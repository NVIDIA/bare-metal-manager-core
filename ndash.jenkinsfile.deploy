@Library(['shared-libs','nvdc-infra-jenkins-shared-lib']) _

String appName = 'carbide'
String tillerNamespace = 'kube-system'
String helmRepository = 'swngc-ngcc-helm'
String datacenterName = "sjc4"
String startTime = utils.getCurrentUTCTime()
String jobPath = utils.extractJobPath(env.BUILD_URL)
int jobNumber = env.BUILD_NUMBER.toInteger()
String team = 'nvmetal'
String project = 'carbide'
String buildLogsUrl = "${env.BUILD_URL}/consoleText"
String registryName = "quay.io/nvidia"

pipeline
{
    agent
    {
        dockerfile
        {
            label 'docker'
            filename 'ndash.build.dockerfile'
            args '-v /etc/passwd:/etc/passwd:ro -v /var/run/docker.sock:/var/run/docker.sock:rw -v /usr/local/bin:/slave_utils'
        }
    }

    parameters
    {
        string(name: 'REF',
               defaultValue: '\${gitlabBranch}',
               description: 'Commit to checkout')
        string(name: 'name',
                defaultValue: '',
                description: 'Name of the deployment environment')
        string(name: 'k8sClusterName',
                defaultValue: '',
                description: 'Name of the cluster to deploy to')
        string(name: 'version',
                defaultValue: '',
                description: 'Version to be deployed')
        string(name: 'callbackUrl',
                defaultValue: '',
                description: 'NDash endpoint to send updates')
    }

    options
    {
        ansiColor('xterm')
        timestamps()
        timeout(time: 1, unit: 'HOURS')
        disableConcurrentBuilds()
    }

    environment
    {
        // Set custom env.HOME so that .gitconfig doesn't go into ~ which is outside of $WORKSPACE
        HOME = "${WORKSPACE}"
        HELM_HOME = "${WORKSPACE}/.helm"
        VERSION = "${params.VERSION}"
    }

    stages
    {
        stage("Prepare Pipeline")
        {
            steps
            {
                prepare(params.keySet() as List)
                script
                {
                    nDashApi.setEndPoint(utils.extractUrlDomainName(params.callbackUrl))
                    environmentName = params.name
                    version = params.version
                    clusterName = params.k8sClusterName
                    callbackUrl = params.callbackUrl
                    currentBuild.description = "deployment to ${environmentName}"
                    cicdaas.updateJobRunApi(callbackUrl, NDashConstants.JobStatus.STARTED, jobPath, jobNumber, startTime)
                    helm.init(helmRepository, tillerNamespace)
                }
            }
        }
        stage('Fetch kubeconfig'){
            steps{
                script{
                    KUBE_HOME = "${HOME}/.kube"
                    
                    datacenter = getNVDCDataCenters()[datacenterName]
                    KUBECONFIG = "${HOME}/.kube/config"
                    sh "mkdir -p ${KUBE_HOME}"
                    // Invoke `nvinit k8s ...` to ensure shared lib kubeconfig
                    // generator has permissions for this cluster.
                    nvinit secretType: "k8s",
                        vaultRole: datacenter.vault.k8s.role,
                        vaultRoleId: datacenter.vault.k8s.role_id,
                        vaultNamespace: datacenter.vault.k8s.namespace
                    // Ensure that the parent directory of the desired kubeconfig output filepath exists.
                    sh "mkdir -p ${new File(KUBECONFIG).getParentFile().getName()}"

                    timeout(time: 20, unit: 'SECONDS') {
                        kubeconfigGenerator(
                            apiServerUrl: clusterName,
                            outputFilename: KUBECONFIG
                        )
                    }
                }
            }
        }
        stage('Download helm chart')
        {
            steps
            {
                script
                {
                    dir('ndash-charts')
                    {
                        helm.downloadAndExtractFilesFromChart(helmRepository, appName, version)
                    }
                }
            }
        }
        stage('Deploy Application')
        {
            environment
            {
                REGISTRY = credentials("quayio_ngc_ro")
                ENV_NAME = "${environmentName}"
            }
            steps
            {
                script
                {
                    sh """
                        skaffold deploy -p ${environmentName} -i ${registryName}/${appName}:${version}
                    """
                }
            }
        }
    }

    post
    {
        always
        {
            script
            {
                pipelineMetadata = []

                switch(currentBuild.currentResult)
                {
                    case "SUCCESS":
                        deployStatus = "success"
                        jobStatus = NDashConstants.JobStatus.SUCCESS
                        pipelineMetadata = [
                            [
                                "key": "version",
                                "value": version
                            ],
                            [
                                "key": "REF",
                                "value": params.REF
                            ]
                        ]
                        break
                    case "FAILURE":
                        deployStatus = "failed"
                        jobStatus = NDashConstants.JobStatus.FAILED
                        break
                    case "ABORTED":
                        deployStatus = "failed"
                        jobStatus = NDashConstants.JobStatus.ABORTED
                        break
                }

                try
                {
                    nDashApi.updateDeploymentStatus(team, project, appName, environmentName, version, deployStatus, ["jobUrl": env.BUILD_URL])
                }
                catch(Exception ex)
                {
                    jobStatus = NDashConstants.JobStatus.FAILED
                    error utils.getStackTrace(ex)
                }
                finally
                {
                    String completionTime = utils.getCurrentUTCTime()
                    cicdaas.updateJobRunApi(params.callbackUrl, jobStatus, jobPath, jobNumber, startTime, completionTime, pipelineMetadata)
                }
            }
            cleanWs()
        }
        failure
        {
            script
            {
                notify.emailBuildFailed()
            }
        }
    }
}
