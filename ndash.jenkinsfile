@Library('shared-libs') _

String baseVersion = '1.0'
String appName = 'vpc'
List<String> appDependencies = []
String tillerNamespace = 'tiller'
String helmRepository = 'swngc-ngcc-helm'
String startTime = utils.getCurrentUTCTime()
String jobPath = utils.extractJobPath(env.BUILD_URL)
int jobNumber = env.BUILD_NUMBER.toInteger()
String team = 'Forge'
String project = 'forge-controller'
String buildLogsUrl = "${env.BUILD_URL}/consoleText"
String environmentName = ""
String defaultBranch = 'main'

pipeline
{
    agent
    {
        dockerfile
        {
            label 'docker'
            filename 'ndash.build.dockerfile'
            args '-v /etc/passwd:/etc/passwd:ro -v /var/run/docker.sock:/var/run/docker.sock:rw'
        }
    }

    parameters
    {
        string(name: 'REF',
               defaultValue: '\${gitlabBranch}',
               description: 'Commit to build')
        string(name: 'callbackUrl',
               defaultValue: '',
               description: 'NDash callback url (will be autogenerated by NDash)')
    }

    options
    {
        ansiColor('xterm')
        timestamps()
        timeout(time: 1, unit: 'HOURS')
        disableConcurrentBuilds()
        gitLabConnection('GitLab Master')
    }

    environment
    {
        // Set custom env.HOME so that .gitconfig doesn't go into ~ which is outside of $WORKSPACE
        HOME = "${WORKSPACE}"
        HELM_HOME = "${WORKSPACE}/.helm"
        GOPATH = "/go"
    }

    stages
    {
        stage("Prepare Pipeline")
        {
            steps
            {
                prepare(params.keySet() as List)
                script
                {
                    nDashApi.setEndPoint(utils.extractUrlDomainName(params.callbackUrl))
                    cicdaas.updateJobRunApi(params.callbackUrl, NDashConstants.JobStatus.STARTED, jobPath, jobNumber, startTime)
                    updateGitlabCommitStatus(name: 'Jenkins CI', state: 'running')
                    helm.init(helmRepository, tillerNamespace)
                    auto_versioning.setTrunk(defaultBranch)
                    environmentName = auto_versioning.currentBranchIsMaster() ? "postmerge" : "premerge"
                }
            }
        }

        stage('Generate Release Tag')
        {
            steps
            {
                script
                {
                    version = auto_versioning.getNextVersion(baseVersion)
                }
            }
        }

        stage('Compile Source')
        {
            steps
            {
                script
                {
                    sh """
                        echo "### build project ###"
                        mkdir -p \${GOPATH}/src/nsv-devops
                        ln -s "${WORKSPACE}" "\${GOPATH}/src/nsv-devops/vpc"
                        make build
                    """
                }
            }
        }

        stage('Run Tests')
        {
            steps
            {
                script
                {
                    sh """
                        echo "### Run tests ###"
                        make test
                    """
                }
            }
        }

        stage('Build & Publish Images')
        {
            environment
            {
                VERSION = "${version}"
            }
            steps
            {
                script
                {
                    docker.withRegistry("https://quay.io", "quayio_ngc_rw")
                    {
                        sh "make publish"
                    }
                }
            }
        }

        stage('Publish Packaged Charts')
        {
            steps
            {
                script
                {
                    dir("${WORKSPACE}/ndash-charts")
                    {
                        helmFlags = [] // pass additional helm flags
                        helmValues = [:] // pass values to be set
                        helmDependencyUpdate = false // pull dependencies (if any) during packaging
                        helm.push(appName, appDependencies, tillerNamespace, version, true, helmFlags, helmValues, 
                            helmRepository, params.REF, helmDependencyUpdate)
                    }
                }
            }
        }

        stage('Update Repository Index')
        {
            steps
            {
                script
                {
                    build job: ArtifactoryConstants.REINDEX_JOB,
                               parameters: [string(name: "REF", value: "master")]
                }
            }
        }

        stage('Push git tags')
        {

            steps
            {
                script
                {
                    auto_versioning.addGitTag(version)
                }
            }
        }
    }

    post
    {
        always
        {
            script
            {
                pipelineMetadata = []

                switch(currentBuild.currentResult)
                {
                    case "SUCCESS":
                        deployStatus = "success"
                        jobStatus = NDashConstants.JobStatus.SUCCESS
                        pipelineMetadata = [
                            [
                                "key": "version",
                                "value": version
                            ],
                            [
                                "key": "REF",
                                "value": params.REF
                            ]
                        ]
                        break
                    case "FAILURE":
                        deployStatus = "failed"
                        jobStatus = NDashConstants.JobStatus.FAILED
                        break
                    case "ABORTED":
                        deployStatus = "failed"
                        jobStatus = NDashConstants.JobStatus.ABORTED
                        break
                }

                try
                {
                    if(deployStatus == "success")
                    {
                        updateGitlabCommitStatus(name: 'Jenkins CI', state: deployStatus)

                        String downloadUrl = nDashApi.buildDownloadUrl(appName, version)
                        String packageId = nDashApi.createPackage(team, project, appName, version,
                                        env.BUILD_URL, downloadUrl, buildLogsUrl)
                        nDashApi.updateDeploymentStatus(team, project, appName, environmentName, version, deployStatus, ["jobUrl": env.BUILD_URL])
                    }
                }
                catch(Exception ex)
                {
                    jobStatus = NDashConstants.JobStatus.FAILED
                    error utils.getStackTrace(ex)
                }
                finally
                {
                    String completionTime = utils.getCurrentUTCTime()
                    cicdaas.updateJobRunApi(params.callbackUrl, jobStatus, jobPath, jobNumber, startTime, completionTime, pipelineMetadata)
                }
            }
            cleanWs()
        }
        failure
        {
            script
            {
                notify.emailBuildFailed()
            }
        }
    }
}
