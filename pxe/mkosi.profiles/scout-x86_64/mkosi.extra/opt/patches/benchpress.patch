diff --git a/framework/cli/commands/run.py b/framework/cli/commands/run.py
index 300c666..80824fd 100644
--- a/framework/cli/commands/run.py
+++ b/framework/cli/commands/run.py
@@ -198,11 +198,11 @@ class RunCommand(BenchpressCommand):
                 continue
             job = all_jobs[job_name]
             logger.info(f"Running {job.name}: {job.description}")
-            metrics = job.run(args.dry_run)
+            metrics, returncode = job.run(args.dry_run)
             if job.report_metrics:
                 if args.dry_run:
                     logger.info(f"Will report metrics with prefix {job.run_prefix}")
                 else:
                     reporter.report(job, metrics)
         reporter.close()
-        return 0
+        return returncode
diff --git a/framework/cli/main.py b/framework/cli/main.py
index 7901997..7994b03 100644
--- a/framework/cli/main.py
+++ b/framework/cli/main.py
@@ -10,6 +10,7 @@
 import argparse
 import logging
 import sys
+import os
 
 import yaml
 from framework.cli.commands.list import ListCommand
@@ -58,6 +59,8 @@ def setup_parser():
 
 # ignore sys.argv[0] because that is the name of the program
 def main(args=sys.argv[1:]):
+    os.chdir('/opt/benchpress')
+
     parser = setup_parser()
     args = parser.parse_args(args)
 
diff --git a/framework/lib/job.py b/framework/lib/job.py
index ed9a9d5..941b007 100644
--- a/framework/lib/job.py
+++ b/framework/lib/job.py
@@ -120,18 +120,20 @@ class Job(object):
                 stdout, stderr = process.stdout, process.stderr
                 returncode = process.returncode
 
-            # write the output log
-            logfile_path = get_filepath(self.run_prefix, "log", "txt")
+            logfile_path = get_filepath(self.name, "stdout", "txt")
             with open(logfile_path, "wt") as fp:
-                fp.write("================ stdout ================\n")
                 for line in stdout.splitlines():
                     fp.write(f"{line}\n")
-                fp.write("================ stderr ================\n")
+                logger.info(f"Raw stdout written to {logfile_path}")
+            logfile_path = get_filepath(self.name, "stderr", "txt")
+            with open(logfile_path, "wt") as fp:
                 for line in stderr.splitlines():
                     fp.write(f"{line}\n")
-                logger.info(f"Raw output written to {logfile_path}")
+                logger.info(f"Raw stderr written to {logfile_path}")
+
             # parse the output log for metrics
             logger.info(f"Parsing results for {self.name}")
+            logger.info(f"returncode {returncode}")
             try:
                 metrics = self.parser.parse(
                     stdout.splitlines(), stderr.splitlines(), returncode
@@ -158,7 +160,7 @@ class Job(object):
                 # run hooks in reverse this time so it operates like a stack
                 for hook, opts in reversed(self.hooks):
                     hook.after_job(opts, self)
-        return metrics
+        return metrics, returncode
 
     @property
     def safe_name(self):
