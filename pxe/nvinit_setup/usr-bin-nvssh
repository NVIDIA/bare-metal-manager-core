#!/bin/bash
umask 0077
script_version=1.0.0
# load the config file
source /etc/nvssh/nvssh.conf

nvssh_authorized_principals_check_help() {
  cat << EOF
  Usage: ${0} authorized-principals-check -i key-id -u username -k cert [ -t cert-type -T cakey-type -h ]
  Options:
    -i   The key ID in the certificate
    -u   SSH user name
    -k   The base64-encoded key or certificate for authentication
    -t   The key or certificate type
    -T   The type of the CA key
    -h   Help
    -v   Version
  Example (sshd_config file):
    AuthorizedPrincipalsCommand /usr/local/sbin/${0} -i %i -u %u -k %k [ -T %T -t %t ]

EOF
}

# compare submitted_list with permitted_list
# return 0 if a (regex) match found,
# return 1 if no match found
# return 2 for input/parse errors
# Example usage:
#   out=$(nvssh_permission_check ${permitted_roles} ${user_roles})
#   status=$?
#     if [ $status -ne 0 ]; then
#       logger -p auth.info --id "PPID=$$ info: ${0}: ${out}"
#       return
#     fi
function nvssh_permission_check() {
  local permitted_list="$1"
  local submitted_list="$2"

  # remove whitespaces
  submitted_list_no_ws="$(echo -e "${submitted_list}" | tr -d '[:space:]')"
  IFS=',' read -r -a submitted_array <<< "$submitted_list_no_ws"
  for s in "${submitted_array[@]}"; do

    submitted_regex="^[-_a-zA-Z0-9*\.]{1,255}$"
    if ! [[ "$s" =~ $submitted_regex ]]; then
      echo "input validation failed. INPUT:${s}, REGEX:${submitted_regex}"
      return 2
    fi

    permitted_list_no_ws="$(echo -e "${permitted_list}" | tr -d '[:space:]')"
    IFS=',' read -r -a permitted_array <<< "$permitted_list_no_ws"
    for p in "${permitted_array[@]}"; do

      # check if permitted contains '*' (permit all)
      if [[ "$p" == "*" ]]; then
        echo "match_found"
        return 0
      fi

      # if permitted matches with
      local s_formatted="^${s/\*/.*}$"
      if [[ "$p" =~ $s_formatted ]]; then
        echo "match_found"
        return 0
      fi

    done
  done

  echo "no_match_found"
  return 1
}

function is_user_authorized() {
  local user_name="$1"
  local user_roles="$2"
  local optional_error_msg="$3"
  local authorized=false
  local sudo_user=false
  local sudo_nopasswd_user=false

  declare -a permitted_list
  declare -a submitted_list
  declare -a sudo_list
  declare -a sudo_nopasswd_list
  if [ -f "$nvssh_tmp_access_conf_file" ]; then
    logger -p auth.info --id "PPID=$$ info: ${0}: ${nvssh_tmp_access_conf_file} exists, loading it.."
    source "$nvssh_tmp_access_conf_file"
    permitted_list=("$nvssh_allowed_sudo_nopasswd_roles" "$nvssh_allowed_sudo_roles" "$nvssh_tmp_allowed_sudo_users" "$nvssh_allowed_roles" "$nvssh_tmp_allowed_users")
    submitted_list=("$user_roles" "$user_roles" "$user_name" "$user_roles" "$user_name")
    sudo_list=(true true true false false)
    sudo_nopasswd_list=(true false false false false)
  else
    permitted_list=("$nvssh_allowed_sudo_nopasswd_roles" "$nvssh_allowed_sudo_roles" "$nvssh_allowed_roles")
    submitted_list=("$user_roles" "$user_roles" "$user_roles")
    sudo_list=(true true false)
    sudo_nopasswd_list=(true false false)
  fi

  for i in "${!permitted_list[@]}"; do
    msg=$(nvssh_permission_check "${permitted_list[$i]}" "${submitted_list[$i]}")
    local status=$?
    logger -p auth.info --id "PPID=$$ info: ${0}: ${msg}"
    if [ $status -eq 2 ]; then
      logger -p auth.info --id "PPID=$$ error: ${0}: ${optional_error_msg} ${msg}"
      exit 1
    fi

    if [ $status -eq 0 ]; then
      authorized=true
      if [ "${sudo_list[$i]}" = true ]; then
        sudo_user=true
      fi
      if [ "${sudo_nopasswd_list[$i]}" = true ]; then
        sudo_nopasswd_user=true
        break # no need to check further if user is authorized with sudo nopasswd
      fi
    fi
  done

  if [ "$authorized" = false ] ; then
    logger -p auth.info --id "PPID=$$ info: ${0}: USER:${user_name} Unauthorized: no matching roles found for: ${user_roles} nvssh_allowed_sudo_roles: ${nvssh_allowed_sudo_roles}, nvssh_allowed_sudo_nopasswd_roles: ${nvssh_allowed_sudo_nopasswd_roles}, nvssh_allowed_roles: ${nvssh_allowed_roles}"
    exit 1
  fi

  # user already exists elsewhere - e.g. in LDAP, NIS etc.
  if [ "$nvssh_nssswitch_plugin" = false ] ; then
    id "${user_name}" 1>/dev/null 2>&1
    status=$?
    if [ $status -ne 0 ]; then
      logger -p auth.err --id "PPID=$$ error: ${0}: USER:${user_name} doesn't exist; authentication failed, exiting.."
      exit 1
    fi
  else
    # create user in /etc/passwd if it doesn't exist
    # check whether the user exists
    grep "^${user_name}:" /etc/passwd
    status=$?
    if [ $status -eq 0 ]; then
      logger -p auth.info --id "PPID=$$ info: ${0}: USER:${user_name} already exists; user creation skipped.."
    else
      # check to make sure temp account exists, and rename to actual username
      grep "^${user_name}-temp:" /etc/passwd
      status=$?
      if [ $status -ne 0 ]; then
        logger -p auth.err --id "PPID=$$ error: ${0}: USER:${user_name}-temp doesn't exist; exiting.."
        exit 1
      fi

      # user is authenticated, now convert temp user to actual logged in user
      /usr/sbin/lusermod -d "/home/${user_name}" -l "${user_name}"  -s "${nvssh_default_shell}" -c "nvssh nssswitch user account" "${user_name}-temp"
      status=$?
      if [ $status -ne 0 ]; then
        logger -p auth.err --id "PPID=$$ error: ${0}: USER:${user_name} lusermod failed; exiting.."
        exit 1
      fi

      # this is NOT a password, but merely a way to get user
      # confirmation before they execute commands as root user
      echo "${user_name}:y" | /usr/sbin/chpasswd
      status=$?
      if [ $status -ne 0 ]; then
        logger -p auth.err --id "PPID=$$ error: ${0}: USER:${user_name} failed to add sudo password"
        exit 1
      fi
    fi
  fi

  ## User is authorized, is sudo-nopasswd -> add to nvssh-sudo-nopasswd group:
  if [[ "$sudo_nopasswd_user" = true ]] ; then
    logger -p auth.info --id "PPID=$$ info: ${0}: match found in nvssh_[tmp_]allowed_sudo_nopasswd_roles for ${user_name}; access granted"
    /usr/bin/gpasswd -a "${user_name}" "nvssh-sudo-nopasswd"
    status=$?
    if [ $status -ne 0 ]; then
      logger -p auth.err --id "PPID=$$ error: ${0}: USER:${user_name} gpasswd add to nvssh-sudo-nopasswd group failed; exiting.."
      exit 1
    fi
  ## User is authorized, is sudo, and is NOT sudo-nopasswd -> add to nvssh-sudo group:
  elif [[ "$sudo_user" = true ]] ; then
    logger -p auth.info --id "PPID=$$ info: ${0}: match found in nvssh_[tmp_]allowed_sudo_roles for ${user_name}; access granted"
    /usr/bin/gpasswd -a "${user_name}" "nvssh-sudo"
    status=$?
    if [ $status -ne 0 ]; then
      logger -p auth.err --id "PPID=$$ error: ${0}: USER:${user_name} gpasswd add to nvssh-sudo group failed; exiting.."
      exit 1
    fi
  ## User is authorized, is NOT sudo, and is NOT sudo-nopasswd -> remove from custom sudo groups:
  else
    logger -p auth.info --id "PPID=$$ info: ${0}: match found in nvssh_[tmp_]allowed_roles for ${user_name}; access granted"
    /usr/bin/gpasswd -d "${user_name}" "nvssh-sudo"
    /usr/bin/gpasswd -d "${user_name}" "nvssh-sudo-nopasswd"
    status=$?
    if [ $status -ne 0 ]; then
      logger -p auth.info --id "PPID=$$ info: ${0}: gpasswd USER:${user_name} is not a member of 'nvssh-sudo'; continue.."
    fi
  fi

  return 0
}

function cmd_authorized_principals_check() {
  local key_id="$1"
  local user_name="$2"
  local cert="$3"
  local cert_type="$4"
  local ca_type="$5"

  if [ -z "${user_name}" ]; then
    logger -p auth.err --id "PPID=$$ error: ${0}: missing cmd-line parameter: -u (SSH user name)"
    cmd_sshcert_auth_failed "${user_name}"
  fi

  if [ -z "${key_id}" ]; then
    logger -p auth.err --id "PPID=$$ error: ${0}: missing cmd-line parameter: -i (Key ID)"
    cmd_sshcert_auth_failed "${user_name}"
  fi

  if [ -z "${cert}" ]; then
    logger -p auth.err --id "PPID=$$ error: ${0}: missing cmd-line parameter: -k (SSH user cert)"
    cmd_sshcert_auth_failed "${user_name}"
  fi

  local key_id_len
  key_id_len=${#key_id}
  if [[ $key_id_len -lt 8 ]] || [[ $key_id_len -gt 4096 ]]; then
    logger -p auth.err --id "PPID=$$ error: ${0}: KEYID:${key_id} input validation failed. Length of ${key_id_len} not between 8-4096"
    cmd_sshcert_auth_failed "${user_name}"
  fi

  local -r key_id_regex="^[-a-zA-Z0-9_@= \.\*,]+$"
  if ! [[ "${key_id}" =~ $key_id_regex ]]; then
    logger -p auth.err --id "PPID=$$ error: ${0}: KEYID:${key_id} input validation failed. REGEX:${key_id_regex}"
    cmd_sshcert_auth_failed "${user_name}"
  fi

  local kuser=""
  local kroles=""

  for kid in ${key_id}; do
    IFS='=' read -r -a array <<< "${kid}"
    if [ ${#array[@]} -eq 2 ]; then
      case "${array[0]}" in

      user)
        kuser=${array[1]}
        ;;
      roles)
        kroles=${array[1]}
        ;;
      esac
    fi
  done

  if [ -z "${kuser}" ]; then
    logger -p auth.err --id "PPID=$$ error: ${0}: missing field(s) in Key-ID (user): KEYID:${key_id}"
    cmd_sshcert_auth_failed "${user_name}"
  fi

  if [ -z "${kroles}" ]; then
    logger -p auth.err --id "PPID=$$ error: ${0}: missing field(s) in Key-ID (roles): KEYID:${key_id}"
    cmd_sshcert_auth_failed "${user_name}"
  fi

  local user_matches=false
  local user_cert
  local principals
  local user_name_matched="$user_name"
  user_cert=$(echo "${cert_type} ${cert}" | ssh-keygen -L -f - | tr -d '\n' | tr -s ' ')
  principals=$(echo "$user_cert" | grep -o -P '(?<=Principals: ).*(?= Critical Options:)')
  IFS=' ' read -r -a principals_array <<< "${principals}"
  for p in "${principals_array[@]}"; do
    # hack: in some cases (e.g. vault jwt-auth), the principal may contain email (@email.com)
    # suffix and we need to remove the email suffix from the user name
    principal=$(echo -n "${p}" | cut -d "@" -f1)
    if [ "$principal" = "$user_name" ]; then
      user_matches=true
      user_name_matched="$p"
      break
    fi
  done

  if [ "$user_matches" = false ] ; then
    logger -p auth.err --id "PPID=$$ error: ${0}: username mismatch cert principals:${principals} username:${user_name}"
    cmd_sshcert_auth_failed "${user_name}"
  fi

  # authentication is complete, now check the authorization
  is_user_authorized "$user_name" "$kroles" "KEYID:${key_id}"
  status=$?
  if [ $status -ne 0 ]; then
    logger -p auth.info --id "PPID=$$ error: ${0}: KEYID:${key_id} Unexpected error"
    cmd_sshcert_auth_failed "${user_name}"
  fi

  echo "$user_name_matched"
}

function cmd_sshcert_auth_failed() {
  local user_name="$1"
  if [ "$nvssh_pam_auth_plugin" = false ] ; then
    cmd_auth_failed "${user_name}"
  fi
  exit 1
}

function cmd_pam_otp_auth() {
  # Vault OTP token validator. If the OTP is valid, Vault
  # returns userid and the role associated with the OTP.
  # This script compares userid with PAM_USER and role with
  # nvssh_[tmp_]allowed_[sudo_][roles|user], defined in /etc/nvssh/nvssh.conf

  local otp
  local vault_url
  local otp_out
  local user_name
  local role_name
  # read OTP from user
  read -r name
  otp=$(echo -n "${name}")
  vault_url="${nvssh_vault_addr}/v1/${nvssh_vault_namespace}/${nvssh_vault_ssh_mount_point}/verify"

  otp_out=$(curl -s --request POST -H 'Content-Type: application/json' -d "{ \"otp\": \"${otp}\" }" "$vault_url")
  user_name=$(echo "${otp_out}" | jq -r .data.username)
  role_name=$(echo "${otp_out}" | jq -r .data.role_name)

  if [[ "$user_name" == "null" ]]; then
    logger -p auth.err --id "PPID=$$ error: ${0}: Vault OTP user_name validation failed (role/user unauthorized?) PAM_USER:${PAM_USER}"
    exit 1
  fi

  if [[ "$role_name" == "null" ]]; then
    logger -p auth.err --id "PPID=$$ error: ${0}: Vault OTP role_name validation failed PAM_USER:${PAM_USER}"
    exit 1
  fi

  if [[ "$PAM_USER" != "$user_name" ]]; then
    logger -p auth.err --id "PPID=$$ error:  ${0}: Username mismatch PAM_USER:${PAM_USER} user_name:${user_name}"
    exit 1
  fi

  # function call
  is_user_authorized "$user_name" "$role_name" "PAM_USER:${PAM_USER}"
  status=$?
  if [ $status -ne 0 ]; then
    logger -p auth.info --id "PPID=$$ error: ${0}: KEYID:${key_id} Unexpected error"
    exit 1
  fi

  # success
  exit 0
}

function cmd_pam_otp_auth_failed() {
  # If public-key/CA and PAM auth (Vault OTP) fails,
  # delete temp user created by nss_nvssh
  #
  cmd_auth_failed "${PAM_USER}"
  exit 0
}

function cmd_auth_failed() {
  local user_name="$1"

  # Assume the user management is handled by a different system (e.g. NIS, LDAP etc.)
  if [ "$nvssh_nssswitch_plugin" = false ] ; then
    return
  fi

  # check if the temp account exists, and remove it
  grep "^${user_name}-temp:" /etc/passwd
  status=$?
  if [ $status -ne 0 ]; then
    logger -p auth.info --id "PPID=$$ info: ${0}: USER:${user_name}-temp doesn't exist; exiting.."
    return
  fi

  /usr/sbin/luserdel "${user_name}-temp"
  status=$?
  if [ $status -ne 0 ]; then
    logger -p auth.info --id "PPID=$$ error: ${0}: USER:${user_name}-temp luserdel failed; exiting.."
    return
  fi

}

function main() {
  local key_id=""
  local user_name=""
  local cert=""
  local cert_type=""
  local ca_type=""

  # delete temp access file if the file is older than nvssh_tmp_access_max_time_in_days
  if [ -f "$nvssh_tmp_access_conf_file" ]; then

    if [ $nvssh_tmp_access_max_time_in_days -gt 30 ]; then
      find "$nvssh_tmp_access_conf_file" --mtime +30 -delete
    elif [ $nvssh_tmp_access_max_time_in_days -lt 1 ]; then
      find "$nvssh_tmp_access_conf_file" --mtime +1 -delete
    else
      find "$nvssh_tmp_access_conf_file" --mtime +${nvssh_tmp_access_max_time_in_days} -delete
    fi

    if [ ! -f "$nvssh_tmp_access_conf_file" ]; then
      logger -p auth.info --id "PPID=$$ info: ${0}: The temp user access file: ${nvssh_tmp_access_conf_file} expired, removing it.."
    fi
  fi

  # Parse options
  while getopts ":h" opt; do
    case ${opt} in
      h )
	      cat << EOF
  Usage: ${0} sub-command [options]

    ${0} nvssh authorized-principals-check -i key-id -u username -k cert [ -t cert-type -T cakey-type -h ]
    Options:
      -i   The key ID in the certificate
      -u   SSH user name (e.g. bouncer user)
      -k   The base64-encoded key or certificate for authentication
      -t   The key or certificate type
      -T   The type of the CA key
      -h   Help
      -v   Version
  Example (sshd_config file):
    AuthorizedPrincipalsCommand ${0} authorized-principals-check -i %i -u %u -k %k [ -T %T -t %t ]

    ${0} pam-otp-auth
  Example (pam.d/sshd PAM file)
    auth sufficient pam_exec.so quiet expose_authtok log=/var/log/vault-otp-auth.log ${0} pam-otp-auth

    ${0} pam-otp-auth-failed
  Example (pam.d/sshd PAM file)
    auth [default=ignore] pam_exec.so ${0} pam-otp-auth-failed

EOF
        exit 0
        ;;
      \? )
        echo "Invalid Option: -$OPTARG" 1>&2
        exit 1
        ;;
    esac
  done
  shift $((OPTIND -1))

  subcommand=$1; shift
  case "$subcommand" in
    authorized-principals-check)
      while getopts "hvi:u:k:t:T:" opt; do
      case "$opt" in
        h)
          nvssh_authorized_principals_check_help
          exit 0
          ;;
        v)
          echo "nvssh_authorized_principals_check v${script_version}"
          exit 0
          ;;
        i) key_id=$OPTARG
          ;;
        u) user_name=$OPTARG
          ;;
        k) cert=$OPTARG
          ;;
        t) cert_type=$OPTARG
          ;;
        T) ca_type=$OPTARG
          ;;
        '?')
          nvssh_authorized_principals_check_help >&2
          exit 1
          ;;
        esac
      done

      shift $((OPTIND -1))
      cmd_authorized_principals_check "$key_id" "$user_name" "$cert" "$cert_type" "$ca_type"
      ;;
    pam-otp-auth)
	    cmd_pam_otp_auth
	    ;;
    pam-otp-auth-failed)
      cmd_pam_otp_auth_failed
      ;;
  esac
}

# main
main "$@"
