## @section Global parameters
## Global Docker image parameters
## Please, note that this will override the image parameters, including dependencies, configured to use the global value
## Current available global Docker image parameters: imageRegistry, imagePullSecrets and storageClass
##

global:
  imageRegistry: ""
  # global.imageRegistry -- Global Docker image registry
  imagePullSecrets: []
  # global.imagePullSecrets -- Global Docker registry secret names as an array
  storageClass: ""
  # global.storageClass -- Global StorageClass for Persistent Volume(s)

kubeVersion: ""
# kubeVersion -- Override Kubernetes version
nameOverride: "carbide-api"
# nameOverride -- String to partially override common.names.name
fullnameOverride: "carbide-api"
# fullnameOverride -- String to fully override common.names.fullname
namespaceOverride: ""
# namespaceOverride -- String to fully override common.names.namespace
commonLabels: {}
# commonLabels -- Labels to add to all deployed objects
commonAnnotations: {}
# commonAnnotations -- Annotations to add to all deployed objects
clusterDomain: cluster.local
# clusterDomain -- Kubernetes cluster domain name
extraDeploy: []
# extraDeploy -- Array of extra objects to deploy with the release
listenAddress: "0.0.0.0"
# listenAddress -- What IP address to bind and listen on
useTLS: false
# useTLS -- Enable TLS for incoming connections to GRPC endpoint
# NOTE container will fail to start if certificate is not present
databaseName: '{{ include "common.names.namespace" . | replace "-" "_" }}_carbide'
# name of the database that carbide-api connects to
# NOTE: Uses the zalando postgres-operator - https://github.com/zalando/postgres-operator
postgresConfigMapName: '{{ tpl .Values.databaseName . | replace "_" "-" }}-database-config'
# postgresCOnfigMapname -- As part of the database creation a configMap is created that stores connection details
postgresClusterName: forge-pg-cluster
# postgresClusterName -- Name of the postgres cluster (not the database name)
postgresSecretRef: '{{ include "common.names.namespace" . }}.carbide.{{ tpl .Values.postgresClusterName . }}.credentials.postgresql.acid.zalan.do'
# postgresSecretRef -- As part of the database creation a secret is created which stores a the credentials for connecting to postgres
dhcpServerIp: "169.254.254.254"
# dhcpserver -- IP Address of DHCP server
authPermissiveMode: false
# authPermissiveMode -- Override the auth engine when it denies a request, and permit anything.
manageVpc: false
# manageVpc -- Choose whether Carbide owns the VPC data: loopback IP, VNI and VLAN_ID allocations. False means VPC will allocate those values
identityKeyfilePath: /run/secrets/spiffe.io/tls.key
# identityKeyfilePath: where the server's identity key file is located on disk
identityPemfilePath: /run/secrets/spiffe.io/tls.crt
# identityPemfilePath: where the server's identity PEM file is located on disk
trustDomain: forge.local
# trustDomain -- spiffe trust domain

diagnosticMode:
  enabled: false
  # diagnosticMode.enabled -- Enable diagnostic mode (all probes will be disabled and the command will be overridden)
  command:
    # diagnosticMode.command -- Command to override all containers in the deployment
    - sleep
  args:
    # diagnosticMode.args -- Args to override all containers in the deployment
    - infinity

container:
  image:
    registry: nvcr.io
    # carbideApi.image.registry -- carbide image registry
    repository: nvidian/nvforge/nvmetal-carbide
    # carbideApi.image.repository -- carbide image repository
    tag: latest
    # carbideApi.image.tag -- carbide image tag (immutable tags are recommended)
    digest: ""
    # carbideApi.image.digest -- carbide image digest in the way sha256:aa.... Please note this parameter, if set, will override the tag image tag (immutable tags are recommended)
    pullPolicy: IfNotPresent
    # carbideApi.image.pullPolicy -- carbide image pull policy
    # Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'
    # ref: http://kubernetes.io/docs/user-guide/images/#pre-pulling-images
    pullSecrets:
      - imagepullsecret
    # carbideApi.image.pullSecrets -- carbide image pull secrets
    #
    # Secrets must be manually created in the namespace.
    # ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    # e.g:
    # pullSecrets:
    #   - myRegistryKeySecretName
    debug: false
    # carbideApi.image.debug -- Enable carbide image debug mode

  replicaCount: 1
  # carbideApi.replicaCount -- Number of carbide replicas to deploy
  containerPorts:
    grpc: 1079
    # carbideApi.containerPorts.grpc -- GRPC container port

  livenessProbe:
    # -- Configure extra options for carbide containers' liveness and readiness probes
    # ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/#configure-probes
    httpGet:
      scheme: "HTTP" # it's http because it's hitting the metrics port
      port: 1080
    # carbideApi.livenessProbe.httpGet.scheme -- Scheme to use for connecting to the host (HTTP or HTTPS)
    enabled: true
    # carbideApi.livenessProbe.enabled -- Enable livenessProbe on containers
    initialDelaySeconds: 20
    # carbideApi.livenessProbe.initialDelaySeconds -- Initial delay seconds for livenessProbe
    periodSeconds: 10
    # livenessProbe.periodSeconds -- Period seconds for livenessProbe
    timeoutSeconds: 5
    # livenessProbe.timeoutSeconds -- Timeout seconds for livenessProbe
    failureThreshold: 2
    # livenessProbe.failureThreshold -- Failure threshold for livenessProbe
    successThreshold: 1
    # livenessProbe.successThreshold -- Success threshold for livenessProbe

  readinessProbe:
    enabled: false
    # carbideApi.readinessProbe.enabled -- Enable readinessProbe on containers
    initialDelaySeconds: 30
    # carbideApi.readinessProbe.initialDelaySeconds -- Initial delay seconds for readinessProbe
    periodSeconds: 5
    # carbideApi.readinessProbe.timeoutSeconds -- Timeout seconds for readinessProbe
    timeoutSeconds: 30
    # carbideApi.readinessProbe.timeoutSeconds -- Timeout seconds for readinessProbe
    failureThreshold: 3
    # carbideApi.readinessProbe.failureThreshold -- Failure threshold for readinessProbe
    successThreshold: 2
    # carbideApi.readinessProbe.successThreshold -- Success threshold for readinessProbe

  startupProbe:
    enabled: false
    # carbideApi.startupProbe.enabled -- Enable startupProbe on carbide containers
    initialDelaySeconds: 30
    # caribdeApi.startupProbe.initialDelaySeconds -- Initial delay seconds for startupProbe
    periodSeconds: 5
    # carbideApi.startupProbe.periodSeconds -- Period seconds for startupProbe
    timeoutSeconds: 30
    # carbideApi.startupProbe.timeoutSeconds -- Timeout seconds for startupProbe
    failureThreshold: 2
    # carbideApi.startupProbe.failureThreshold -- Failure threshold for startupProbe
    successThreshold: 2
    # carbideApi.startupProbe.successThreshold -- Success threshold for startupProbe

  customLivenessProbe: {}
  # carbideApi.customLivenessProbe -- Custom livenessProbe that overrides the default one
  customReadinessProbe: {}
  # carbideApi.customReadinessProbe -- Custom readinessProbe that overrides the default one
  customStartupProbe: {}
  # carbideApi.customStartupProbe -- Custom startupProbe that overrides the default one

  resources:
    # -- container resource requests and limits
    # ref: http://kubernetes.io/docs/user-guide/compute-resources/
    limits: {}
    # carbideApi.resources.limits -- The resources limits for the carbide containers
    requests: {}
    # carbideApi.resources.requests -- The requested resources for the carbide containers

  podSecurityContext:
    # -- Configure Pods Security Context
    # ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod
    enabled: false
    # carbideApi.podSecurityContext.enabled -- Enabled carbide pods' Security Context
    fsGroup: 1001
    # carbideApi.podSecurityContext.fsGroup -- Set carbide pod's Security Context fsGroup

  containerSecurityContext:
    # -- Configure Container Security Context
    # ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container
    enabled: false
    # carbideApi.containerSecurityContext.enabled -- Enabled containers' Security Context
    runAsUser: 1001
    # carbideApi.containerSecurityContext.runAsUser -- Set containers' Security Context runAsUser
    runAsNonRoot: true
    # carbideApi.containerSecurityContext.runAsNonRoot -- Set containers' Security Context runAsNonRoot
    readOnlyRootFilesystem: false
    # carbideApi.containerSecurityContext.readOnlyRootFilesystem -- Set containers' Security Context runAsNonRoot

  existingConfigmap:
  # carbideApi.existingConfigmap -- The name of an existing ConfigMap with your custom configuration for carbide
  command: []
    # carbideApi.command -- Override default container command (useful when using custom images)
    #- /bin/sh
    #- -c
    #- /opt/carbide/carbide-api run --datastore="postgresql://${CARBIDE_API_DATASTORE_USERNAME}:${CARBIDE_API_DATASTORE_PASSWORD}@${CARBIDE_API_DATASTORE_SERVICE_NAME}/forge-carbide" --listen="0.0.0.0:1079"
  args: []
  # carbideApi.args -- Override default container args (useful when using custom images)
  hostAliases: []
  # carbideApi.hostAliases -- carbide pods host aliases
  # https://kubernetes.io/docs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-host-aliases/
  podLabels:
    carbide_api_pod: "yes"
    forge_pod: "yes"
  # carbideApi.podLabels -- Extra labels for carbide pods
  # ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  podAnnotations: {}
  # carbideApi.podAnnotations -- Annotations for carbide pods
  # ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
  podAffinityPreset: ""
  # carbideApi.podAffinityPreset -- Pod affinity preset. Ignored if `carbideApi.affinity` is set. Allowed values: `soft` or `hard`
  # ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity
  podAntiAffinityPreset: soft
  # carbideApi.podAntiAffinityPreset -- Pod anti-affinity preset. Ignored if `carbideApi.affinity` is set. Allowed values: `soft` or `hard`
  # ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity

  pdb:
    # -- Pod Disruption Budget configuration
    # ref: https://kubernetes.io/docs/tasks/run-application/configure-pdb
    create: false
    # carbideApi.pdb.create -- Enable/disable a Pod Disruption Budget creation
    minAvailable: 1
    # carbideApi.pdb.minAvailable -- Minimum number/percentage of pods that should remain scheduled
    maxUnavailable: ""
    # carbideApi.pdb.maxUnavailable -- Maximum number/percentage of pods that may be made unavailable

  autoscaling:
    # -- Autoscaling configuration
    # ref: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/
    enabled: false
    # carbideApi.autoscaling.enabled -- Enable autoscaling for carbideApi
    minReplicas: ""
    # carbideApi.autoscaling.minReplicas -- Minimum number of carbideApi replicas
    maxReplicas: ""
    # carbideApi.autoscaling.maxReplicas -- Maximum number of carbideApi replicas
    targetCPU: ""
    # carbideApi.autoscaling.targetCPU -- Target CPU utilization percentage
    targetMemory: ""
    # carbideApi.autoscaling.targetMemory -- Target Memory utilization percentage

  nodeAffinityPreset:
    # -- Node carbideApi.affinity preset
    # ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity
    type: ""
    # carbideApi.nodeAffinityPreset.type -- Node affinity preset type. Ignored if `carbideApi.affinity` is set. Allowed values: `soft` or `hard`
    key: ""
    # carbideApi.nodeAffinityPreset.key -- Node label key to match. Ignored if `carbideApi.affinity` is set
    values: []
    # carbideApi.nodeAffinityPreset.values -- Node label values to match. Ignored if `carbideApi.affinity` is set

  affinity: {}
  # carbideApi.affinity -- Affinity for carbide pods assignment
  # ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
  # NOTE: `podAffinityPreset`, `podAntiAffinityPreset`, and `nodeAffinityPreset` will be ignored when it's set
  nodeSelector: {}
  # carbideApi.nodeSelector -- Node labels for carbide pods assignment
  # ref: https://kubernetes.io/docs/user-guide/node-selection/
  tolerations: []
  # carbideApi.tolerations -- Tolerations for carbide pods assignment
  # ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  updateStrategy:
    # carbideApi.updateStrategy.type -- carbide statefulset strategy type
    # ref: https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#update-strategies
    type: RollingUpdate
    # -- StrategyType
    # Can be set to RollingUpdate or OnDelete

  podManagementPolicy: OrderedReady
  # carbideApi.podManagementPolicy -- Statefulset Pod management policy, it needs to be Parallel to be able to complete the cluster join
  # ONLY FOR STATEFULSETS
  # Ref: https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#pod-management-policies
  priorityClassName: ""
  # carbideApi.priorityClassName -- carbide pods' priorityClassName
  topologySpreadConstraints: []
  # carbideApi.topologySpreadConstraints -- Topology Spread Constraints for pod assignment spread across your cluster among failure-domains. Evaluated as a template
  # Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/#spread-constraints-for-pods
  schedulerName: ""
  # carbideAPi.schedulerName -- Name of the k8s scheduler (other than default) for carbide pods
  # ref: https://kubernetes.io/docs/tasks/administer-cluster/configure-multiple-schedulers/
  terminationGracePeriodSeconds: ""
  # carbideApi.terminationGracePeriodSeconds -- Seconds Redmine pod needs to terminate gracefully
  # ref: https://kubernetes.io/docs/concepts/workloads/pods/pod/#termination-of-pods
  lifecycleHooks: {}
  # carbideApi.lifecycleHooks -- for the carbide container(s) to automate configuration before or after startup
  extraEnvVars: []
  # carbideApi.extraEnvVars -- Array with extra environment variables to add to carbide nodes
  extraEnvVarsCM: ""
  # carbideApi.extraEnvVarsCM -- Name of existing ConfigMap containing extra env vars for carbide nodes
  extraEnvVarsSecret: ""
  # carbideApi.extraEnvVarsSecret -- Name of existing Secret containing extra env vars for carbide nodes
  extraVolumes: []
  # carbideApi.extraVolumes -- Optionally specify extra list of additional volumes for the carbide pod(s)
  extraVolumeMounts: []
  # carbideApi.extraVolumeMounts -- Optionally specify extra list of additional volumeMounts for the carbide container(s)
  sidecars: []
  # carbideApi.sidecars -- Add additional sidecar containers to the carbide pod(s)
  # e.g:
  # sidecars:
  #   - name: your-image-name
  #     image: your-image
  #     imagePullPolicy: Always
  #     ports:
  #       - name: portname
  #         containerPort: 1234
  initContainers: []
  # carbideApi.initContainers -- Add additional init containers to the carbide pod(s)
  # ref: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
  # e.g:
  # initContainers:
  #  - name: your-image-name
  #    image: your-image
  #    imagePullPolicy: Always
  #    command: ['sh', '-c', 'echo "hello world"']

## %%SECONDARY_CONTAINER/POD_DESCRIPTION%%
##
#%%SECONDARY_OBJECT_BLOCK%%: %%SAME_STRUCTURE_AS_THE_MAIN_CONTAINER/POD%%

## %%OTHERS_CONTAINER/POD_DESCRIPTION%%
##
#%%OTHER_OBJECT_BLOCK%%: %%SAME_STRUCTURE_AS_THE_MAIN_CONTAINER/POD%%

## @section Traffic Exposure Parameters
##

service:
  type: ClusterIP
  # service.type -- carbide service type
  ports:
    grpc: 1079
    # service.ports.grpc -- carbide service grpc port
  nodePorts:
    # service.nodePorts -- Node ports to expose
    # NOTE: choose port between <30000-32767>
    grpc: 31079
    # service.nodePorts.grpc -- Node port for grpc
  clusterIP: ""
  # service.clusterIP -- carbide service Cluster IP
  # e.g.:
  # clusterIP: None
  loadBalancerIP: ""
  # service.loadBalancerIP -- carbide service Load Balancer IP
  # ref: https://kubernetes.io/docs/concepts/services-networking/service/#type-loadbalancer
  loadBalancerSourceRanges: []
  # service.loadBalancerSourceRanges -- carbide service Load Balancer sources
  # ref: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/#restrict-access-for-loadbalancer-service
  # e.g:
  # loadBalancerSourceRanges:
  #   - 10.10.10.0/24
  externalTrafficPolicy: Cluster
  # service.externalTrafficPolicy -- carbide service external traffic policy
  # ref: http://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip
  annotations: {}
  # service.annotations -- Additional custom annotations for carbide service
  extraPorts: []
  # service.extraPorts -- Extra ports to expose in carbide service (normally used with the `sidecars` value)
  sessionAffinity: None
  # service.sessionAffinity -- Control where client requests go, to the same pod or round-robin
  # Values: ClientIP or None
  # ref: https://kubernetes.io/docs/user-guide/services/
  sessionAffinityConfig: {}
  # service.sessionAffinityConfig -- Additional settings for the sessionAffinity
  # sessionAffinityConfig:
  #   clientIP:
  #     timeoutSeconds: 300

metricsService:
  ports:
    http: 1080
    # metricsService.ports.http -- The port that exposes the /metrics endpoint for carbide-api
  targetPorts:
    http: 1080
    # metricsService.targetPorts.http -- The container port that exposes the /metrics endpoint for carbide-api

ingress:
  # -- ingress parameters
  # ref: http://kubernetes.io/docs/user-guide/ingress/
  enabled: false
  # ingress.enabled -- Enable ingress record generation for carbide
  pathType: ImplementationSpecific
  # ingress.pathType -- Ingress path type
  apiVersion: ""
  # ingress.apiVersion -- Force Ingress API version (automatically detected if not set)
  hostname: .local
  # ingress.hostname -- Default host for the ingress record
  ingressClassName: ""
  # ingress.ingressClassName -- IngressClass that will be be used to implement the Ingress (Kubernetes 1.18+)
  # This is supported in Kubernetes 1.18+ and required if you have more than one IngressClass marked as the default for your cluster .
  # ref: https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/
  path: /
  # ingress.path -- Default path for the ingress record
  # NOTE: You may need to set this to '/*' in order to use this with ALB ingress controllers
  annotations: {}
  # ingress.annotations -- Additional annotations for the Ingress resource. To enable certificate autogeneration, place here your cert-manager annotations.
  # Use this parameter to set the required annotations for cert-manager, see
  # ref: https://cert-manager.io/docs/usage/ingress/#supported-annotations
  # e.g:
  # annotations:
  #   kubernetes.io/ingress.class: nginx
  tls: false
  # ingress.tls -- Enable TLS configuration for the host defined at `ingress.hostname` parameter
  # TLS certificates will be retrieved from a TLS secret with name: `{{- printf "%s-tls" .Values.ingress.hostname }}`
  # You can:
  #   - Use the `ingress.secrets` parameter to create this TLS secret
  #   - Rely on cert-manager to create it by setting the corresponding annotations
  #   - Rely on Helm to create self-signed certificates by setting `ingress.selfSigned=true`
  selfSigned: false
  # ingress.selfSigned -- Create a TLS secret for this ingress record using self-signed certificates generated by Helm
  extraHosts: []
  # ingress.extraHosts -- An array with additional hostname(s) to be covered with the ingress record
  # e.g:
  # extraHosts:
  #   - name: carbide-api.local
  #     path: /
  extraPaths: []
  # ingress.extraPaths -- An array with additional arbitrary paths that may need to be added to the ingress under the main host
  # e.g:
  # extraPaths:
  # - path: /*
  #   backend:
  #     serviceName: ssl-redirect
  #     servicePort: use-annotation
  extraTls: []
  # ingress.extraTls -- TLS configuration for additional hostname(s) to be covered with this ingress record
  # ref: https://kubernetes.io/docs/concepts/services-networking/ingress/#tls
  # e.g:
  # extraTls:
  # - hosts:
  #     - carbide-api.local
  #   secretName: carbide-api.local-tls
  secrets: []
  # ingress.secrets -- Custom TLS certificates as secrets
  # NOTE: 'key' and 'certificate' are expected in PEM format
  # NOTE: 'name' should line up with a 'secretName' set further up
  # If it is not set and you're using cert-manager, this is unneeded, as it will create a secret for you with valid certificates
  # If it is not set and you're NOT using cert-manager either, self-signed certificates will be created valid for 365 days
  # It is also possible to create and manage the certificates outside of this helm chart
  # Please see README.md for more information
  # e.g:
  # secrets:
  #   - name: carbide-api.local-tls
  #     key: |-
  #       -----BEGIN RSA PRIVATE KEY-----
  #       ...
  #       -----END RSA PRIVATE KEY-----
  #     certificate: |-
  #       -----BEGIN CERTIFICATE-----
  #       ...
  #       -----END CERTIFICATE-----
  extraRules: []
  # ingress.extraRules -- Additional rules to be covered with this ingress record
  # ref: https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-rules
  # e.g:
  # extraRules:
  # - host: example.local
  #     http:
  #       path: /
  #       backend:
  #         service:
  #           name: example-svc
  #           port:
  #             name: http

persistence:
  # -- Enable persistence using Persistent Volume Claims
  # ref: https://kubernetes.io/docs/user-guide/persistent-volumes/
  enabled: false
  # persistence.enabled -- Enable persistence using Persistent Volume Claims
  mountPath: /mnt/persistence
  # persistence.mountPath -- Path to mount the volume at.
  subPath: ""
  # persistence.subPath -- The subdirectory of the volume to mount to, useful in dev environments and one PV for multiple services
  storageClass: ""
  # persistence.storageClass -- Storage class of backing PVC
  # If defined, storageClassName: <storageClass>
  annotations: {}
  # persistence.annotations -- Persistent Volume Claim annotations
  accessModes:
    # persistence.accessModes -- Persistent Volume Access Modes
    - ReadWriteOnce
  size: 8Gi
  # persistence.size -- Size of data volume
  existingClaim: ""
  # persistence.existingClaim -- The name of an existing PVC to use for persistence
  selector: {}
  # persistence.selector -- Selector to match an existing Persistent Volume for WordPress data PVC
  # If set, the PVC can't have a PV dynamically provisioned for it
  # E.g.
  # selector:
  #   matchLabels:
  #     app: my-app
  dataSource: {}
  # persistence.dataSource -- Custom PVC data source

## @section Init Container Parameters
##

volumePermissions:
  # -- 'volumePermissions' init container parameters
  # Changes the owner and group of the persistent volume mount point to runAsUser:fsGroup values
  # based on the *podSecurityContext/*containerSecurityContext parameters
  enabled: false
  # volumePermissions.enabled -- Enable init container that changes the owner/group of the PV mount point to `runAsUser:fsGroup`
  image:
    # -- Bitnami Shell image
    # ref: https://hub.docker.com/r/bitnami/bitnami-shell/tags/
    registry: nvcr.io
    # volumePermissions.image.registry -- Bitnami Shell image registry
    repository: nvidian/nvforge/bitnami-shell
    # volumePermissions.image.repository -- Bitnami Shell image repository
    tag: latest
    # volumePermissions.image.tag -- Bitnami Shell image tag (immutable tags are recommended)
    pullPolicy: IfNotPresent
    # volumePermissions.image.pullPolicy -- Bitnami Shell image pull policy
    pullSecrets: []
    # volumePermissions.image.pullSecrets -- Bitnami Shell image pull secrets
    # Optionally specify an array of imagePullSecrets.
    # Secrets must be manually created in the namespace.
    # ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
  resources:
    # -- Init container's resource requests and limits
    # ref: http://kubernetes.io/docs/user-guide/compute-resources/
    limits: {}
    # volumePermissions.resources.limits -- The resources limits for the init container
    requests: {}
    # volumePermissions.resources.requests -- The requested resources for the init container

  containerSecurityContext:
    # -- Init container Container Security Context
    # ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container
    runAsUser: 0
    # volumePermissions.containerSecurityContext.runAsUser -- Set init container's Security Context runAsUser
    # NOTE: when runAsUser is set to special value "auto", init container will try to chown the
    #   data folder to auto-determined user&group, using commands: `id -u`:`id -G | cut -d" " -f2`
    #   "auto" is especially useful for OpenShift which has scc with dynamic user ids (and 0 is not allowed)

## @section Other Parameters
##

## RBAC configuration
##
rbac:
  # -- RBAC configuration
  create: true
  # rbac.create -- Specifies whether RBAC resources should be created
  rules: []
  # rbac.rules -- Custom RBAC rules to set
  # e.g:
  # rules:
  #   - apiGroups:
  #       - ""
  #     resources:
  #       - pods
  #     verbs:
  #       - get
  #       - list

serviceAccount:
  # -- ServiceAccount configuration
  create: true
  # serviceAccount.create -- Specifies whether a ServiceAccount should be created
  name: "carbide-api"
  # serviceAccount.name -- The name of the ServiceAccount to use.
  # If not set and create is true, a name is generated using the common.names.fullname template
  annotations: {}
  # serviceAccount.annotations -- Additional Service Account annotations (evaluated as a template)
  automountServiceAccountToken: true
  # serviceAccount.automountServiceAccountToken -- Automount service account token for the server service account
