{{- $nvueConfig := . -}}
- header:
    model: VX
    nvue-api-version: nvue_v1
    rev-id: 1.0
    version: Cumulus Linux 5.6.0
{{- $tenant := .Tenant }}
- set:
{{- if .IncludeBridge }} {{/* Only if an L2 segment exists should bridges be configured */}}
    bridge:
      domain:
        br_default:
          vlan:
  {{- range .Tenant.PortConfigs }}
    {{- if .IsL2Segment }}
            '{{ .VlanID }}':
              vni:
                '{{ .L2VNI }}': {} {{/* Always configuring an L2VNI, even if not necessary. Less conditions in the template */}}
    {{- end }}
  {{- end }}
{{- end }}
    evpn:
      enable: on
    interface:
      lo:
        ip:
          address:
            {{ .LoopbackIP }}/32: {}
        type: loopback
      pf0dpu1_if:
        ip:
          address:
            169.254.169.253/30: {}
          vrf: {{ $tenant.VrfName }}
{{- if .IsStorageClient }} {{/* New variable to be created to define if a node is a storage client and the interface should be created */}}
      pf0dpu3_if:
        ip:
          address:
            {{ $.StorageDpuIP }}: {}
        vrf: storage
{{- end }}
{{- if $nvueConfig.HasInternalBridgeRouting }}
      {{ $nvueConfig.VfInterceptBridgeSf }}_if:
        ip:
          address:
            {{ $nvueConfig.VfInterceptHbnRepresentorIp }}/{{ $nvueConfig.InterceptBridgePrefixLen }}: {}
{{- end }}
{{- range .Uplinks}}
      {{ . }}:
        type: swp
{{- end }}
{{- range .Tenant.PortConfigs }}
      {{ .InterfaceName }}:
        type: swp
        acl: {{/* Removing condition of use-case. ACL should always be configured. The condition should be for the ACL content and not the existance */}}
        {{- if $.HasDenyPrefixes }}
          p0000_deny_prefixes_ipv4:
            inbound: {}
        {{- end }}
        {{- if $nvueConfig.HasIpv4EgressSecurityPolicyOverrideRules }}
          p0004_security_policy_override_ipv4_host_egress:          
            inbound: {}
        {{- end }}
        {{- if $nvueConfig.HasIpv6EgressSecurityPolicyOverrideRules }}
          p0004_security_policy_override_ipv6_host_egress:
            inbound: {}
        {{- end }}
        {{- if $nvueConfig.HasIpv4IngressSecurityPolicyOverrideRules }}
          p0004_security_policy_override_ipv4_host_ingress:
            outbound: {}
        {{- end }}
        {{- if $nvueConfig.HasIpv6IngressSecurityPolicyOverrideRules }}
          p0004_security_policy_override_ipv6_host_ingress:
            outbound: {}
        {{- end }}
        {{- if $tenant.HasNetworkSecurityGroup }}
          p0005_security_group_ipv4_in: 
            inbound: {}
          p0005_security_group_ipv6_in:
            inbound: {}
          p0005_security_group_ipv4_out: 
            outbound: {}
          p0005_security_group_ipv6_out: 
            outbound: {}
        {{- end }}
        {{- if $tenant.HasVpcPeerPrefixes }}
          p0009_vpc_peer_egress_from_host:
            inbound: {}
          p0009_vpc_peer_ingress_to_host:
            outbound: {}
        {{- end }}
        {{- if and ($.UseVpcIsolation) ($.HasSiteFabricPrefixes) }}
          {{- if not $tenant.HasNetworkSecurityGroup }}
          p0010_vpc_isolation_ipv4:
            inbound: {}
          {{- end }}
        {{- end }}
   {{- if .IsL2Segment }}
          dhcp_flood_prevention:
            inbound: {}
   {{- end }}
   {{- if not .IsL2Segment }} {{/* If not L2, IP will be directly configured on the interface */}}
        ip:
          address:
          {{- range .IPs }}
            {{ . }}: {} {{/* In case of FNN L3, this is the first IP in the /31 in the prefix */}}
          {{- end }}
          vrf: {{ $tenant.VrfName }} {{/* The name of the VRF (VPC) this interface should be in (reference to the configured VRF later) */}}
     {{- else }} {{/* If the segment is L2, the interface should be configured in the bridge */}}
        bridge:
          domain:
            br_default:
              access: {{ .VlanID }}
   {{- end }}
  {{- if .IsL2Segment }} {{/* If the segment is L2, an SVI is needed */}}
      vlan{{ .VlanID }}:
        type: svi
        vlan: {{ .VlanID }}
        ip:
          address:
            {{ .SviIP }}: {} {{/* The SviIP is a _different_ ip from the same subnet than the gateway. Typically the second IP in the subnet */}}
          vrf: {{ $tenant.VrfName }} {{/* The name of the VRF (VPC) this interface should be in (reference to the configured VRF later) */}}
          vrr:
            address:
            {{- range .IPs }}
              {{ . }}: {} {{/* In case of FNN l2, the first IP from the subnet */}}
            {{- end }}
            enable: on
            mac-address: {{ .SviMAC }} {{/* A shared MAC address for all vlan interfaces in the same VNI (VPC) */}}
            state:
              up: {}
  {{- end }}
{{- end }}
    nve:
      vxlan:
        arp-nd-suppress: on
        enable: on
        source:
          address: {{ .LoopbackIP }} {{/* Unique DPU Loopback used as VTEP */}}
    router:
      bgp:
        autonomous-system: {{ .ASN }} {{/* Unique DPU ASN */}}
        enable: on
        router-id: {{ .LoopbackIP }}
      vrr:
        enable: on
      policy:
        community-list:
          BYOIP_LEAK_COMMUNITY_LIST:
            rule:
              '10':
                action: permit
                community:
                  65100:01: {}
        prefix-list:
          ALLOW_TO_UNDERLAY_PREFIX_LIST:
            rule:
              '65000':
                action: permit
                match:
                  {{ .LoopbackIP }}/32: {}
              {{- if .HasSecondaryOverlayVTEP }}
              '65001':
                action: permit
                match:
                  {{ .SecondaryOverlayVtepIP }}/32: {}
              {{- end }}
          DPU_FROM_INSTANCE_PREFIX_LIST:
            rule:
              '10':
                action: permit
                match:
                  0.0.0.0/0:
                    min-prefix-len: 32
          DPU_FROM_TRAFFIC_INTERCEPT_PEER_PREFIX_LIST:
            rule:
                  {{- range .TrafficInterceptPublicPrefixes }}
              '{{ .Index }}':
                action: permit
                match:
                  {{ .Prefix }}: {}
                  {{- end }}
          DPU_TO_EVPN_DROP_PREFIX_LIST:
            rule:
              '10':
                action: permit{{/* This means 'match', not 'allow' */}}
                match:
                  {{ .Tenant.VrfLoopback }}/32: {}{{/* Still not clear we really even need a loopback on the VRF for our use-case, and we allow duplication between sites, so keep the type-5 route for it out of the overlay. */}}
        route-map:
          dpu_to_evpn:
            rule:
              '65534':
                action:
                  deny: {}
                match:
                  type: ipv4
                  evpn-route-type: ip-prefix
                  ip-prefix-list: DPU_TO_EVPN_DROP_PREFIX_LIST
              '65535':
                action:
                  permit: {}{{/* We originally did no filtering here.  An attempt to use an "allow" prefix-list and default deny route-map stripped more than expected.  It seems like a bug that we need to look into. For now, we just drop the prefixes that we wanted dropped. */}}
          leak_to_underlay:
            rule:
              '65533':
                action:
                  permit: {}
                match:
                  type: ipv4
                  ip-prefix-list: ALLOW_TO_UNDERLAY_PREFIX_LIST
                set:
                  community:
                    none: {}{{/* We strip here just in case something accidentally slipped through */}}
                  large-community:
                    none: {}
              '65534':
                action:
                  permit: {}
                match:
                  tag: 65100
                set:
                  community:
                    none: {}
                  large-community:
                    none: {}
              '65535':
                action:
                  deny: {}
          dpu_from_traffic_intercept_gw_peer:
            rule:
              '10':
                action:
                  permit: {}
                match:
                  type: ipv4
                  ip-prefix-list: DPU_FROM_TRAFFIC_INTERCEPT_PEER_PREFIX_LIST
                  community-list: BYOIP_LEAK_COMMUNITY_LIST
                set:
                  tag: 65100{{/* tag it so we can match on the tag and use it for leaking later */}}
                  community:
                    none: {}{{/* Strip any communities the peer might have attached. */}}
                  large-community:
                    none: {}
              '11':
                action:
                  permit: {}
                match:
                  type: ipv4
                  ip-prefix-list: DPU_FROM_TRAFFIC_INTERCEPT_PEER_PREFIX_LIST
                set:
                  community:
                    none: {}{{/* Strip any communities the peer might have attached. */}}
                  large-community:
                    none: {}
              '65535':
                action:
                  deny: {}
          dpu_from_instance:
            rule:
              '10':
                action:
                  permit: {}
                match:
                  type: ipv4
                  ip-prefix-list: DPU_FROM_INSTANCE_PREFIX_LIST
                  community-list: BYOIP_LEAK_COMMUNITY_LIST
                set:
                  tag: 65100{{/* tag it so we can match on the tag and use it for leaking later */}}
                  community:
                      none: {}{{/* Strip any communities the peer might have attached. */}}
                  large-community:
                    none: {}
              '11':
                action:
                  permit: {}
                match:
                  type: ipv4
                  ip-prefix-list: DPU_FROM_INSTANCE_PREFIX_LIST
                set:
                  community:
                      none: {}{{/* Strip any communities the peer might have attached. */}}
                  large-community:
                    none: {}
              '65535':
                action:
                  deny: {}
          dpu_to_instance:
            rule:
              '10':
                action:
                  deny: {}
          dpu_to_traffic_intercept_gw_peer:
            rule:
              '10':
                action:
                  deny: {}
{{- if $nvueConfig.StatefulAclsEnabled }}
    system:
      reflexive-acl:
        enable: on                  
{{- end }}
    vrf:
      default:
        router:
        {{- if $nvueConfig.HasStaticAdvertisements }}
          static:
          {{- if $nvueConfig.HasSecondaryOverlayVTEP }}
            {{ $nvueConfig.SecondaryOverlayVtepIP }}/32:
              address-family: ipv4-unicast
              via:
                {{ $nvueConfig.VfInterceptBridgeIP }}:
                  type: ipv4-address
          {{- end }}
        {{- end }}
          nexthop-tracking:
            ipv4:
              resolved-via-default: on
          bgp:
            address-family:
              ipv4-unicast:
              {{- if $nvueConfig.HasStaticAdvertisements }}
                network:
                {{- if $nvueConfig.HasSecondaryOverlayVTEP }}
                  {{ $nvueConfig.SecondaryOverlayVtepIP }}/32: {}
                {{- end }}
              {{- end}}
                enable: on
                multipaths:
                  ebgp: 128
                redistribute:
                  connected:
                    enable: on
              l2vpn-evpn:
                enable: on
            enable: on
            neighbor:
{{- range .RouteServers }}
              {{ . }}:
                peer-group: routeserver
                type: numbered
{{- end }}
{{- range .Uplinks}}
              {{ . }}:
                peer-group: underlay
                type: unnumbered
{{- end }}
            path-selection:
              multipath:
                aspath-ignore: on
            peer-group:
              routeserver:
                address-family:
                  ipv4-unicast:
                    enable: off
                  l2vpn-evpn:
                    enable: on
                    policy:
                      outbound:
                        route-map: dpu_to_evpn
                multihop-ttl: 255
                remote-as: external
                update-source: lo
              underlay:
                remote-as: external
                address-family:
                  ipv4-unicast:
                    policy:
                      outbound:
                        route-map: leak_to_underlay
{{- if eq (len .RouteServers) 0 }}
                  l2vpn-evpn:
                    enable: on
                    policy:
                      outbound:
                        route-map: dpu_to_evpn
{{- end }}                
{{- if .Tenant.VrfLoopback }}
      {{ .Tenant.VrfName }}: {{/* A VRF (VPC) needs to be defined on each DPU. This also creates an interface which introduces a max of 15 chars */}}
        evpn:
          enable: on
          vni:
            '{{ .Tenant.L3VNI }}': {} {{/* A VRF (VPC) needs a unique VNI to create the tenant separation */}}
        loopback:
          ip:
            address:
              {{ .Tenant.VrfLoopback }}/32: {} {{/* Every VRF on each DPU requires a unique loopback address */}}
        router:
        {{- if $nvueConfig.UseAdminNetwork }}
          static:
            {{- range .Tenant.HostInterfaces }}
            {{ .HostRoute }}:
              address-family: ipv4-unicast
              via:
                vlan{{ .ID }}:
                  type: interface
            {{- end }}
        {{- end }}
          bgp:
            address-family:
              ipv4-unicast:
              {{- if $nvueConfig.UseAdminNetwork }}
                network:
                  {{- range .Tenant.HostInterfaces }}
                  {{ .HostRoute }}: {}
                  {{- end }}              
              {{- end }}
                enable: on
                redistribute:
                  connected:
                    enable: on
                route-export:
                  to-evpn:
                    enable: on
            enable: on
            neighbor:
  {{- range .Tenant.HostInterfaces}}
    {{- if .HostIP }}
              {{ .HostIP }}:
                passive-mode: on
                peer-group: tenant
                type: numbered
    {{- end }}
  {{- end }}
  {{- if $nvueConfig.PublicPrefixInternalNextHop }}
              {{ $nvueConfig.PublicPrefixInternalNextHop }}:
                passive-mode: on
                peer-group: traffic_intercept_gw_peer
                type: numbered
  {{- end }}
            peer-group:
              traffic_intercept_gw_peer:
                address-family:
                  ipv4-unicast:
                    policy:
                      inbound:
                        route-map: dpu_from_traffic_intercept_gw_peer
                      outbound:
                        route-map: dpu_to_traffic_intercept_gw_peer
                nexthop-connected-check: off
                remote-as: external
                timers:
                  connection-retry: 10
                  hold: 9
                  keepalive: 3
                  route-advertisement: none
              tenant:
                address-family:
                  ipv4-unicast:
                    policy:
                      inbound:
                        route-map: dpu_from_instance
                      outbound:
                        route-map: dpu_to_instance
                nexthop-connected-check: off
                remote-as: external
                timers:
                  connection-retry: 10
                  hold: 9
                  keepalive: 3
                  route-advertisement: none
            route-export:
              to-evpn:
                route-target:
                  {{ $.DatacenterASN }}:{{ .Tenant.L3VNI }}: {}
                  {{- if $.UseCommonInternalTenantRouteTarget }}
                  {{ $.CommonInternalRouteTarget.ASN }}:{{ $.CommonInternalRouteTarget.VNI }}: {} {{/* This is the common tag for DPU routes of INTERNAL customers. */}}
                  {{- end}}
            route-import:
              from-evpn:
                route-target:
                  {{ $.DatacenterASN }}:{{ .Tenant.L3VNI }}: {}
                  {{ $.DatacenterASN }}:{{ $.InternetL3VNI }}: {} {{/* This is the common tag for the default route of INTERNAL customers.  There should eventually be a conditional around this and a separate option for external. */}}
                {{- range .Tenant.VpcPeerVnis }}
                  {{ $.DatacenterASN }}:{{ .Vni }}: {} {{/* If we ever want to allow cross-DC peering for some reason, this would have to change */}}
                {{- end}}
                {{- range $.AdditionalRouteTargetImports }}
                  {{ .ASN }}:{{ .VNI }}: {}
                {{- end}}
                  auto: {}
{{- end }}
    acl:
      dhcp_flood_prevention:
        rule: 
          '10':
            action:
              deny: {}
            hw-offload: off
            match:
              ip:
                dest-ip: 255.255.255.255
                dest-port:
                  '67': {}
                protocol: udp
                source-port:
                  '68': {}
        type: ipv4

 {{- if $.HasDenyPrefixes }}
      p0000_deny_prefixes_ipv4:
        type: ipv4
        rule:
    {{- if not .Tenant.HasNetworkSecurityGroup }}
      {{- range $tenant.PortConfigs }}
        {{- range .VpcPrefixes }}
          '{{ .Index }}':
            action:
              permit: {}
            match:
              ip:
                dest-ip: {{ .Prefix }}
        {{- end }}
      {{- end }}
    {{- end}}        
    {{- range $.DenyPrefixes }}
          '{{ .Index }}':
            action:
              deny: {}
            match:
              ip:
                dest-ip: {{ .Prefix }}
    {{- end }}
{{- end }}
{{- if .Tenant.HasVpcPeerPrefixes }}
      p0009_vpc_peer_egress_from_host:
        type: ipv4
        rule:
        {{- range .Tenant.VpcPeerPrefixes }}
          '{{ .Index }}':
            action:
              permit: {}
            match:
              ip:
                dest-ip: {{ .Prefix }}
        {{- end }}
      p0009_vpc_peer_ingress_to_host:
        type: ipv4
        rule:
        {{- range .Tenant.VpcPeerPrefixes }}
          '{{ .Index }}':
            action:
              permit: {}
            match:
              ip:
                source-ip: {{ .Prefix }}
        {{- end }}
{{- end }}
 {{- if and ($.UseVpcIsolation) ($.HasSiteFabricPrefixes) }}
    {{- if not .Tenant.HasNetworkSecurityGroup }}
      p0010_vpc_isolation_ipv4:
        type: ipv4
        rule:
      {{- range $tenant.PortConfigs }}
        {{- range .VpcPrefixes }}
          '{{ .Index }}':
            action:
              permit: {}
            match:
              ip:
                dest-ip: {{ .Prefix }}
        {{- end }}
      {{- end }}
      {{- range $.SiteFabricPrefixes }}
          '{{ .Index }}':
            action:
              deny: {}
            match:
              ip:
                dest-ip: {{ .Prefix }}
      {{- end }}
    {{- end}}
 {{- end }}
 {{- if .Tenant.HasNetworkSecurityGroup }}
      p0005_security_group_ipv4_in: {{/* Egress from host.  Ingress and Egress is defined from instance perspective, so reverse on DPU side */}}
        rule:
      {{- if .Tenant.HasIpv4EgressSecurityGroupRules }}
        {{- range .Tenant.EgressNetworkSecurityGroupRulesIpv4 }}
          '{{ .Priority }}':
            action:
              {{ .Action }}: {}
            match:
              {{- if and ($nvueConfig.StatefulAclsEnabled) (.CanBeStateful) }}
              conntrack:{{/* Testing showed this is not needed, but we should follow the docs */}}
                new: {}
                established: {}
              {{- end }}
              ip:
                dest-ip: {{ .DstPrefix }}
                {{- if .HasDstPort }}
                dest-port:
                  '{{ .DstPort }}': {}
                {{- end }} 
                {{- if not .CanMatchAnyProtocol }} 
                protocol: {{ .Protocol }}
                {{- end}}
                source-ip: {{ .SrcPrefix }} 
                {{- if .HasSrcPort }}
                source-port:
                  '{{ .SrcPort }}': {}
                {{- end }} 
        {{- end }}
      {{- end }}
          '65535':
            action:
              deny: {}
        type: ipv4
      p0005_security_group_ipv6_in: {{/* Egress from host.  Ingress and Egress is defined from instance perspective, so reverse on DPU side */}}
        rule:
      {{- if .Tenant.HasIpv6EgressSecurityGroupRules }}
        {{- range .Tenant.EgressNetworkSecurityGroupRulesIpv6 }}
          '{{ .Priority }}':
            action:
              {{ .Action }}: {}
            match:
              ip:
                dest-ip: {{ .DstPrefix }}
                {{- if .HasDstPort }}
                dest-port:
                  '{{ .DstPort }}': {}
                {{- end }} 
                {{- if not .CanMatchAnyProtocol }} 
                protocol: {{ .Protocol }}
                {{- end }}
                source-ip: {{ .SrcPrefix }} 
                {{- if .HasSrcPort }}
                source-port:
                  '{{ .SrcPort }}': {}
                {{- end }} 
        {{- end }}
      {{- end }}
          '65535':
            action:
              deny: {}
        type: ipv6
      p0005_security_group_ipv4_out: {{/* Ingress to host. Ingress and Egress is defined from instance perspective, so reverse on DPU side */}}
        rule:
      {{- if .Tenant.HasIpv4IngressSecurityGroupRules }}
        {{- range .Tenant.IngressNetworkSecurityGroupRulesIpv4 }}
          '{{ .Priority }}':
            action:
              {{ .Action }}: {}
            match:
              ip:
                dest-ip: {{ .DstPrefix }}
                {{- if .HasDstPort }}
                dest-port:
                  '{{ .DstPort }}': {}
                {{- end }}
                {{- if not .CanMatchAnyProtocol }} 
                protocol: {{ .Protocol }}
                {{- end }}
                source-ip: {{ .SrcPrefix }} 
                {{- if .HasSrcPort }}
                source-port:
                  '{{ .SrcPort }}': {}
                {{- end }} 
        {{- end }}
      {{- end }}
      {{- if $nvueConfig.StatefulAclsEnabled }}
          '65532':
            action:
              permit: {}
            match:
              ip:
                protocol: tcp
              conntrack:
                established: {}
          '65533':
            action:
              permit: {}
            match:
              ip:
                protocol: udp
              conntrack:
                established: {}
          '65534':
            action:
              permit: {}
            match:
              ip:
                protocol: icmp
              conntrack:
                established: {}
      {{- end }}
          '65535':
            action:
              deny: {}
        type: ipv4
      p0005_security_group_ipv6_out: {{/* Ingress to host.  Ingress and Egress is defined from instance perspective, so reverse on DPU side */}}
        rule:
      {{- if .Tenant.HasIpv6IngressSecurityGroupRules }}
        {{- range .Tenant.IngressNetworkSecurityGroupRulesIpv6 }}
          '{{ .Priority }}':
            action:
              {{ .Action }}: {}
            match:
              ip:
                dest-ip: {{ .DstPrefix }}
                {{- if .HasDstPort }}
                dest-port:
                  '{{ .DstPort }}': {}
                {{- end }} 
                {{- if not .CanMatchAnyProtocol }} 
                protocol: {{ .Protocol }}
                {{- end}}
                source-ip: {{ .SrcPrefix }} 
                {{- if .HasSrcPort }}
                source-port:
                  '{{ .SrcPort }}': {}
                {{- end }} 
        {{- end }}
      {{- end }}
          '65535':
            action:
              deny: {}
        type: ipv6
{{- end }}

      {{- if $nvueConfig.HasIpv4EgressSecurityPolicyOverrideRules }}
      p0004_security_policy_override_ipv4_host_egress:
        type: ipv4
        rule:
        {{- range $nvueConfig.Ipv4EgressNetworkSecurityPolicyOverrideRules }}
          '{{ .Priority }}':
            action:
              {{ .Action }}: {}
            match:
              ip:
                dest-ip: {{ .DstPrefix }}
                {{- if .HasDstPort }}
                dest-port:
                  '{{ .DstPort }}': {}
                {{- end }} 
                {{- if not .CanMatchAnyProtocol }} 
                protocol: {{ .Protocol }}
                {{- end}}
                source-ip: {{ .SrcPrefix }} 
                {{- if .HasSrcPort }}
                source-port:
                  '{{ .SrcPort }}': {}
                {{- end }} 
        {{- end }}
      {{- end }}
      {{- if $nvueConfig.HasIpv6EgressSecurityPolicyOverrideRules }}
      p0004_security_policy_override_ipv6_host_egress:
        type: ipv6
        rule:
        {{- range $nvueConfig.Ipv6EgressNetworkSecurityPolicyOverrideRules }}
          '{{ .Priority }}':
            action:
              {{ .Action }}: {}
            match:
              ip:
                dest-ip: {{ .DstPrefix }}
                {{- if .HasDstPort }}
                dest-port:
                  '{{ .DstPort }}': {}
                {{- end }} 
                {{- if not .CanMatchAnyProtocol }} 
                protocol: {{ .Protocol }}
                {{- end }}
                source-ip: {{ .SrcPrefix }} 
                {{- if .HasSrcPort }}
                source-port:
                  '{{ .SrcPort }}': {}
                {{- end }} 
        {{- end }}
      {{- end }}
      {{- if $nvueConfig.HasIpv4IngressSecurityPolicyOverrideRules }}
      p0004_security_policy_override_ipv4_host_ingress:
        type: ipv4
        rule:
        {{- range $nvueConfig.Ipv4IngressNetworkSecurityPolicyOverrideRules }}
          '{{ .Priority }}':
            action:
              {{ .Action }}: {}
            match:
              ip:
                dest-ip: {{ .DstPrefix }}
                {{- if .HasDstPort }}
                dest-port:
                  '{{ .DstPort }}': {}
                {{- end }}
                {{- if not .CanMatchAnyProtocol }} 
                protocol: {{ .Protocol }}
                {{- end }}
                source-ip: {{ .SrcPrefix }} 
                {{- if .HasSrcPort }}
                source-port:
                  '{{ .SrcPort }}': {}
                {{- end }} 
        {{- end }}
      {{- end }}
      {{- if $nvueConfig.HasIpv6IngressSecurityPolicyOverrideRules }}
      p0004_security_policy_override_ipv6_host_ingress:
        type: ipv6
        rule:
        {{- range $nvueConfig.Ipv6IngressNetworkSecurityPolicyOverrideRules }}
          '{{ .Priority }}':
            action:
              {{ .Action }}: {}
            match:
              ip:
                dest-ip: {{ .DstPrefix }}
                {{- if .HasDstPort }}
                dest-port:
                  '{{ .DstPort }}': {}
                {{- end }} 
                {{- if not .CanMatchAnyProtocol }} 
                protocol: {{ .Protocol }}
                {{- end}}
                source-ip: {{ .SrcPrefix }} 
                {{- if .HasSrcPort }}
                source-port:
                  '{{ .SrcPort }}': {}
                {{- end }} 
        {{- end }}
      {{- end }}
