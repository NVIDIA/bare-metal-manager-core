syntax = "proto3";

import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";

package carbide.v0;

// Primitives
message UUID {
	string value = 1;
}

// Event subscription API
//message EventRequest {};
//message EventMessage {
//	google.protobuf.Timestamp emitted = 1;
//	oneof event {
//		EventMachineAdded machine_added = 2;
//		EventMachineDeleted machine_deleted = 3;
//		EventMachineStateChanged machine_state_changed = 4;
//	};
//}
//message EventMachineAdded {
//	UUID id = 1;
//};
//message EventMachineDeleted {
//	UUID id = 1;
//}
//message EventMachineStateChanged {
//	UUID id = 1;
//}

message MachineEvent {
	int64 id = 1;
	UUID  machine_id = 2;
	MachineAction event = 3;
	int32 version = 4;

	google.protobuf.Timestamp time = 5;
}

// Machines API
message MachineList {
	repeated Machine machines = 1;
}

enum MachineAction {
	UNKNOWN = 0;
	DISCOVER = 1;
	ADOPT = 2;
	TEST = 3;
	COMMISSION = 4;
	ASSIGN = 5;
	FAIL = 6;
	DECOMMISSION = 7;
	RECOMMISSION = 8;
	UNASSIGN = 9;
	RELEASE = 10;
}

message Machine {
	UUID id = 1;
	string fqdn = 2;

	google.protobuf.Timestamp created = 3;
	google.protobuf.Timestamp modified = 4;

	repeated MachineEvent events = 5;
	repeated MachineInterface interfaces = 6;

	MachineState state = 7;

	optional string userdata = 8;
// TODO(ajf): hardware discovery
// TODO(ajf): os selection
// TODO(ajf): bmc configuration
// TODO(ajf): machine labels/tags
// TODO(ajf): test results
// TODO(ajf): storage
}

message MachineState {
	string state = 1;
}


message MachineInterface {
	UUID id = 1;
	UUID machine_id = 2;
	UUID segment_id = 3;

	string mac_address = 4;

	optional string address_ipv4 = 5;
	optional string address_ipv6 = 6;
}

message MachineDiscovery {
	string mac_address = 1;
	string relay_address = 2;
}

message NetworkSegment {
	UUID id = 1;
	string name = 2;
	string subdomain = 3;
	int32 mtu = 4;

	optional string subnet_ipv4 = 5;
	optional string subnet_ipv6 = 6;

	int32 reserve_first_ipv4 = 7;
	int32 reserve_first_ipv6 = 8;

	optional string gateway_ipv4 = 9;
}

message DhcpRecord {
	UUID machine_id = 1;
	UUID segment_id = 2;

	string subdomain = 3;
	string fqdn = 4;

	optional AddressAssignmentV4 address_ipv4 = 5;
	optional AddressAssignmentV6 address_ipv6 = 6;
}

message AddressAssignmentV4 {
	string mac_address = 1;
	string address = 2;
	optional string gateway = 3;
	string mask = 4;
}

message AddressAssignmentV6 {
	string duid = 1;
	string address = 2;
}

message NewNetworkSegment {
	string name = 2;
	string subdomain = 3;

	optional int32 mtu = 4;
	optional string subnet_ipv4 = 5;
	optional string subnet_ipv6 = 6;
	optional int32 reserve_first_ipv4 = 7;
	optional int32 reserve_first_ipv6 = 8;
	optional string gateway_ipv4 = 9;
}

message NetworkSegmentList {
	repeated NetworkSegment network_segments = 1;
}

message NetworkSegmentQuery {
	string name = 1;
}

message MachineQuery {
	optional UUID id = 1;
	optional string fqdn = 2;
}

message NetworkSegmentDeletion { }
message ProjectDeletion{ }

message OperatingSystemUpdate { }
message OperatingSystemUpdateResult { }

// API service
service Carbide {
	// TODO: User Identity: Starfleet, JWTs, etc
	// TODO: Authentication endpoints
	// TODO: Infiniband

	// Project API
	/* Create a project, a project has a network */
//TOOD:	rpc CreateProject(ProjectSpec) returns (ProjectCreationResult);
//TOOD:	rpc UpdateProject(ProjectSpec) returns (ProjectUpdateResult);

	/* Delete a project, fails if there's machines bound to it */
//TOOD:	rpc DeleteProject(UUID) returns (ProjectDeletionResult);

	// Machines API
	/* Discover or create a machine based on Mac Address & DHCP Relay IP */
	rpc DiscoverMachine(MachineDiscovery) returns (DhcpRecord);

	/*
	 * Find and filter a list of the currently available machines:
	 *
	 * A query can be:
	 *   - type of hardware model or presence of certain hardware (i.e. # of GPUs and their model)
	 *   - connected to a specific NetworkSegment
	 *   - connected to a specific IB Island
	 *   - Belonging to a specific project / tenant / etc
	 *   - NOT a specific type of hardware (i.e. No GPUs)
	 */
	rpc FindMachines(MachineQuery) returns (MachineList);

	/* Return a single machine object */
//TODO:	rpc GetMachine(UUID) returns (Machine);

	/* Reteurn a single machine's console (IPMI) information */
//TODO:	rpc GetMachineConsoleConfiguration(UUID) returns (MachineIPMI);

	/* Associate a machine with a project */
//TODO:	rpc BindMachineToProject(MachineProjectBinding) returns (MachineProjectBindingResult);

	/* Do something to a machine, fails if the state transition is invalid */
	/*
	 * Examples:
	 *   - Adopt
	 *   - Commission
	 *   - Release
	 *   - Decommission / Recycle
	 */
//TODO:	rpc PerformMachineAction(MachineAction) returns (MachineStateUpdate);

	/* Update the desired operating system, if this is successful PerformMachineAction of Reprovision is necessary */
//TODO:	rpc UpdateMachineOperatingSystem(OperatingSystemUpdate) returns (OperatingSystemUpdateResult);

	/* Release the machine back to the pool for the tenant */
//TODO:	rpc ReleaseMachine(UUID);

	/* Reset the machine to initial state (wipe all drives, reset firmware, etc) */
//TODO:	rpc ResetMachine(UUID);

	// Network Segment APIs (all privileged operations)
	/* Create a network segment (VLAN/Subnet/VXLan) with some metadata */
	rpc CreateNetworkSegment(NewNetworkSegment) returns (NetworkSegment);

	/* Return the list of networks that exist */
	rpc GetNetworkSegments(NetworkSegmentQuery) returns (NetworkSegmentList);

	/* Delete a network, fails if it's bound to a project or there's machine's on it */
	rpc DeleteNetworkSegment(UUID) returns (NetworkSegmentDeletion);

	/* Associate a network segment (overlay) to a project (tenant) */
//TODO:	rpc BindNetworkSegmentToProject(NetworkSegmentBinding) returns (??);

	// OperatingSystem API - standard CRUD operations
//TODO:	rpc CreateOperatingSystem(OperatingSystem) returns (OperatingSystem);
//TODO:	rpc FindOperatingSystems(OperatingSystemQuery) returns (OperatingSystemList);
//TODO:	rpc UpdateOperatingSystem(OperatingSystemUpdate) returns (OperatingSystem);
//TODO:	rpc DeleteOperatingSystem(OperatingSystem) returns (OperatingSystemDelete);

	// Events API
//TODO:	rpc StreamEvents(EventRequestFilter) returns (stream EventMessage);
}
