syntax = "proto3";

import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";
import "machine_discovery.proto";
import "site_explorer.proto";

package forge;

service Forge {
  // What version of Forge is this service running? Matches `--version` command line.
  rpc Version(VersionRequest) returns (BuildInfo);

  // Domain
  rpc CreateDomain(Domain) returns (Domain);
  rpc UpdateDomain(Domain) returns (Domain);
  rpc DeleteDomain(DomainDeletion) returns (DomainDeletionResult);
  rpc FindDomain(DomainSearchQuery) returns (DomainList);
  // VPC
  rpc CreateVpc(VpcCreationRequest) returns (Vpc);
  rpc UpdateVpc(VpcUpdateRequest) returns (VpcUpdateResult);
  rpc DeleteVpc(VpcDeletionRequest) returns (VpcDeletionResult);
  rpc FindVpcs(VpcSearchQuery) returns (VpcList);

  // Segments - i.e. Overlay Networks
  rpc FindNetworkSegments(NetworkSegmentQuery) returns (NetworkSegmentList);
  rpc CreateNetworkSegment(NetworkSegmentCreationRequest) returns (NetworkSegment);
  rpc DeleteNetworkSegment(NetworkSegmentDeletionRequest) returns (NetworkSegmentDeletionResult);
  rpc NetworkSegmentsForVpc(VpcSearchQuery) returns (NetworkSegmentList);

  // Find a IB partition
  rpc FindIBPartitions(IBPartitionQuery) returns (IBPartitionList);
  // Create a IB partition
  rpc CreateIBPartition(IBPartitionCreationRequest) returns (IBPartition);
  // Delete a IB partition
  rpc DeleteIBPartition(IBPartitionDeletionRequest) returns (IBPartitionDeletionResult);
  // Find all IB partitions under a specified tenant
  rpc IBPartitionsForTenant(TenantSearchQuery) returns (IBPartitionList);

  // Manage instances on machines
  // Allocates a Machine as Instance for tenant, with the given configuration
  rpc AllocateInstance(InstanceAllocationRequest) returns (Instance);
  // Releases an instance that has been allocated by a tenant
  rpc ReleaseInstance(InstanceReleaseRequest) returns (InstanceReleaseResult);
  // Updates the network interface configuration for an instance
  // The update will take effect asynchronously. Users should monitor `Instance.status.network_status.synced`
  // to determine whether all updates have been applied.
  // Note: This is commented because we will not immediately implement the method
  // rpc UpdateInstanceNetworkConfig(InstanceNetworkConfigUpdateRequest) returns (Instance);
  rpc FindInstances(InstanceSearchQuery) returns (InstanceList);
  rpc FindInstanceByMachineID(MachineId) returns (InstanceList);

  // INTERNAL: RPC method is used between Site Controller components,
  // and for testing
  rpc RecordObservedInstanceNetworkStatus(InstanceNetworkStatusObservation) returns (ObservedInstanceNetworkStatusRecordResult);
  // forge-dpu-agent -> carbide-api
  rpc GetManagedHostNetworkConfig(ManagedHostNetworkConfigRequest) returns (ManagedHostNetworkConfigResponse);
  rpc RecordDpuNetworkStatus(DpuNetworkStatus) returns (google.protobuf.Empty);
  rpc DpuAgentUpgradeCheck(DpuAgentUpgradeCheckRequest) returns (DpuAgentUpgradeCheckResponse);
  rpc DpuAgentUpgradePolicyAction(DpuAgentUpgradePolicyRequest) returns (DpuAgentUpgradePolicyResponse);

  rpc LookupRecord(DNSMessage.DNSQuestion) returns (DNSMessage.DNSResponse);
//  rpc LookupPTRRecord(DnsRequest) returns (DnsReply);

  // TODO(ajf): Harder to implement bi-directional streaming, commented out for now
  // rpc StreamConsole(stream ConsoleInput) returns (stream ConsoleOutput);
  // rpc StreamInstanceEvents(UUID) returns (stream InstanceEvent);

  /* Power Control */
  rpc InvokeInstancePower(InstancePowerRequest) returns (InstancePowerResult);

  rpc ForgeAgentControl(ForgeAgentControlRequest) returns (ForgeAgentControlResponse);
  // PRIVILEGED: Creates a new machine from nothing
  rpc DiscoverMachine(MachineDiscoveryInfo) returns (MachineDiscoveryResult);
  rpc RenewMachineCertificate(MachineCertificateRenewRequest) returns (MachineCertificateResult);
  rpc DiscoveryCompleted(MachineDiscoveryCompletedRequest) returns (MachineDiscoveryCompletedResponse);
  rpc CleanupMachineCompleted(MachineCleanupInfo) returns (MachineCleanupResult);
  // Invoked by forge-scout whenever a certain Machine can not be properly acted on
  rpc ReportForgeScoutError(ForgeScoutErrorReport) returns (ForgeScoutErrorReportResult);
  rpc DiscoverDhcp(DhcpDiscovery) returns (DhcpRecord);

  // PRIVILEGED: Get a single machine
  rpc GetMachine(MachineId) returns (Machine);

  // PRIVILEGED: Find things
  // DEPRECATED: use FindMachineIds and FindMachinesByIds instead
  rpc FindMachines(MachineSearchQuery) returns (MachineList);
  rpc FindInterfaces(InterfaceSearchQuery) returns (InterfaceList);
  rpc DeleteInterface(InterfaceDeleteQuery) returns (google.protobuf.Empty);
  rpc FindIpAddress (FindIpAddressRequest) returns (FindIpAddressResponse);
  rpc FindMachineIds(MachineSearchConfig) returns (MachineIdList);
  rpc FindMachinesByIds(MachineIdList) returns (MachineList);
  rpc FindConnectedDevicesByDpuMachineIds(MachineIdList) returns (ConnectedDeviceList);

  // IPMI handling
  rpc GetBMCMetaData(BMCMetaDataGetRequest) returns (BMCMetaDataGetResponse);
  rpc UpdateBMCMetaData(BMCMetaDataUpdateRequest) returns (BMCMetaDataUpdateResponse);

  // User Credential handling.
  rpc UpdateMachineCredentials(MachineCredentialsUpdateRequest) returns (MachineCredentialsUpdateResponse);

  rpc GetPxeInstructions(PxeInstructionRequest) returns (PxeInstructions);
  rpc GetCloudInitInstructions(CloudInitInstructionsRequest) returns (CloudInitInstructions);
  rpc Echo(EchoRequest) returns (EchoResponse);

  // Tenant, Tenant Team, & Tenant Public Key actions
  rpc CreateTenant(CreateTenantRequest) returns (CreateTenantResponse);
  rpc FindTenant(FindTenantRequest) returns (FindTenantResponse);
  rpc UpdateTenant(UpdateTenantRequest) returns (UpdateTenantResponse);

  rpc CreateTenantKeyset(CreateTenantKeysetRequest) returns (CreateTenantKeysetResponse);
  rpc FindTenantKeyset(FindTenantKeysetRequest) returns (TenantKeySetList);
  rpc UpdateTenantKeyset(UpdateTenantKeysetRequest) returns (UpdateTenantKeysetResponse);
  rpc DeleteTenantKeyset(DeleteTenantKeysetRequest) returns (DeleteTenantKeysetResponse);

  rpc ValidateTenantPublicKey(ValidateTenantPublicKeyRequest) returns (ValidateTenantPublicKeyResponse);

  // Admin CLI actions

  // Query Vault for the DPU's SSH admin password
  rpc GetDpuSSHCredential(CredentialRequest) returns (CredentialResponse);

  // List all machines network status (HBN), as reported by `forge-dpu-agent`
  rpc GetAllManagedHostNetworkStatus(ManagedHostNetworkStatusRequest) returns (ManagedHostNetworkStatusResponse);

  // Gets the latest Site Exploration report
  rpc GetSiteExplorationReport(GetSiteExplorationRequest) returns (site_explorer.SiteExplorationReport);
  // Explore an individual BMC and show the report
  rpc Explore(ExploreRequest) returns (site_explorer.EndpointExplorationReport);

  // Force deletes a Machine and the associated DPU from Forge databases,
  // with the intention of rediscovering the host later on.
  // The command will not stop a running tenant instance. Only a reboot that forces
  // the Forge PXE boot process again would stop the image and run the discovery
  // process again.
  //
  // Due to the not well defined state that hosts are in after calling this command,
  // it should not be used by Tenants or Site Providers to release instances. Those
  // should use customer-facing commands like `ReleaseInstance`.
  //
  // AdminForceDeleteMachine is a lower level admin tool for cases where there is no
  // appropriate customer-facing workflow available or where those workflows fail.
  rpc AdminForceDeleteMachine(AdminForceDeleteMachineRequest) returns (AdminForceDeleteMachineResponse);

  // Reboot a machine and boot into PXE
  rpc AdminReboot(AdminRebootRequest) returns (AdminRebootResponse);

  // List existing resource pools and their stats
  rpc AdminListResourcePools(ListResourcePoolsRequest) returns (ResourcePools);

  // Add capacity to a resource pool
  rpc AdminGrowResourcePool(GrowResourcePoolRequest) returns (GrowResourcePoolResponse);

  // Assign all VPCs a VNI
  rpc MigrateVpcVni(google.protobuf.Empty) returns (MigrateVpcVniResponse);

  // Maintenance mode operations: enable, disable
  rpc SetMaintenance(MaintenanceRequest) returns (google.protobuf.Empty);

  // Set RUST_LOG dynamically
  rpc SetLogFilter(LogFilterRequest) returns (google.protobuf.Empty);

  // Trigger reprovisioning of DPU
  rpc TriggerDpuReprovisioning(DpuReprovisioningRequest) returns (google.protobuf.Empty);
  // List DPUs waiting for reprovisioning
  rpc ListDpuWaitingForReprovisioning(DpuReprovisioningListRequest) returns (DpuReprovisioningListResponse);

  // Trigger DPU reset. It works only if DPU is in DPU Not Ready state.
  // This is temporary command added to support MC team. It must be removed once site-explorere
  // is enabled on all the envs. This command modifies state directly, which can cause conflicts
  // with state machine.
  rpc TriggerDpuReset(DpuResetRequest) returns (DpuResetResponse);

  rpc GetMachineBootOverride(UUID) returns (MachineBootOverride);
  rpc SetMachineBootOverride(MachineBootOverride) returns (google.protobuf.Empty);
  rpc ClearMachineBootOverride(UUID) returns (google.protobuf.Empty);

  // Get Network topology
  rpc GetNetworkTopology(NetworkTopologyRequest) returns (NetworkTopologyData);
  rpc FindNetworkDevicesByDeviceIds(NetworkDeviceIdList) returns (NetworkTopologyData);

  // Reset a BMC
  rpc AdminBmcReset(AdminBmcResetRequest) returns (AdminBmcResetResponse);

  // Create Credential in Vault
  rpc CreateCredential(CredentialCreationRequest) returns (CredentialCreationResult);

  // Delete Credential in Vault
  rpc DeleteCredential(CredentialDeletionRequest) returns (CredentialDeletionResult);

  // Route Server Management
  rpc GetRouteServers(google.protobuf.Empty) returns (RouteServers);
  rpc AddRouteServers(RouteServers) returns (google.protobuf.Empty);
  rpc RemoveRouteServers(RouteServers) returns (google.protobuf.Empty);
  rpc ReplaceRouteServers(RouteServers) returns (google.protobuf.Empty);

  // MachineInventory
  rpc UpdateAgentReportedInventory(DpuAgentInventoryReport) returns (google.protobuf.Empty);

  // Phone Home
  rpc UpdateInstancePhoneHomeLastContact(InstancePhoneHomeLastContactRequest) returns (InstancePhoneHomeLastContactResponse);

  // Set Host UEFI password
  rpc SetHostUefiPassword(SetHostUefiPasswordRequest) returns (SetHostUefiPasswordResponse);

  // Identify the vendor of a BMC without logging into it
  rpc IdentifyBMC(IdentifyBMCRequest) returns (IdentifyBMCResponse);
}

enum CredentialType {
  HostBMC = 0;
  DPUBMC = 1;
  UFM = 2;
  DpuUefi = 3;
  HostUefi = 4;
  HostBMCFactoryDefault = 5;
  DpuBMCFactoryDefault = 6;
}

message CredentialCreationRequest {
  // Credential type
  CredentialType credential_type = 1;
  // The username of credential.
  // No need specify it for HostBMC, DPUBMC, DpuUefi.
  // For UFM, the username is the URL of UFM.
  optional string username = 2;
  // The password of credential for HostBMC, DPUBMC, DpuUefi.
  // For UFM, the password is the token of UFM.
  string password = 3;
  // For the BMC factory default credential: "dell", "lenovo", "hpe", "supermicro", etc
  optional string vendor = 4;
}

message CredentialDeletionRequest {
  CredentialType credential_type = 1;
  optional string username = 2;
}

message CredentialCreationResult {

}

message CredentialDeletionResult {

}

message VersionRequest {
    bool display_config = 1;
  }

message BuildInfo {
    string build_version = 1; // v2023.06-rc2-1-gc5c05de3
    string build_date = 2; // 2023-06-05
    string git_sha = 3; // c5c05de3
    string rust_version = 4; // rustc 1.68.0 (2c8cc3432 2023-03-06)
    string build_user = 5; // graham
    string build_hostname = 6; // fedora

    optional RuntimeConfig runtime_config = 50;
}

message RuntimeConfig {
    string listen = 1;
    string metrics_endpoint = 2;
    string otlp_endpoint = 3;
    string database_url = 4;
    bool enable_ip_fabric = 5;
    reserved 6; // deprecated rapid_iterations
    uint32 asn = 7;
    repeated string dhcp_servers = 8;
    repeated string route_servers = 9;
    bool enable_route_servers = 10;
    repeated string deny_prefixes = 11;
    repeated string site_fabric_prefixes = 12;

    // Only name. Rest config can be read from network-segment command.
    repeated string networks = 13;

    reserved 14;  // deprecated dpu_ipmi_reboot_args

    string dpu_ipmi_tool_impl = 15;
    uint32 dpu_ipmi_reboot_attempt = 16;

    optional string initial_domain_name = 17;
    string initial_dpu_agent_upgrade_policy = 18;

    map<string, string> dpu_nic_firmware_update_version = 19;
    bool dpu_nic_firmware_initial_update_enabled = 20;
    bool dpu_nic_firmware_reprovision_update_enabled = 21;
    int32 max_concurrent_machine_updates = 22;
    uint64 machine_update_runtime_interval = 23;

    bool dpu_dhcp_server_enabled = 24;
    bool nvue_enabled = 25;
    uint32 max_database_connections = 26;
 }

message MachineId {
  string id = 1;
}

message EchoRequest {
  string message = 1;
}

message EchoResponse {
  string message = 1;
}
message DNSMessage {

  message DNSQuestion {
    optional string qName = 1;  // FQDN including trailing dot
    optional uint32 qType = 2;  //
    optional uint32 qClass = 3; // Usually 1 (IN)
  }
  message DNSResponse {
    message DNSRR {
      optional string rdata = 5;
    }
    optional uint32 rcode = 1;
    repeated DNSRR rrs = 2;
  }
  optional DNSQuestion question = 1;
  optional DNSResponse response = 2;
}

message DnsRequest {
  string query = 1;
}

message DnsReply {
  string reply = 1;
}

message DomainList {
  repeated Domain domains = 1;
}

message Domain {
  UUID id = 1;
  string name = 2;

  google.protobuf.Timestamp created = 3;
  google.protobuf.Timestamp updated = 4;
  google.protobuf.Timestamp deleted = 5;
}

message DomainDeletion {
  UUID id = 1;
}

message DomainDeletionResult {

}

message DomainSearchQuery {
  optional UUID id = 1;
  optional string name = 2;
}

message ConsoleInput {
  string input = 1;
}

message ConsoleOutput {
  string output = 1;
}

message InstanceEvent {
  string event = 1;
}


// Primitives
message UUID {
  string value = 1;
}

message VpcSearchQuery {
  optional UUID id = 1;
  optional string name = 2;
}

message TenantSearchQuery {
  optional string tenantOrganizationId = 1;
}

message Vpc {
  UUID id = 1;
  string name = 2;
  string tenantOrganizationId = 3;

  string version = 99;

  // Not sure if we actually still need those
  google.protobuf.Timestamp created = 4;
  google.protobuf.Timestamp updated = 5;
  google.protobuf.Timestamp deleted = 6;

  optional string tenantKeysetId = 7;
  optional uint32 vni = 8;
  optional VpcVirtualizationType network_virtualization_type = 9;
}

message VpcCreationRequest {
  string name = 2;
  string tenantOrganizationId = 3;
  // this keyset will enable any key contained within it to access any instance associated with this VPC.
  optional string tenantKeysetId = 4;
  optional VpcVirtualizationType network_virtualization_type = 5;

  // Desired ID for this VPC. If the ID is not provided, Forge will generate
  // a random ID.
  // The VPC ID must be unique within the Forge site.
  optional UUID id = 6;
}

enum VpcVirtualizationType {
  ETHERNET_VIRTUALIZER = 0;
  // 1 was previously FORGE_NATIVE_NETWORKING
  ETHERNET_VIRTUALIZER_WITH_NVUE = 2;
}

message VpcUpdateRequest {
  UUID id = 1;
  // If the field here is set, the update will only be applied if the version
  // is equivalent to the current version on the Forge Site.
  // If a concurrent update changed the site configuration, the API will return
  // a `ConcurrentModificationError`.
  optional string if_version_match = 2;

  // CR question: To avoid the duplication between VpcUpdateRequest and
  // VpcCreationRequest and Vpc - we could move all user configurable fields into
  // a `message VpcConfig/VpcSettings`. However I don't feel like this would add
  // a lot for primitive types like Vpc.

  string name = 3;
  string tenantOrganizationId = 4;
  optional string tenantKeysetId = 5;
}

message VpcUpdateResult {
  // TODO: Should we also return the current state as a field here?
  // Probably won't hurt
}

message VpcDeletionRequest {
  UUID id = 1;
}

message VpcDeletionResult {
}

message VpcList {
  repeated Vpc vpcs = 1;
}

// Enumerates possible instance states from the view of a tenant
// This is only a subset of total states that the instance might be in, and
// excludes states that are used while the instance is not being allocated to
// a tenant.
enum TenantState {
  // The instance is currently getting provisioned for a tenant
  PROVISIONING = 0;
  // The instance is ready and can be used by the tenant
  READY = 1;
  // The instance has been ready, but the newest configuration that the tenant
  // desired has not been applied yet
  CONFIGURING = 2;
  // The instance is shutting down. Shutdown has not completed yet
  TERMINATING = 3;
  // The instance has fully shut down, and is no longer available for the user
  TERMINATED = 4;
  // The instance is in a terminal failed state. This state is equivalent to
  // DEACTIVATED - no user software is running anymore during the state. However
  // an instance might enter a FAILED state before even fully activating, in case
  // activation failed.
  FAILED = 5;
  // DPU is being reprovisioned.
  DPU_REPROVISIONING = 6;
}

// Describe the desired configuration of an IBPartition
message IBPartitionConfig {
  // The name of IBPartition.
  string name = 1;
  // The ID of tenant that IBPartition belong to
  string tenantOrganizationId = 2;
}

// Describe the status and applied configuration of an IBPartition
message IBPartitionStatus {
  // Provisioning state of this partition
  TenantState state = 1;
  // The result of last state controller run - it's outcome and an optional reason for that outcome
  optional ControllerStateReason state_reason = 8;

  // The pkey of IB Partition
  optional string pkey = 2;
  // The partition name of IB Partition
  optional string partition = 3;
  // can be range from 0-15
  optional int32 service_level = 4;
  // can be one of the following: 2.5, 10, 30, 5, 20, 40, 60, 80, 120, 14, 56, 112, 168, 25, 100, 200, or 300
  optional int32 rate_limit = 5;
  // For IB partitions, value can be 2k or 4k only
  optional int32 mtu = 6;
  // If true, SHARP applications ware created accordingly
  optional bool enable_sharp = 7;
}

// Describe an Infiniband based Partition configuration and status
message IBPartition {
  UUID id = 1;

  IBPartitionConfig config = 2;
  string config_version = 3;

  IBPartitionStatus status = 4;
}

message IBPartitionList {
  repeated IBPartition ib_partitions = 1;
}

message IBPartitionCreationRequest {
  IBPartitionConfig config = 1;
  // Desired ID for this Partition. If the ID is not provided, Forge will generate
  // a random ID.
  // The Partition ID must be unique within the Forge site.
  optional UUID id = 2;
}

message IBPartitionDeletionRequest {
  UUID id = 1;
}

message IBPartitionDeletionResult {
}

message IBPartitionSearchConfig {
  bool include_history = 1;
}

message IBPartitionQuery {
  UUID id = 1;
  optional IBPartitionSearchConfig search_config = 2;
}

message NetworkSegmentStateHistory {
  string state = 1;
  string version = 2;
  google.protobuf.Timestamp time = 3;
}

enum NetworkSegmentType {
  TENANT = 0;
  ADMIN = 1;
  UNDERLAY = 2;
}

message NetworkSegment {
  UUID id = 1;
  UUID vpc_id = 2;

  string name = 3;

  optional UUID subdomain_id = 4;
  optional int32 mtu = 5;

  repeated NetworkPrefix prefixes = 6;

  string version = 99;
  TenantState state = 100;
  repeated NetworkSegmentStateHistory history = 101;
  // The result of last state controller run - it's outcome and an optional reason for that outcome
  optional ControllerStateReason state_reason = 102;


  // Not sure if we actually still need those
  google.protobuf.Timestamp created = 11;
  google.protobuf.Timestamp updated = 12;
  google.protobuf.Timestamp deleted = 13;

  NetworkSegmentType segment_type = 14;
}

message NetworkSegmentCreationRequest {
  UUID vpc_id = 2;

  string name = 3;

  optional UUID subdomain_id = 4;
  optional int32 mtu = 5;

  repeated NetworkPrefix prefixes = 6;

  NetworkSegmentType segment_type = 7;

  // Desired ID for this Network Segment. If the ID is not provided, Forge will generate
  // a random ID.
  // The Network Segment ID must be unique within the Forge site.
  optional UUID id = 8;
}

message NetworkSegmentDeletionRequest {
  UUID id = 1;
}

message NetworkSegmentDeletionResult {
}

message NetworkSegmentSearchConfig {
  bool include_history = 1;
  bool include_num_free_ips = 2;
}

message NetworkSegmentQuery {
  UUID id = 1;
  optional NetworkSegmentSearchConfig search_config = 2;
}

message NetworkPrefix {
  UUID id = 1;
  string prefix = 2;
  optional string gateway = 3;
  int32 reserve_first = 4;
  VpcResourceState state = 5;
  repeated NetworkPrefixEvent events = 6;
  optional string circuit_id = 7;
  uint32 free_ip_count = 8;
}

message MachineState {
  string state = 1;
}

message InstancePowerRequest {
  MachineId machine_id = 1;

  enum Operation {
    POWER_RESET = 0;
  }
  Operation operation = 2;

  // Whether the `custom_ipxe` script that had been provided during instance creation
  // should be executed again during the next reboot.
  //
  // If the flag is set to `false` or not specified, Forge will only provide the
  // `custom_ipxe` script on the first boot attempt. For every subsequent boot,
  // the instance will use the default boot action - which is usually to boot from
  // the hard drive.
  //
  // If the `always_boot_with_custom_ipxe` flag is set during instance creation,
  // Forge will also provide the `custom_ipxe` script on every reboot. Thereby the
  // `always_boot_with_custom_ipxe` takes precedence over `boot_with_custom_ipxe`.
  bool boot_with_custom_ipxe = 3;

  // In case update is needed, and user wants to approve, they can inform via this flag.
  // If this flag is true, first update will be performed and then host will be rebooted.
  bool apply_updates_on_reboot = 4;
}

message InstancePowerResult {
}

message InstanceSearchQuery {
  optional UUID id = 1;
  optional Label label = 2;
}

message InstanceList {
  repeated Instance instances = 1;
}

message Label {
  string key = 1;
  optional string value = 2;
}

message Metadata {
  string name = 1;
  string description = 2;
  repeated Label labels = 3;
}

message InstanceAllocationRequest {
  // The Machine on top of which we create an Instance
  // If we go towards "we already have instances model", this would become more of a
  // AssignInstanceToTenant request, and the ID would be the instance_id
  MachineId machine_id = 1;

  // Desired configuration for the allocated instance
  InstanceConfig config = 2;

  // Desired ID for this Instance. If the ID is not provided, Forge will generate
  // a random ID.
  // The Instance ID must be unique within the Forge site.
  optional UUID instance_id = 3;

  reserved 11; // Was ssh_keys - replaced by tenantKeysetId in InstanceConfig.TenantConfig instead.
  Metadata metadata = 12;
}

// Tenant related configuration that is set once the instance is allocated
// by a tenant
message TenantConfig {
  // Identifies the tenant that uses this instance
  string tenant_organization_id = 1;

  // TODO: If we want to make those user-changeable, it might also be worthwhile to
  // move them into a message `InstanceImageConfig` or something along that.
  // Alternative is to instruct users to simply provision new images if they need
  // a different image.
  // In the model where `Instance`s also exist before being allocated by the user
  // then this one has at least one state change - from being empty to being populated.
  // We could also move all of this into a `message InstanceTenantConfig` to be
  // able to get from empty to populated.
  optional string user_data = 11;
  string custom_ipxe = 12;

  // If this flag is set to `true`, the instance will receive the `custom_ipxe` instructions
  // on every reboot attempts. Depending on the type of iPXE instructions, this might
  // lead the instance to reinstall itself on every reboot.
  //
  // If the flag is set to `false` or not specified, Forge will only provide the
  // `custom_ipxe` script on the first boot attempt. For every subsequent boot,
  // the instance will use the default boot action - which is usually to boot from
  // the hard drive.
  //
  // If the `custom_ipxe` instructions should only be used for specific reboots
  // in order to trigger reinstallation, tenants can use the `InvokeInstancePower`
  // API to reboot instances with the `boot_with_custom_ipxe` parameter set to
  // `true`.
  bool always_boot_with_custom_ipxe = 13;

  // If this flag is set to true` the instance will not transition to a Ready state until
  // InstancePhoneHomeLastContact is updated
  bool phone_home_enabled = 14;

  //TODO: make an API that allows these to be updated.  For now, they're set only at instance allocation.
  repeated string tenantKeysetIds = 8; // this may be empty
}

// Desired configuration for an instance
message InstanceConfig {
  // Tenant related configuration.
  // This field can be absent if the instance has not yet been allocated by
  // a tenant. On assignment, the config changes once. Due to the one-time
  // change no version field is required.
  TenantConfig tenant = 1;

  // Configures instance networking configurations
  InstanceNetworkConfig network = 11;

  // Configures instance infiniband configurations.
  InstanceInfinibandConfig infiniband = 12;
}

// Desired network configuration for an instance
message InstanceNetworkConfig {
  // Configures how instance network interfaces are set up
  repeated InstanceInterfaceConfig interfaces = 1;

  // The ID of security group that is attached to this instance.
  // The configurations in this group apply to all interfaces on the instance.
  // Note: This is commented because we will not supported setting these in the first
  // release of the new Instance API
  // optional UUID security_group_id = 4;
}

// Desired infiniband configuration for an instance
message InstanceInfinibandConfig {
  // Configures how instance infiniband interfaces are set up
  repeated InstanceIBInterfaceConfig ib_interfaces = 1;
}

// New configuration for the instances network interfaces
// This completely overwrites the existing interfaces, so it would be up on the caller
// to make sure the new settings are consistent and old interfaces that should not be
// touched are listed here again.
// A change in any entry of `InstanceNetworkConfig::interface_configs` can be interpreted by
// Forge as deleting the old interface and replacing it with a new interface.
// Note: This is commented because we will not immediately implement the method
// message InstanceNetworkConfigUpdateRequest {
//   // The ID of the instance that should get an updated networking configuration
//   UUID instance_id = 1;

//   // If the field here is set, the update will only be applied if the version
//   // is equivalent to the current network config version on the Forge Site.
//   // If a concurrent update changed the site configuration, the API will return
//   // a `ConcurrentModificationError`.
//   optional string if_version_match = 2;

//   // The updated instance network configuration
//   InstanceNetworkConfig network_config = 3;
// }

// Current status of an instance
message InstanceStatus {
  // Status that is related to the tenant of the instance.
  // In case no tenant has been assigned to this instance, the field would be absent.
  optional InstanceTenantStatus tenant = 1;

  // Note: There will be a separate state for the states
  // that are only important for the site admin and forge team.
  // That state is at the moment defined on `message Machine`, but might
  // be carried over. It's outside of the scope of this change.

  // Status of the networking subsystem of an instance
  InstanceNetworkStatus network = 11;

  // Status of the infiniband subsystem of an instance
  InstanceInfinibandStatus infiniband = 12;

  // Whether all configurations related to an instance are in-sync.
  // This is a logical AND for the settings of all sub-configurations.
  // At this time it equals `InstanceNetworkStatus::configs_synced`,
  // but might in the future also include readiness for other subsystems.
  SyncState configs_synced = 101;

  // This indicates if updates are pending for the instance
  optional InstanceUpdateStatus update = 102;
}

// State of the networking subsystem of an instance
message InstanceNetworkStatus {
  // Status for each configured interface
  //
  // Each entry in this status array maps to it's corresponding entry in the
  // Config section. E.g. `instance.status.network.interface_status[1]`
  // would map to `instance.config.network.interface_configs[1]`.
  repeated InstanceInterfaceStatus interfaces = 1;

  // Whether all desired network changes that the user has applied have taken effect
  // This includes:
  // - Whether `InstanceNetworkConfig` is of exactly the same version as the
  //   version the user desires.
  // - Whether the version of each security policy that is either directly referenced
  //   as part of an `InstanceInterfaceConfig` or indirectly referenced via the
  //   the security policies that are applied to the VPC or NetworkSegment
  //   is exactly the same version as the version the user desires.
  //
  // Note for the implementation: We need to monitor all these config versions
  // on the feedback path from DPU to carbide in order to know whether the
  // changes have indeed taken effect.
  // TODO: Do we also want to show all applied versions here, or just track them
  // internally? Probably not help for for tenants at all - but it could be helpful
  // for the Forge operating team to debug settings that to do do not go in-sync
  // without having to attach to the database.
  SyncState configs_synced = 101;
}

// State of the infiniband subsystem of an instance
message InstanceInfinibandStatus {
  // Status for each configured interface
  //
  // Each entry in this status array maps to it's corresponding entry in the
  // Config section. E.g. `instance.status.network.ib_interface_status[1]`
  // would map to `instance.config.network.ib_interface_configs[1]`.
  repeated InstanceIBInterfaceStatus ib_interfaces = 1;

  // Whether all desired infiniband changes that the user has applied have taken effect
  // This includes:
  // - Whether `InstanceInfinibandConfig` is of exactly the same version as the
  //   version the user desires.
  //
  // TODO: Do we also want to show all applied versions here, or just track them
  // internally? Probably not help for for tenants at all - but it could be helpful
  // for the Forge operating team to debug settings that to do do not go in-sync
  // without having to attach to the database.
  SyncState configs_synced = 101;
}

// Contains all information about an actively running instance
// This entails both the instance configuration, as well as the current state of the instance
message Instance {
  // Instance ID
  UUID id = 1;
  // The ID of the host machine which is utilized for this Instance (host_machine_id)
  MachineId machine_id = 2;
  Metadata metadata = 3;

  // The desired configuration on the instance
  InstanceConfig config = 103;

  // The most recent status of the instance that has been observed
  InstanceStatus status = 104;

  // Current version of the networking configuration that is applied on the instance
  // This field can be used in InstanceNetworkConfigUpdateRequest::if_version_match
  // to only request updates if the version hasn't been updated in between.
  string network_config_version = 201;

  // Current version of the infiniband configuration that is applied on the instance
  // This field can be used in InstanceInfinibandConfigUpdateRequest::if_version_match
  // to only request updates if the version hasn't been updated in between.
  string ib_config_version = 202;
}

message InstanceUpdateStatus {
  enum Module {
    Dpu = 0;
  }

  Module module = 1;
  string initiator = 2;
  google.protobuf.Timestamp trigger_received_at = 3;
  optional google.protobuf.Timestamp update_triggered_at = 4;
  bool user_approval_received = 5;
}

// The configuration that a customer desires for an instances network interface
message InstanceInterfaceConfig {
  // Whether the user wants to create a physical or virtual function
  InterfaceFunctionType function_type = 1;

  // Network segment ID can change. It if changes - we require a new IP address
  UUID network_segment_id = 3;

  // The ID of security group that is attached to this interface
  // Note: This is commented because we will not supported setting these in the first
  // release of the new Instance API
  // optional UUID security_group_id = 4;
}

// The configuration that a customer desires for an instances IB interface
message InstanceIBInterfaceConfig {
  // The name of the device that gets configured
  string device = 1;

  // The device vendor.
  optional string vendor = 2;

  reserved 3; // fabric

  // If multiple devices with the same name - and connected to the same
  // fabric - are available, this selects the device among these.
  // `device_instance == 1` selects the 2nd device of a certain type.
  //
  // Forge will internally order devices of the same type by PCI slot in order
  // to achieve deterministic device selection via `device_instance`.
  uint32 device_instance = 4;

  // Whether the interface is a physical or virtual function
  // In the case of a virtual function the associated
  // `virtual_function_id` describes the ID of the interface
  InterfaceFunctionType function_type = 11;

  // If the interface is defined as a virtual function (associated
  // `InstanceInterfaceConfig.function_type == InterfaceFunctionType::VIRTUAL_FUNCTION`,
  // then this value is set and specifies the virtual function ID that is configured
  // for this network interface.
  optional uint32 virtual_function_id = 12;

  // The actual configuration for the device
  UUID ib_partition_id = 21;
}

// The actual status of a single network interface of an instance
message InstanceInterfaceStatus {
  // If the interface is defined as a virtual function (associated
  // `InstanceInterfaceConfig.function_type == InterfaceFunctionType::VIRTUAL_FUNCTION`,
  // then this value is set and specifies the virtual function ID that is configured
  // for this network interface.
  optional uint32 virtual_function_id = 1;

  // The MAC address which has been assigned to this interface
  // The list will be empty if interface configuration hasn't been completed
  // and therefore the address is unknown.
  optional string mac_address = 2;

  // The list of IP addresses that had been assigned to this interface,
  // based on the requested subnet.
  // The list will be empty if interface configuration hasn't been completed
  repeated string addresses = 3;
}

// The actual status of a single IB interface of an instance
message InstanceIBInterfaceStatus {
  // The GUID of the hardware device that this interface is attached to
  optional string pf_guid = 1;

  // The GUID which has been assigned to this interface
  // In case the interface is a PF interface, the GUID will be equivalent to
  // `pf_guid` - which is the GUID that is stored on the hardware device.
  // For a VF interface, this is a GUID that has been allocated by Forge in order
  // be used for the VF.
  // Tenants have to configure the VF device on their instances to use this GUID.
  optional string guid = 2;

  // The local id of this IB interface; if interface configuration has not been completed, the value is 0.
  uint32 lid = 11;

  // The list of IP addresses that had been assigned to this interface,
  // based on the requested partition.
  // The list will be empty if interface configuration hasn't been completed or IPoIB disabled
  // TODO: This is for future use - once once Forge supports IP over IB
  // repeated string addresses = 21;
}

message InstancePhoneHomeLastContactRequest {
  UUID instance_id = 1;
}

message InstancePhoneHomeLastContactResponse {
  google.protobuf.Timestamp timestamp = 1;
}

message InstanceReleaseRequest {
  UUID id = 1;
}

message InstanceReleaseResult {
}

message MachineSearchConfig {
  bool include_dpus = 1;
  bool include_history = 2;
  bool include_predicted_host = 3;
  bool only_maintenance = 4;
  bool include_associated_machine_id = 5;
  bool exclude_hosts = 6;
}

message MachineSearchQuery {
  optional MachineId id = 1;
  optional string fqdn = 2;
  optional MachineSearchConfig search_config = 3;
}

message InterfaceList {
  repeated MachineInterface interfaces = 1;
}

message MachineList {
  repeated Machine machines = 1;
}

message InterfaceDeleteQuery {
  UUID id = 1;
}

message InterfaceSearchQuery {
  optional UUID id = 1;
  optional string ip = 2;
}

enum MachineType {
  UNKNOWN = 0;
  DPU = 1;
  HOST = 2;
}

message BmcInfo {
  optional string ip = 1;
  optional string mac = 2;
  optional string version = 3;
  optional string firmware_version = 4;
  optional uint32 port = 5;
}

message Machine {
  // Uniquely identifies a Forge machine.
  // The value of this field is globally unique.
  MachineId id = 1;

  reserved 4, 5, 6; // Used for timestamps in the past

  // The current lifecycle state of the machine
  string state = 7;
  // Version field that is associated with the `state` of the machine.
  // Every time the lifecycle state of the `Machine` changes for any reason, the version field will be updated.
  string state_version = 13;
  // The result of last state controller run - it's outcome and an optional reason for that outcome
  optional ControllerStateReason state_reason = 25;

  // The history of the state for the machine. Only populated if `include_history` is set.
  repeated MachineEvent events = 8;

  // Note: This is not yet removed in this change to limit the amount of breaking
  // changes at once - but users shouldn't rely on it. The actually interesting
  // information around interfaces for Instance users is in `Instance::InstanceNetworkStatus`.
  repeated MachineInterface interfaces = 9;

  // TODO: This field might actually move Instance since the discovered hardware
  // could be different per lifecycle. When the machine is updated with different
  // hardware and restarted, the data can change. The Instance would have the
  // capability to store the actual discovery information for each lifecycle
  optional machine_discovery.DiscoveryInfo discovery_info = 10;

  // Machine type if it is a DPU or HOST.
  MachineType machine_type = 11;

  BmcInfo bmc_info = 12;

  google.protobuf.Timestamp last_reboot_time = 14;
  NetworkHealth network_health = 15;
  google.protobuf.Timestamp last_observation_time = 16;
  optional string maintenance_reference = 17;
  optional google.protobuf.Timestamp maintenance_start_time = 18;

  // Other machine ids associated with this machine
  optional MachineId associated_host_machine_id = 19;
  optional MachineId associated_dpu_machine_id = 20;

  optional MachineInventory inventory = 21;
  optional google.protobuf.Timestamp last_reboot_requested_time = 22;
  optional string last_reboot_requested_mode = 23;

  optional string dpu_agent_version = 24;

  // Fields are not ordered numerically, check the whole message for max field number
}

message DpuAgentInventoryReport {
  MachineId machine_id = 1;
  MachineInventory inventory = 2;
}

message MachineInventory {
  repeated MachineInventorySoftwareComponent components = 1;
}

message MachineInventorySoftwareComponent {
  string name = 1;
  string version = 2;
  string url = 3;
}

// Result of last state controller iteration
message ControllerStateReason {
  ControllerStateOutcome outcome = 1;
  optional string outcome_msg = 2;
}

enum ControllerStateOutcome {
  WAIT = 0;
  ERROR = 1;
  TRANSITION = 2;
  DO_NOTHING = 3;
  TODO = 4;
}

// The most recent tenant related status
message InstanceTenantStatus {
  // The current state of the instance from the point of view of the assigned tenant
  TenantState state = 1;
  // An optional message which can contain details about the state
  string state_details = 2;
}

enum SyncState {
  // All configuration changes that users requested have been applied
  SYNCED = 0;
  // At least one configuration change to an active instance has not yet been processed
  PENDING = 1;
}

enum MachineArchitecture {
  ARM = 0;
  X86 = 1;
}

message MachineEvent {
  int64 id = 1;
  MachineId machine_id = 2;

  // The lifecycle state of the Machine
  string event = 3;
  // The version field that is associated with this event
  string version = 5;

  google.protobuf.Timestamp time = 4;
}

message MachineInterface {
  UUID id = 1;
  optional MachineId attached_dpu_machine_id = 2;
  MachineId machine_id = 3;
  UUID segment_id = 4;

  string hostname = 5;

  UUID domain_id = 6;

  bool primary_interface = 7;
  string mac_address = 8;

  repeated string address = 9;
  optional string vendor = 10;

  google.protobuf.Timestamp created = 11;
  optional google.protobuf.Timestamp last_dhcp = 12;
}

message DhcpDiscovery {
  string mac_address = 1;
  string relay_address = 2;
  optional string vendor_string = 3;
  optional string link_address = 4;
  optional string circuit_id = 5;
  optional string remote_id = 6;
}

message DhcpRecord {
  MachineId machine_id = 1;
  UUID machine_interface_id = 2;
  UUID segment_id = 3;
  UUID subdomain_id = 4;

  string fqdn = 5;
  string mac_address = 6;
  string address = 7;

  int32 mtu = 8;

  string prefix = 9;

  optional string gateway = 10;

  optional string booturl = 11;
}

message NetworkSegmentList {
  repeated NetworkSegment network_segments = 1;
}

message Tag {
  string slug = 1;
  optional string name = 3;  // Mandatory in case of CREATE action.
}

message TagCreate {
  Tag tag = 1;
}

message TagDelete {
  Tag tag = 1;
}

message TagResult {
  bool result = 1;
}

message TagVoid {
}

message TagsList {
  repeated string slugs = 1;
  UUID target = 2;
  TagTargetKind target_kind = 3;
}

message TagsListResult {
  repeated Tag tags = 1;
}

enum TagTargetKind {
  MACHINE = 0;
  NETWORK_SEGMENT = 1;
}

message TagAssign {
  string slug = 1;
  UUID target = 2;
  TagTargetKind target_kind = 3;
}

message TagRemove {
  string slug = 1;
  UUID target = 2;
  TagTargetKind target_kind = 3;
}

message SSHKeyValidationRequest {
    string user = 1;
    string pubkey = 2;
}

enum UserRoles {
  USER = 0;
  ADMINISTRATOR = 1;
  OPERATOR = 2;
  NOACCESS = 3;
}

message SSHKeyValidationResponse {
    bool is_authenticated = 1;
    UserRoles role = 2;
}

message CredentialRequest {
    string host_id = 1;  // UUID, IP address, host name or MAC address
}

message CredentialResponse {
    string username = 1;
    string password = 2;
}

message GetSiteExplorationRequest {

}

message ExploreRequest {
  // IP address of the BMC to explore
  string address = 1;
}

message ManagedHostNetworkConfigRequest {
  MachineId dpu_machine_id = 1;
}

message ManagedHostNetworkConfigResponse {
  reserved 1; // previously is_production_mode

  // ASN and DHCP servers are not versioned, they are fixed on process start

  // ASN
  uint32 asn = 2;
  // DHCP servers that the host DHCP requests should be relayed to
  repeated string dhcp_servers = 3;

  // "" when on admin network, "vxlan5555" otherwise.
  // vxlan5555 is special HBN single vxlan device. It handles networking between machines on the
  // same subnet. It handles the encapsulation into VXLAN and VNI for cross-host comms.
  // VNI device is not versioned
  string vni_device = 4;

  ManagedHostNetworkConfig managed_host_config = 5;
  string managed_host_config_version = 6;

  bool use_admin_network = 7;
  FlatInterfaceConfig admin_interface = 8;

  repeated FlatInterfaceConfig tenant_interfaces = 9;
  // Blank if on the admin network, matches DB instances.network_config if there's a tenant
  string instance_config_version = 10;
  optional UUID instance_id = 11;

  // Both None if on the admin network
  optional VpcVirtualizationType network_virtualization_type = 12;
  optional uint32 vpc_vni = 13;

  // IP addresses of the L2VPN route servers
  repeated string route_servers = 14;

  // Remote ID. Used by DPU to update host's DHCP request with option 82.
  string remote_id = 15;

  // IPv4 prefixes to be denied in the DPU ACL rules.
  repeated string deny_prefixes = 16;

  // Enable forge DHCP on HBN
  bool enable_dhcp = 100;

  // Host primary interface id
  optional string host_interface_id = 102;
}

// Network configuration for a managed host (host + DPU pair) managed by Forge
message ManagedHostNetworkConfig {
  // DPU loopback IP
  string loopback_ip = 1;
}

message FlatInterfaceConfig {
    InterfaceFunctionType function_type = 1;
    // aka circuit_id
    uint32 vlan_id = 2;
    // vxlan id
    uint32 vni = 3;
    // in CIDR notation
    string gateway = 4;
    // host admin ip for admin network, host ip for tenant
    string ip = 5;
    // If the interface is defined as a virtual function (associated
    // `function_type == InterfaceFunctionType::VIRTUAL_FUNCTION`,
    // then this value is set and specifies the virtual function ID that is configured
    // for this network interface.
    optional uint32 virtual_function_id = 6;
    // A list of IPv4 prefixes that belong to this VPC. Note this may contain
    // the prefix from the network segment this interface is attached to (which
    // could be independently derived from the `gateway` field).
    repeated string vpc_prefixes = 7;
    // Prefix for ip
    string prefix = 8;
    // FQDN
    string fqdn = 9;
    // boot_url
    optional string booturl = 10;
}

message ManagedHostNetworkStatusRequest {}
message ManagedHostNetworkStatusResponse {
    repeated DpuNetworkStatus all = 1;
}

message DpuAgentUpgradeCheckRequest {
    string machine_id = 1;
    string current_agent_version = 2;
    google.protobuf.Timestamp binary_mtime = 3;
    string binary_sha = 4;
}

message DpuAgentUpgradeCheckResponse {
  bool should_upgrade = 1;
  string package_version = 2; // Update to this version of the .deb package
  string server_version = 3;
}

message DpuAgentUpgradePolicyRequest {
  optional AgentUpgradePolicy new_policy = 1;
}

enum AgentUpgradePolicy {
  OFF = 0;
  UP_ONLY = 1;
  UP_DOWN = 2;
}

message DpuAgentUpgradePolicyResponse {
  // The policy in effect right now
  AgentUpgradePolicy active_policy = 1;
  // Did we just change it because of a user request?
  bool did_change = 2;
}

message AdminForceDeleteMachineRequest {
    // UUID, IP address, host name or MAC address of either the host or DPU to force delete
    string host_query = 1;

    // Should we delete oob_net0 and host interfaces?
    bool delete_interfaces = 2;

    // Should we delete BMC interfaces? Please note, this will depend on if BMC interfaces
    // are associated with machine.
    bool delete_bmc_interfaces = 3;
}

// Response to AdminForceDeleteMachine call
// Describes which resources have been released
message AdminForceDeleteMachineResponse {
    bool all_done = 1;

    string managed_host_machine_id = 11;
    string managed_host_machine_interface_id = 12;
    string dpu_machine_id = 13;
    string dpu_machine_interface_id = 14;
    string instance_id = 15;

    string managed_host_bmc_ip = 21;
    string dpu_bmc_ip = 22;

    reserved 31, 32, 33, 34; // Had been related to the deprecated forge-vpc service

    // How many interfaces have been unregistered from UFM
    uint32 ufm_unregistrations = 35;
    // UFM unregistrations have been started, but could not be finished
    bool ufm_unregistaration_pending = 36;

    // The Machines lockdown state before it was attempted to unlock the Machine
    string initial_lockdown_state = 41;
    // Whether the Machine had been unlocked as part of this action
    bool machine_unlocked = 42;

    // Whether the machine interfaces are deleted.
    bool host_interfaces_deleted = 43;
    bool dpu_interfaces_deleted = 44;

    // Whether the BMC interfaces are found.
    bool host_bmc_interface_associated = 45;
    bool dpu_bmc_interface_associated = 46;

    // Whether the BMC interfaces are deleted.
    bool host_bmc_interface_deleted = 47;
    bool dpu_bmc_interface_deleted = 48;


}

// Must provide either machine_id or user/password pair
message AdminRebootRequest {
    string ip = 1;
    optional uint32 port = 2;
    optional string user = 3;
    optional string password = 4;
    optional string machine_id = 5;
}

message AdminRebootResponse {}

// Must provide either machine_id or user/password pair
message AdminBmcResetRequest {
  string ip = 1;
  optional uint32 port = 2;
  optional string user = 3;
  optional string password = 4;
  optional string machine_id = 5;
}

message AdminBmcResetResponse {}

enum BMCRequestType {
    IPMI = 0;
    REDFISH = 1;
}

message BMCMetaDataGetRequest {
    MachineId machine_id = 1;
    UserRoles role = 2;
    BMCRequestType request_type = 3;
}

message BMCMetaDataGetResponse {
    string ip = 1;
    string user = 2;
    string password = 3;
    string mac = 4;
    optional uint32 port = 5;
}

message BMCMetaDataUpdateRequest {
    message DataItem {
        string user = 2;
        UserRoles role = 3;
        string password = 4;
    }

    MachineId machine_id = 1;
    repeated DataItem data = 2;
    BMCRequestType request_type = 3;
    BmcInfo bmc_info = 4;
}

message BMCMetaDataUpdateResponse {}

message MachineCredentialsUpdateRequest {
   enum CredentialPurpose {
      HBN = 0;
      LOGIN_USER = 1;
   }
    message Credentials {
        string user = 1;
        string password = 2;
        CredentialPurpose credential_purpose = 3;
    }

    MachineId machine_id = 4;
    repeated Credentials credentials = 5;
}

message MachineCredentialsUpdateResponse {}

message ForgeAgentControlRequest {
    MachineId machine_id = 1;
}

message ForgeAgentControlResponse {
	enum Action {
		NOOP = 0;       // No operation. Do nothing
		RESET = 1;      // Wipe the machine, prepare for next tenant
		DISCOVERY = 2;  // Run full discovery
		REBUILD = 3;    // Future thingy
		RETRY = 4;      // Machine needs more time to come in proper state. Retry again.
	}
	Action action = 1;
}

message MachineDiscoveryInfo {
  UUID machine_interface_id = 1;
  oneof discovery_data {
    machine_discovery.DiscoveryInfo info = 2;
  }
  bool create_machine = 3;
}

message MachineDiscoveryCompletedRequest {
	MachineId machine_id = 1;
  optional string DiscoveryError = 2;
}

message MachineCleanupInfo {
	enum CleanupResult {
		OK = 0;
		ERROR = 1;
	}
	message CleanupStepResult {
		CleanupResult result = 1;
		// If the result was an error, this can contain the associate error message
		string message = 2;
	}

	MachineId machine_id = 1;

	// NVMe Cleanup Result
	CleanupStepResult nvme = 2;
	// RAM cleanup result
	CleanupStepResult ram = 3;
	// EFI variable MemoryOverwriteRequestControl-e20939be-32d4-41be-a150-897f85d49829 must be set to 1
	CleanupStepResult mem_overwrite = 4;
	// Reset IB devices
	CleanupStepResult ib = 5;

	CleanupResult result = 11;
}

message MachineCertificate {
  bytes public_key = 1;
  bytes private_key = 2;
  bytes issuing_ca = 3;
}

message MachineCertificateRenewRequest {} // The certificate to renew is delivered via the TLS channel.
message MachineCertificateResult {
  // the renewed certificate for the client that
  MachineCertificate machine_certificate = 1;
}

message MachineDiscoveryResult {
  // This is returned to the discovery client from the API. Lets try not to put much in here unless we need it.
  MachineId machine_id = 1;
  // This is returned to the discovery client so that it can use the embedded certificate to authenticate to the api for further communications.
  MachineCertificate machine_certificate = 2;
}

message MachineDiscoveryCompletedResponse { }

message MachineCleanupResult {
  // This is returned to the discovery client from the API. Lets try not to put much in here unless we need it.
}

message ForgeScoutErrorReport {
  // Machine that encountered the error
  // This might be null if the MachineId could not be resolved
  MachineId machine_id = 1;
  // Interface ID of the Machine that encountered the error
  UUID machine_interface_id = 2;
  // Error report
  string error = 3;
}

message ForgeScoutErrorReportResult {
}

message VpcResourceState {
    string state = 1;
}

message NetworkPrefixEvent {
  int64 id = 1;

  UUID network_prefix_id = 2;

  VpcResourceAction event = 3;

  google.protobuf.Timestamp time = 4;
}

message VpcResourceLeafEvent {
  int64 id = 1;

  UUID vpc_leaf_id = 2;

  VpcResourceAction event = 3;

  google.protobuf.Timestamp time = 4;
}

enum VpcResourceAction {
  VPC_INITIALIZE = 0;
  VPC_SUBMIT = 1;
  VPC_ACCEPT = 2;
  VPC_WAIT = 3;
  VPC_FAIL = 4;
  VPC_SUCCESS = 5;
  VPC_RECOMMISSION = 6;
}

message PxeInstructionRequest {
  MachineArchitecture arch = 1;
  UUID interface_id = 2;
}

message PxeInstructions {
  string pxe_script = 1;
}

message CloudInitDiscoveryInstructions {
  MachineInterface machine_interface = 1;
  Domain domain = 2;
  bool update_firmware = 3;
}

message CloudInitMetaData {
  string instance_id = 1;
  string cloud_name = 2;
  string platform = 3;
}

message CloudInitInstructionsRequest {
  string ip = 1;
}

message CloudInitInstructions {
  optional string custom_cloud_init = 1;
  optional CloudInitDiscoveryInstructions discovery_instructions = 2;
  optional CloudInitMetaData metadata = 3;
}

// Specifies whether a network interface is physical network function (PF)
// or a virtual network function
enum InterfaceFunctionType {
  PHYSICAL = 0;
  VIRTUAL = 1;
}

// What forge-dpu-agent reports. Will grow over time.
message DpuNetworkStatus {
  MachineId dpu_machine_id = 1;
  google.protobuf.Timestamp observed_at = 2;
  NetworkHealth health = 3;
  optional string network_config_version = 4;
  optional string instance_config_version = 5;
  repeated InstanceInterfaceStatusObservation interfaces = 6;
  optional string network_config_error = 7;
  optional UUID instance_id = 8;
  optional string dpu_agent_version = 9;
  optional int64 client_certificate_expiry_unix_epoch_secs = 10;
}

// Observed status of the networking subsystem of an instance
message InstanceNetworkStatusObservation {
  // The ID of the instance for which this status was observed
  UUID instance_id = 1;

  // The version of the config that is applied on the networking subsystem
  // Only if the version is equivalent to the latest desired version we
  // can actually interpret the results. If the version is outdated, then the
  // list of interfaces might actually relate to a different interfaces than
  // the ones that are currently required by the networking config.
  string config_version = 2;

  // When this status was observed
  //
  // If the field isn't populated, the server will assume that status is up to
  // date. Clients can set the timestamp to indicate that they provide a status
  // to the server that is based on an older observation (e.g. a cache). This
  // can help the server to decide whether the data that is acted upon might be
  // outdated, and might not indicate that networking is still configured correctly.
  optional google.protobuf.Timestamp observed_at = 3;

  // Status for each configured interface
  repeated InstanceInterfaceStatusObservation interfaces = 4;
}

// Result for the RecordObservedInstanceNetworkStatus method
message ObservedInstanceNetworkStatusRecordResult {
}

// Observed status of a single network interface of an instance
message InstanceInterfaceStatusObservation {
  // Whether the interface is a physical or virtual function
  // In the case of a virtual function the associated
  // `virtual_function_id` describes the ID of the interface
  InterfaceFunctionType function_type = 1;

  // If the interface is defined as a virtual function (associated
  // `function_type == InterfaceFunctionType::VIRTUAL_FUNCTION`,
  // then this value is set and specifies the virtual function ID that is configured
  // for this network interface.
  optional uint32 virtual_function_id = 2;

  // The MAC address which has been assigned to this interface
  // The list will be empty if interface configuration hasn't been completed
  // and therefore the address is unknown.
  optional string mac_address = 3;

  // The list of IP addresses that had been assigned to this interface,
  // based on the requested subnet.
  // The list will be empty if interface configuration hasn't been completed
  repeated string addresses = 4;
}

message TenantContent {
}

message Tenant {
  string organization_id = 1;
  TenantContent tenant_content = 2;
  // this string is used to verify that the client has the most updated "view" of a keyset when attempting to modify it
  string version = 3;
}

message CreateTenantRequest {
  // this organization ID must be globally unique
  string organization_id = 1;
}
message CreateTenantResponse {
  Tenant tenant = 1;
}

message UpdateTenantRequest {
  string organization_id = 1;
  TenantContent tenant_content = 2;

  // if this field is set and non-empty, the request will only update the tenant if the version matches the server's view,
  // otherwise it will return a concurrency related error.
  optional string if_version_match = 3;
}
message UpdateTenantResponse {
  // the updated tenant after modification
  Tenant tenant = 1;
}

message FindTenantRequest {
  string tenant_organization_id = 1;
}
message FindTenantResponse {
  Tenant tenant = 1;
}

message TenantKeysetIdentifier {
  // the organization_id of the associated tenant, required to be non-null and globally unique
  string organization_id = 1;
  // the id of the key, provided by the tenant.  Must be unique within the tenant's organization.
  // TODO: update this document once we have a clearer idea of the charset restrictions for this provided identifier.
  string keyset_id = 2;
}

message TenantPublicKey {
  string public_key = 1;
  optional string comment = 2;
}

message TenantKeysetContent {
  repeated TenantPublicKey public_keys = 1;
}

message TenantKeyset {
  TenantKeysetIdentifier keyset_identifier = 1;
  TenantKeysetContent keyset_content = 2;
  // this version will be used to determine if a client has the most updated "view" of a tenant when attempting to modify it
  string version = 3;
}

message CreateTenantKeysetRequest {
  TenantKeysetIdentifier keyset_identifier = 1;
  // it is allowed for the provided request to contain no keys, which will reserve the identifier as an empty set.
  TenantKeysetContent keyset_content = 2;
  // The new version that should be stored for the keyset. The Forge site controller
  // will store this version field as the new version for the data. It will not
  // assign a version on its own.
  string version = 3;
}
message CreateTenantKeysetResponse {
  TenantKeyset keyset = 1;
}

message FindTenantKeysetRequest {
  // The tenant organization for which to list keysets. If this is empty, the call will
  // return the key sets for all tenant organizations.
  optional string organization_id = 1;
  // The keyset ID within the tenant organization. If this is not empty, the call will
  // return only the content of a single keyset if this exists.
  // Otherwise all keysets for the selected tenant will be listed.
  optional string keyset_id = 2;
  // Whether to include the actual keys in the response. By default only the names
  // of the keysets will be returned and their versions. The keys will be omitted
  // since it is assumed that the caller (Forge Cloud API) is already aware of them.
  bool include_key_data = 3;

}
message TenantKeySetList {
  repeated TenantKeyset keyset = 1;
}

message UpdateTenantKeysetRequest {
  // this request will update the existing keyset provided the identifiers match
  TenantKeysetIdentifier keyset_identifier = 1;
  TenantKeysetContent keyset_content = 2;

  // The new version that should be stored for the keyset. The Forge site controller
  // will store this version field as the new version for the data. It will not
  // assign a version on its own.
  string version = 3;

  // if this field is set and non-empty, the request will only update the tenant if the version matches the server's view,
  // otherwise it will return a concurrency related error.
  optional string if_version_match = 4;
}
message UpdateTenantKeysetResponse {
  // Since the update request overwrites the whole keyset, the caller of the API
  // already knows the data that will be stored after a successful update.
  // Therefore this response does not need to carry any data.
}

message DeleteTenantKeysetRequest {
  TenantKeysetIdentifier keyset_identifier = 1;
}
message DeleteTenantKeysetResponse {}

// the tenantPublicKey will be checked against the following lists for permission to access the instance:
// 1) the instance's keysets.
// 2) the vpc's keyset.
// 3) the tenant's keyset.
// if the key is present in one of those lists, the request will be granted permission to access the instance.
message ValidateTenantPublicKeyRequest {
  string instance_id = 1;
  string tenant_public_key = 2;
}
// the status of the response will be in the grpc Status object, along with any associated Errors.
message ValidateTenantPublicKeyResponse {}

// Health of HBN on a DPU. Sent by forge-dpu-agent.
message NetworkHealth {
    bool is_healthy = 1;
    repeated string passed = 2;
    repeated string failed = 3;
    optional string message = 4;
}

message ListResourcePoolsRequest {}
message ResourcePools {
    repeated ResourcePool pools = 1;
}

message ResourcePool {
    string name = 1;
    string min = 2;
    string max = 3;
    uint64 total = 4;
    uint64 allocated = 5;
}

message GrowResourcePoolRequest {
	// TOML definition of resized pools
	string text = 1;
}

message GrowResourcePoolResponse {}

message Range {
    string start = 1;
    string end = 2;
}

enum ResourcePoolType {
    Integer = 0;
    Ipv4 = 1;
}

message MigrateVpcVniResponse {
	uint32 updated_count = 1;
	uint32 total_vpc_count = 2;
}

enum MaintenanceOperation {
  Enable = 0;
  Disable = 1;
}

message MaintenanceRequest {
  MaintenanceOperation operation = 1;
  // Managed host ID
  MachineId host_id = 2;
  // For Enable: The ticket tracker URL.
  optional string reference = 3;
}

message LogFilterRequest {
  string filter = 1;
  optional string expiry = 2;
}

message FindIpAddressRequest {
  string ip = 1;
}

message FindIpAddressResponse {
  repeated IpAddressMatch matches = 1;
  repeated string errors = 2;
}

enum UpdateInitiator {
  AdminCli = 0;
  Automatic = 1;
}

message DpuResetRequest {
  MachineId dpu_id = 1;
}

message DpuResetResponse {
  string msg = 1;
}

message DpuReprovisioningRequest {
  enum Mode {
    Set = 0;
    Clear = 1;
  }
  MachineId dpu_id = 1;
  Mode mode = 2;
  UpdateInitiator initiator = 3;
  bool update_firmware = 4;
}

message DpuReprovisioningListRequest {
}

message DpuReprovisioningListResponse {
  message DpuReprovisioningListItem {
    MachineId id = 1;  // Dpu Machine ID
    string state = 2;  // ManagedHost state
    string initiator = 3;  // Who requested this reprovisioning.
    google.protobuf.Timestamp requested_at = 4;  // When reprovisioning was requested.
    bool update_firmware = 5;
    optional google.protobuf.Timestamp initiated_at = 6;  // When reprovisioning is started.
    bool user_approval_received = 7;  // User approval received or not if needed
  }
  repeated DpuReprovisioningListItem dpus = 1;
}

message IpAddressMatch {
  IpType ip_type = 1;
  optional string owner_id = 2; // resource pool name, instance id, machine id, etc
  string message = 3; // Display to end user. Usually has more details than just type/owner_id.
}

// The things `forge-admin-cli ip find` searches.
//
// Why the IpType prefix on everything, you ask? Because:
// > Note that enum values use C++ scoping rules, meaning that enum values are siblings of their
// > type, not children of it.
// Yeah I'm surprised too.
enum IpType {
  IpTypeStaticDataDhcpServer = 0;
  IpTypeStaticDataRouteServer = 1;
  IpTypeResourcePool = 2;
  IpTypeInstanceAddress = 3;
  IpTypeMachineAddress = 4;
  IpTypeBmcIp = 5;
  IpTypeLoopbackIp = 6;
  IpTypeNetworkSegment = 7;
}

message MachineBootOverride {
  UUID machine_interface_id = 1;
  optional string custom_pxe = 2;
  optional string custom_user_data = 3;
}

// A connected device is described by DPU and local port.
message ConnectedDevice {
  MachineId id = 1;
  string local_port = 2;
  string remote_port = 3;
  optional string network_device_id = 4;
}

message ConnectedDeviceList {
  repeated ConnectedDevice connected_devices = 1;
}

// NetworkDevice and Switch are used interchangeably.
message NetworkDevice {
  string id = 1;
  string name = 2;
  optional string description = 3;
  repeated string mgmt_ip = 4;
  string discovered_via = 5;
  string device_type = 6;

  repeated ConnectedDevice devices = 7;
}

message NetworkTopologyRequest {
  optional string id = 1;
}

message NetworkDeviceIdList {
  repeated string network_device_ids = 1;
}

message NetworkTopologyData {
  repeated NetworkDevice network_devices = 1;
}

message RouteServers {
  repeated string route_servers = 1;
}

message MachineIdList {
  repeated MachineId machine_ids = 1;
}

message SetHostUefiPasswordRequest {
  MachineId host_id = 1;
}

message SetHostUefiPasswordResponse {}

message IdentifyBMCRequest {
  string address = 1;
}

message IdentifyBMCResponse {
  string known_vendor = 1;
  string raw_vendor = 2;
  bool is_lenovo = 3;
  bool is_dell = 4;
  bool is_mellanox = 5;
  bool is_supermicro = 6;
  bool is_viking = 7;
  bool is_hpe = 8;
}
