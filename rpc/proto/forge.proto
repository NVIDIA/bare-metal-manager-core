syntax = "proto3";

import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";
import "machine_discovery.proto";
import "security_group.proto";

package forge;

service Forge {
  // Domain
  rpc CreateDomain(Domain) returns (Domain);
  rpc UpdateDomain(Domain) returns (Domain);
  rpc DeleteDomain(DomainDeletion) returns (DomainDeletionResult);
  rpc FindDomain(DomainSearchQuery) returns (DomainList);
  // VPC
  rpc CreateVpc(VpcCreationRequest) returns (Vpc);
  rpc UpdateVpc(VpcUpdateRequest) returns (VpcUpdateResult);
  rpc DeleteVpc(VpcDeletionRequest) returns (VpcDeletionResult);
  rpc FindVpcs(VpcSearchQuery) returns (VpcList);

  // Segments - i.e. Overlay Networks
  rpc FindNetworkSegments(NetworkSegmentQuery) returns (NetworkSegmentList);
  rpc CreateNetworkSegment(NetworkSegmentCreationRequest) returns (NetworkSegment);
  rpc UpdateNetworkSegment(NetworkSegmentUpdateRequest) returns (NetworkSegmentUpdateResult);
  rpc DeleteNetworkSegment(NetworkSegmentDeletionRequest) returns (NetworkSegmentDeletionResult);
  rpc NetworkSegmentsForVpc(VpcSearchQuery) returns (NetworkSegmentList);

  // IBSubnets
  rpc FindIBSubnets(IBSubnetQuery) returns (IBSubnetList);
  rpc CreateIBSubnet(IBSubnetCreationRequest) returns (IBSubnet);
  rpc DeleteIBSubnet(IBSubnetDeletionRequest) returns (IBSubnetDeletionResult);
  rpc IBSubnetsForVpc(VpcSearchQuery) returns (IBSubnetList);

  // Manage instances on machines
  // Allocates a Machine as Instance for tenant, with the given configuration
  rpc AllocateInstance(InstanceAllocationRequest) returns (Instance);
  // Releases an instance that has been allocated by a tenant
  rpc ReleaseInstance(InstanceReleaseRequest) returns (InstanceReleaseResult);
  // Updates the network interface configuration for an instance
  // The update will take effect asynchronously. Users should monitor `Instance.status.network_status.synced`
  // to determine whether all updates have been applied.
  // Note: This is commented because we will not immediately implement the method
  // rpc UpdateInstanceNetworkConfig(InstanceNetworkConfigUpdateRequest) returns (Instance);
  rpc FindInstances(InstanceSearchQuery) returns (InstanceList);
  rpc FindInstanceByMachineID(MachineId) returns (InstanceList);

  // INTERNAL: RPC method is used between Site Controller components,
  // and for testing
  rpc RecordObservedInstanceNetworkStatus(InstanceNetworkStatusObservation) returns (ObservedInstanceNetworkStatusRecordResult);
  // forge-dpu-agent -> carbide-api
  rpc GetManagedHostNetworkConfig(ManagedHostNetworkConfigRequest) returns (ManagedHostNetworkConfigResponse);
  rpc RecordManagedHostNetworkStatus(ManagedHostNetworkStatusObservation) returns (ManagedHostNetworkStatusRecordResult);

  rpc LookupRecord(DNSMessage.DNSQuestion) returns (DNSMessage.DNSResponse);
//  rpc LookupPTRRecord(DnsRequest) returns (DnsReply);

  // TODO(ajf): Harder to implement bi-directional streaming, commented out for now
  // rpc StreamConsole(stream ConsoleInput) returns (stream ConsoleOutput);
  // rpc StreamInstanceEvents(UUID) returns (stream InstanceEvent);

  /* Power Control */
  rpc InvokeInstancePower(InstancePowerRequest) returns (InstancePowerResult);

  rpc ForgeAgentControl(ForgeAgentControlRequest) returns (ForgeAgentControlResponse);
  // PRIVILEGED: Creates a new machine from nothing
  rpc DiscoverMachine(MachineDiscoveryInfo) returns (MachineDiscoveryResult);
  rpc DiscoveryCompleted(MachineDiscoveryCompletedRequest) returns (MachineDiscoveryCompletedResponse);
  rpc CleanupMachineCompleted(MachineCleanupInfo) returns (MachineCleanupResult);
  rpc DiscoverDhcp(DhcpDiscovery) returns (DhcpRecord);

  // PRIVILEGED: Get a single machine
  rpc GetMachine(MachineId) returns (Machine);

  // PRIVILEGED: Find a list of machines
  rpc FindMachines(MachineSearchQuery) returns (MachineList);
  rpc FindInterfaces(InterfaceSearchQuery) returns (InterfaceList);

  // PRIVILEGED: Define and manage new instance types
  rpc CreateInstanceType(InstanceType) returns (InstanceType);
  rpc UpdateInstanceType(InstanceType) returns (InstanceType);
  rpc DeleteInstanceType(InstanceTypeDeletion) returns (InstanceTypeDeletionResult);

  // Tags handling
  rpc CreateTag(TagCreate) returns (TagResult);
  rpc DeleteTag(TagDelete) returns (TagResult);
  rpc ListTags(TagVoid) returns (TagsListResult);

  rpc AssignTag(TagAssign) returns (TagResult);
  rpc RemoveTag(TagRemove) returns (TagResult);
  rpc SetTags(TagsList) returns (TagResult);

  // Auth Requests
  rpc ValidateUserSSHKey(SSHKeyValidationRequest) returns (SSHKeyValidationResponse);

  // IPMI handling
  rpc GetBMCMetaData(BMCMetaDataGetRequest) returns (BMCMetaDataGetResponse);
  rpc UpdateBMCMetaData(BMCMetaDataUpdateRequest) returns (BMCMetaDataUpdateResponse);

  // User Credential handling.
  rpc UpdateMachineCredentials(MachineCredentialsUpdateRequest) returns (MachineCredentialsUpdateResponse);

  // SecurityGroup
  // Create or update a security group in its entirety.
  rpc UpdateSecurityGroupPolicy(SecurityGroupPolicy) returns(SecurityGroupPolicy);
  // Delete a security group.
  rpc DeleteSecurityGroupPolicy(SecurityGroupPolicyDeletion) returns(google.protobuf.Empty);
  // Associate a security group with some entities.
  rpc BindSecurityGroup(SecurityGroupBind) returns(google.protobuf.Empty);
  // Disassociate a security group with some entities.
  rpc UnbindSecurityGroup(SecurityGroupBind) returns(google.protobuf.Empty);
  // List all or one security group policy.
  rpc ListSecurityGroupPolicies(SecurityGroupPolicyQuery) returns(SecurityGroupPolicyList);
  // List all or one security group binds.
  rpc ListSecurityGroupBinds(SecurityGroupBindQuery) returns(SecurityGroupBindList);

  rpc GetPxeInstructions(MachineId) returns (PxeInstructions);
  rpc Echo(EchoRequest) returns (EchoResponse);

  // Tenant, Tenant Team, & Tenant Public Key actions
  rpc CreateTenant(CreateTenantRequest) returns (CreateTenantResponse);
  rpc FindTenant(FindTenantRequest) returns (FindTenantResponse);
  rpc UpdateTenant(UpdateTenantRequest) returns (UpdateTenantResponse);

  rpc CreateTenantKeyset(CreateTenantKeysetRequest) returns (CreateTenantKeysetResponse);
  rpc FindTenantKeyset(FindTenantKeysetRequest) returns (FindTenantKeysetResponse);
  rpc UpdateTenantKeyset(UpdateTenantKeysetRequest) returns (UpdateTenantKeysetResponse);
  rpc DeleteTenantKeyset(DeleteTenantKeysetRequest) returns (DeleteTenantKeysetResponse);

  rpc ValidateTenantPublicKey(ValidateTenantPublicKeyRequest) returns (ValidateTenantPublicKeyResponse);

  // Admin CLI actions

  // Query Vault for the DPU's SSH admin password
  rpc GetDpuSSHCredential(CredentialRequest) returns (CredentialResponse);

  // List all machines network status (HBN), as reported by `forge-dpu-agent`
  rpc GetAllManagedHostNetworkStatus(ManagedHostNetworkStatusRequest) returns (ManagedHostNetworkStatusResponse);

  // Force deletes a Machine and the associated DPU from Forge databases,
  // with the intention of rediscovering the host later on.
  // The command will not stop a running tenant instance. Only a reboot that forces
  // the Forge PXE boot process again would stop the image and run the discovery
  // process again.
  //
  // Due to the not well defined state that hosts are in after calling this command,
  // it should not be used by Tenants or Site Providers to release instances. Those
  // should use customer-facing commands like `ReleaseInstance`.
  //
  // AdminForceDeleteMachine is a lower level admin tool for cases where there is no
  // appropriate customer-facing workflow available or where those workflows fail.
  rpc AdminForceDeleteMachine(AdminForceDeleteMachineRequest) returns (AdminForceDeleteMachineResponse);

  // Reboot a machine and boot into PXE
  rpc AdminReboot(AdminRebootRequest) returns (AdminRebootResponse);

  // Create or edit a resource pool
  rpc AdminDefineResourcePool(DefineResourcePoolRequest) returns (DefineResourcePoolResponse);
}

message MachineId {
  string id = 1;
}

message EchoRequest {
  string message = 1;
}

message EchoResponse {
  string message = 1;
}
message DNSMessage {

  message DNSQuestion {
    optional string qName = 1;  // FQDN including trailing dot
    optional uint32 qType = 2;  //
    optional uint32 qClass = 3; // Usually 1 (IN)
  }
  message DNSResponse {
    message DNSRR {
      optional string rdata = 5;
    }
    optional uint32 rcode = 1;
    repeated DNSRR rrs = 2;
  }
  optional DNSQuestion question = 1;
  optional DNSResponse response = 2;
}

message DnsRequest {
  string query = 1;
}

message DnsReply {
  string reply = 1;
}

message DomainList {
  repeated Domain domains = 1;
}

message Domain {
  UUID id = 1;
  string name = 2;

  google.protobuf.Timestamp created = 3;
  google.protobuf.Timestamp updated = 4;
  google.protobuf.Timestamp deleted = 5;
}

message DomainDeletion {
  UUID id = 1;
}

message DomainDeletionResult {

}

message DomainSearchQuery {
  optional UUID id = 1;
  optional string name = 2;
}

message ConsoleInput {
  string input = 1;
}

message ConsoleOutput {
  string output = 1;
}

message InstanceEvent {
  string event = 1;
}


// Primitives
message UUID {
  string value = 1;
}

message VpcSearchQuery {
  optional UUID id = 1;
  optional string name = 2;
}

message Vpc {
  UUID id = 1;
  string name = 2;
  string tenantOrganizationId = 3;

  string version = 99;

  // Not sure if we actually still need those
  google.protobuf.Timestamp created = 4;
  google.protobuf.Timestamp updated = 5;
  google.protobuf.Timestamp deleted = 6;

  optional string tenantKeysetId = 7;
}

message VpcCreationRequest {
  string name = 2;
  string tenantOrganizationId = 3;
  // this keyset will enable any key contained within it to access any instance associated with this VPC.
  optional string tenantKeysetId = 4;
}

message VpcUpdateRequest {
  UUID id = 1;
  // If the field here is set, the update will only be applied if the version
  // is equivalent to the current version on the Forge Site.
  // If a concurrent update changed the site configuration, the API will return
  // a `ConcurrentModificationError`.
  optional string if_version_match = 2;

  // CR question: To avoid the duplication between VpcUpdateRequest and
  // VpcCreationRequest and Vpc - we could move all user configurable fields into
  // a `message VpcConfig/VpcSettings`. However I don't feel like this would add
  // a lot for primitive types like Vpc.

  string name = 3;
  string tenantOrganizationId = 4;
  optional string tenantKeysetId = 5;
}

message VpcUpdateResult {
  // TODO: Should we also return the current state as a field here?
  // Probably won't hurt
}

message VpcDeletionRequest {
  UUID id = 1;
}

message VpcDeletionResult {
}

message VpcList {
  repeated Vpc vpcs = 1;
}

// Enumerates possible instance states from the view of a tenant
// This is only a subset of total states that the instance might be in, and
// excludes states that are used while the instance is not being allocated to
// a tenant.
enum TenantState {
  // The instance is currently getting provisioned for a tenant
  PROVISIONING = 0;
  // The instance is ready and can be used by the tenant
  READY = 1;
  // The instance has been ready, but the newest configuration that the tenant
  // desired has not been applied yet
  CONFIGURING = 2;
  // The instance is shutting down. Shutdown has not completed yet
  TERMINATING = 3;
  // The instance has fully shut down, and is no longer available for the user
  TERMINATED = 4;
  // The instance is in a terminal failed state. This state is equivalent to
  // DEACTIVATED - no user software is running anymore during the state. However
  // an instance might enter a FAILED state before even fully activating, in case
  // activation failed.
  FAILED = 5;
}

// Describe the desired configuration of an IBSubnet
message IBSubnetConfig {
  // The name of IBSubnet.
  string name = 1;
  // The ID of VPC that IBSubnet belong to
  UUID vpc_id = 2;
}

// Describe the status and applied configuration of an IBSubnet
message IBSubnetStatus {
  // Provisioning state of this subnet
  TenantState state = 1;

  // The pkey of IB Subnet
  optional string pkey = 2;
  // The partition name of IB Subnet
  optional string partition = 3;
  // can be range from 0-15
  optional int32 service_level = 4;
  // can be one of the following: 2.5, 10, 30, 5, 20, 40, 60, 80, 120, 14, 56, 112, 168, 25, 100, 200, or 300
  optional int32 rate_limit = 5;
  // For IB subnets, value can be 2k or 4k only
  optional int32 mtu = 6;
  // If true, SHARP applications ware created accordingly
  optional bool enable_sharp = 7;
}

// Describe an Infiniband based Subnet configuration and status
message IBSubnet {
  UUID id = 1;

  IBSubnetConfig config = 2;
  string config_version = 3;

  IBSubnetStatus status = 4;
}

message IBSubnetList {
  repeated IBSubnet ib_subnets = 1;
}

message IBSubnetCreationRequest {
  IBSubnetConfig config = 1;
}

message IBSubnetDeletionRequest {
  UUID id = 1;
}

message IBSubnetDeletionResult {
}

message IBSubnetSearchConfig {
  bool include_history = 1;
}

message IBSubnetQuery {
  UUID id = 1;
  optional IBSubnetSearchConfig search_config = 2;
}

message NetworkSegmentStateHistory {
  string state = 1;
  string version = 2;
  google.protobuf.Timestamp time = 3;
}

message NetworkSegment {
  UUID id = 1;
  UUID vpc_id = 2;

  string name = 3;

  optional UUID subdomain_id = 4;
  optional int32 mtu = 5;

  repeated NetworkPrefix prefixes = 6;

  string version = 99;
  TenantState state = 100;
  repeated NetworkSegmentStateHistory history = 101;


  // Not sure if we actually still need those
  google.protobuf.Timestamp created = 11;
  google.protobuf.Timestamp updated = 12;
  google.protobuf.Timestamp deleted = 13;
}

message NetworkSegmentCreationRequest {
  UUID vpc_id = 2;

  string name = 3;

  optional UUID subdomain_id = 4;
  optional int32 mtu = 5;

  repeated NetworkPrefix prefixes = 6;
}

// A request to update the configuration of a network segment
// The `NetworkSegment` will be updated and make use of all the configurations
// specified here. If clients want to retain some particular configurations,
// they should fetch the original state of the `NetworkSegment`, and apply the
// changes they want to make based on that.
// Fetching the original configuration will yield a `version` string to the client.
// The client can pass the version back to the server to allow the server to check
// if any concurrent modification changed the object in between the client examining
// it and the update being executed.
message NetworkSegmentUpdateRequest {
  UUID id = 1;
  // If the field here is set, the update will only be applied if the version
  // is equivalent to the current version on the Forge Site.
  // If a concurrent update changed the site configuration, the API will return
  // a `ConcurrentModificationError`.
  optional string if_version_match = 2;

  string name = 3;
  optional int32 mtu = 5;
}

message NetworkSegmentUpdateResult {
  // TODO: Should we also return the current state as a field here?
  // Probably won't hurt
}

message NetworkSegmentDeletionRequest {
  UUID id = 1;
}

message NetworkSegmentDeletionResult {
}

message NetworkSegmentSearchConfig {
  bool include_history = 1;
}

message NetworkSegmentQuery {
  UUID id = 1;
  optional NetworkSegmentSearchConfig search_config = 2;
}

message NetworkPrefix {
  UUID id = 1;
  string prefix = 2;
  optional string gateway = 3;
  int32 reserve_first = 4;
  VpcResourceState state = 5;
  repeated NetworkPrefixEvent events = 6;
  optional string circuit_id = 7;
}

message MachineState {
  string state = 1;
}

enum InstanceTypeCapabilities {
  DEFAULT = 0;
}

message InstancePowerRequest {
  MachineId machine_id = 1;
  enum Operation {
    POWER_RESET = 0;
  }
  Operation operation = 2;
  bool boot_with_custom_ipxe = 3;
}

message InstanceType {
  UUID id = 1;
  string short_name = 2;
  string description = 3;

  repeated InstanceTypeCapabilities capabilities = 4;

  bool active = 5;
  google.protobuf.Timestamp created = 6;
  google.protobuf.Timestamp updated = 7;
}

message InstanceTypeDeletion {
  UUID id = 1;
}

message InstancePowerResult {
}

message InstanceTypeDeletionResult {}

message InstanceSearchQuery {
  optional UUID id = 1;
}

message InstanceList {
  repeated Instance instances = 1;
}

message InstanceAllocationRequest {
  // The Machine on top of which we create an Instance
  // If we go towards "we already have instances model", this would become more of a
  // AssignInstanceToTenant request, and the ID would be the instance_id
  MachineId machine_id = 1;

  // Desired configuration for the allocated instance
  InstanceConfig config = 2;

  //DEPRECATED -- use tenantKeysetId in InstanceConfig.TenantConfig instead.
  repeated string ssh_keys = 11;
}

// Tenant related configuration that is set once the instance is allocated
// by a tenant
message TenantConfig {
  // Identifies the tenant that uses this instance
  string tenant_organization_id = 1;

  // TODO: If we want to make those user-changeable, it might also be worthwhile to
  // move them into a message `InstanceImageConfig` or something along that.
  // Alternative is to instruct users to simply provision new images if they need
  // a different image.
  // In the model where `Instance`s also exist before being allocated by the user
  // then this one has at least one state change - from being empty to being populated.
  // We could also move all of this into a `message InstanceTenantConfig` to be
  // able to get from empty to populated.
  optional string user_data = 11;
  string custom_ipxe = 12;

  //TODO: make an API that allows these to be updated.  For now, they're set only at instance allocation.
  repeated string tenantKeysetIds = 8; // this may be empty
}

// Desired configuration for an instance
message InstanceConfig {
  // Tenant related configuration.
  // This field can be absent if the instance has not yet been allocated by
  // a tenant. On assignment, the config changes once. Due to the one-time
  // change no version field is required.
  TenantConfig tenant = 1;

  // Configures instance networking configurations
  InstanceNetworkConfig network = 11;
}

// Desired network configuration for an instance
message InstanceNetworkConfig {
  // Configures how instance network interfaces are set up
  repeated InstanceInterfaceConfig interfaces = 1;

  // Configures how ib subnet interfaces are set up
  repeated InstanceIBInterfaceConfig ib_interfaces = 2;

  // The ID of security group that is attached to this instance.
  // The configurations in this group apply to all interfaces on the instance.
  // Note: This is commented because we will not supported setting these in the first
  // release of the new Instance API
  // optional UUID security_group_id = 4;
}

// New configuration for the instances network interfaces
// This completely overwrites the existing interfaces, so it would be up on the caller
// to make sure the new settings are consistent and old interfaces that should not be
// touched are listed here again.
// A change in any entry of `InstanceNetworkConfig::interface_configs` can be interpreted by
// Forge as deleting the old interface and replacing it with a new interface.
// Note: This is commented because we will not immediately implement the method
// message InstanceNetworkConfigUpdateRequest {
//   // The ID of the instance that should get an updated networking configuration
//   UUID instance_id = 1;

//   // If the field here is set, the update will only be applied if the version
//   // is equivalent to the current network config version on the Forge Site.
//   // If a concurrent update changed the site configuration, the API will return
//   // a `ConcurrentModificationError`.
//   optional string if_version_match = 2;

//   // The updated instance network configuration
//   InstanceNetworkConfig network_config = 3;
// }

// Current status of an instance
message InstanceStatus {
  // Status that is related to the tenant of the instance.
  // In case no tenant has been assigned to this instance, the field would be absent.
  optional InstanceTenantStatus tenant = 1;

  // Note: There will be a separate state for the states
  // that are only important for the site admin and forge team.
  // That state is at the moment defined on `message Machine`, but might
  // be carried over. It's outside of the scope of this change.

  // Status of the networking subsystem of an instance
  InstanceNetworkStatus network = 11;

  // Whether all configurations related to an instance are in-sync.
  // This is a logical AND for the settings of all sub-configurations.
  // At this time it equals `InstanceNetworkStatus::configs_synced`,
  // but might in the future also include readiness for other subsystems.
  SyncState configs_synced = 101;
}

// State of the networking subsystem of an instance
message InstanceNetworkStatus {
  // Status for each configured interface
  //
  // Each entry in this status array maps to it's corresponding entry in the
  // Config section. E.g. `instance.status.network.interface_status[1]`
  // would map to `instance.config.network.interface_configs[1]`.
  repeated InstanceInterfaceStatus interfaces = 1;

  // Each entry in this status array maps to it's corresponding entry in the
  // Config section. E.g. `instance.status.network.ib_interface_status[1]`
  // would map to `instance.config.network.ib_interface_configs[1]`.
  repeated InstanceIBInterfaceStatus ib_interfaces = 2;

  // Whether all desired network changes that the user has applied have taken effect
  // This includes:
  // - Whether `InstanceNetworkConfig` is of exactly the same version as the
  //   version the user desires.
  // - Whether the version of each security policy that is either directly referenced
  //   as part of an `InstanceInterfaceConfig` or indirectly referenced via the
  //   the security policies that are applied to the VPC or NetworkSegment
  //   is exactly the same version as the version the user desires.
  //
  // Note for the implementation: We need to monitor all these config versions
  // on the feedback path from DPU to carbide in order to know whether the
  // changes have indeed taken effect.
  // TODO: Do we also want to show all applied versions here, or just track them
  // internally? Probably not help for for tenants at all - but it could be helpful
  // for the Forge operating team to debug settings that to do do not go in-sync
  // without having to attach to the database.
  SyncState configs_synced = 101;
}

// Contains all information about an actively running instance
// This entails both the instance configuration, as well as the current state of the instance
message Instance {
  // Instance ID
  UUID id = 1;
  // The ID of the machine which is utilized for this Instance
  MachineId machine_id = 2;

  // The desired configuration on the instance
  InstanceConfig config = 103;

  // The most recent status of the instance that has been observed
  InstanceStatus status = 104;

  // Current version of the networking configuration that is applied on the instance
  // This field can be used in InstanceNetworkConfigUpdateRequest::if_version_match
  // to only request updates if the version hasn't been updated in between.
  string network_config_version = 201;
}

// The configuration that a customer desires for an instances network interface
message InstanceInterfaceConfig {
  // Whether the user wants to create a physical or virtual function
  InterfaceFunctionType function_type = 1;

  // Network segment ID can change. It if changes - we require a new IP address
  UUID network_segment_id = 3;

  // The ID of security group that is attached to this interface
  // Note: This is commented because we will not supported setting these in the first
  // release of the new Instance API
  // optional UUID security_group_id = 4;
}

// The configuration that a customer desires for an instances IB interface
message InstanceIBInterfaceConfig {
  // IB subnet ID can change.
  repeated UUID ib_subnet_id = 1;

  // The guid of IB interface
  string guid = 2;
}

// The actual status of a single network interface of an instance
message InstanceInterfaceStatus {
  // If the interface is defined as a virtual function (associated
  // `InstanceInterfaceConfig.function_type == InterfaceFunctionType::VIRTUAL_FUNCTION`,
  // then this value is set and specifies the virtual function ID that is configured
  // for this network interface.
  optional uint32 virtual_function_id = 1;

  // The MAC address which has been assigned to this interface
  // The list will be empty if interface configuration hasn't been completed
  // and therefore the address is unknown.
  optional string mac_address = 2;

  // The list of IP addresses that had been assigned to this interface,
  // based on the requested subnet.
  // The list will be empty if interface configuration hasn't been completed
  repeated string addresses = 3;
}

// The actual status of a single IB interface of an instance
message InstanceIBInterfaceStatus {
  // The GUID which has been assigned to this interface
  optional string guid = 1;

  // The local id of this IB interface; if interface configuration has not been completed, the value is 0.
  uint32 lid = 2;

  // The list of IP addresses that had been assigned to this interface,
  // based on the requested subnet.
  // The list will be empty if interface configuration hasn't been completed or IPoIB disabled
  repeated string addresses = 3;
}

message InstanceReleaseRequest {
  UUID id = 1;
}

message InstanceReleaseResult {
}

message MachineSearchConfig {
  bool include_dpus = 1;
  bool include_history = 2;
}

message MachineSearchQuery {
  optional MachineId id = 1;
  optional string fqdn = 2;
  optional MachineSearchConfig search_config = 3;
}

message InterfaceList {
  repeated MachineInterface interfaces = 1;
}

message MachineList {
  repeated Machine machines = 1;
}

message InterfaceSearchQuery {
  optional UUID id = 1;
}

enum MachineType {
  UNKNOWN = 0;
  DPU = 1;
  HOST = 2;
}

message BmcInfo {
  optional string ip = 1;
  optional string mac = 2;
}

message Machine {
  MachineId id = 1;

  google.protobuf.Timestamp created = 4;
  google.protobuf.Timestamp updated = 5;
  google.protobuf.Timestamp deployed = 6;

  // Note: These might change if ore lifecycle mention flows into `Instance`
  string state = 7;
  repeated MachineEvent events = 8;
  // Note: This is not yet removed in this change to limit the amount of breaking
  // changes at once - but users shouldn't rely on it. The actually interesting
  // information around interfaces for Instance users is in `Instance::InstanceNetworkStatus`.
  repeated MachineInterface interfaces = 9;

  // TODO: This field might actually move Instance since the discovered hardware
  // could be different per lifecycle. When the machine is updated with different
  // hardware and restarted, the data can change. The Instance would have the
  // capability to store the actual discovery information for each lifecycle
  optional machine_discovery.DiscoveryInfo discovery_info = 10;

  // Machine type if it is a DPU or HOST.
  MachineType machine_type = 11;

  BmcInfo bmc_info = 12;
}

// The most recent tenant related status
message InstanceTenantStatus {
  // The current state of the instance from the point of view of the assigned tenant
  TenantState state = 1;
  // An optional message which can contain details about the state
  string state_details = 2;
}

enum SyncState {
  // All configuration changes that users requested have been applied
  SYNCED = 0;
  // At least one configuration change to an active instance has not yet been processed
  PENDING = 1;
}

enum MachineArchitecture {
  ARM = 0;
  X86 = 1;
}

message MachineEvent {
  int64 id = 1;
  MachineId machine_id = 2;

  string event = 3;

  google.protobuf.Timestamp time = 4;
}

message MachineInterface {
  UUID id = 1;
  optional MachineId attached_dpu_machine_id = 2;
  MachineId machine_id = 3;
  UUID segment_id = 4;

  string hostname = 5;

  UUID domain_id = 6;

  bool primary_interface = 7;
  string mac_address = 8;

  repeated string address = 9;
}

message DhcpDiscovery {
  string mac_address = 1;
  string relay_address = 2;
  optional string vendor_string = 3;
  optional string link_address = 4;
  optional string circuit_id = 5;
}

message DhcpRecord {
  MachineId machine_id = 1;
  UUID machine_interface_id = 2;
  UUID segment_id = 3;
  UUID subdomain_id = 4;

  string fqdn = 5;
  string mac_address = 6;
  string address = 7;

  int32 mtu = 8;

  string prefix = 9;
  optional string gateway = 10;
}

message NetworkSegmentList {
  repeated NetworkSegment network_segments = 1;
}

message Tag {
  string slug = 1;
  optional string name = 3;  // Mandatory in case of CREATE action.
}

message TagCreate {
  Tag tag = 1;
}

message TagDelete {
  Tag tag = 1;
}

message TagResult {
  bool result = 1;
}

message TagVoid {
}

message TagsList {
  repeated string slugs = 1;
  UUID target = 2;
  TagTargetKind target_kind = 3;
}

message TagsListResult {
  repeated Tag tags = 1;
}

enum TagTargetKind {
  MACHINE = 0;
  NETWORK_SEGMENT = 1;
}

message TagAssign {
  string slug = 1;
  UUID target = 2;
  TagTargetKind target_kind = 3;
}

message TagRemove {
  string slug = 1;
  UUID target = 2;
  TagTargetKind target_kind = 3;
}

message SSHKeyValidationRequest {
    string user = 1;
    string pubkey = 2;
}

enum UserRoles {
  USER = 0;
  ADMINISTRATOR = 1;
  OPERATOR = 2;
  NOACCESS = 3;
}

message SSHKeyValidationResponse {
    bool is_authenticated = 1;
    UserRoles role = 2;
}

message CredentialRequest {
    string host_id = 1;  // UUID, IP address, host name or MAC address
}

message CredentialResponse {
    string username = 1;
    string password = 2;
}

message ManagedHostNetworkConfigRequest {
  MachineId machine_id = 1;
}

message ManagedHostNetworkConfigResponse {
  ManagedHostNetworkConfig managed_host_config = 1;
  string managed_host_config_version = 2;
  // TODO: Should be augmented by the active InstanceConfig
  // Either here, or as field inside `ManagedHostNetworkConfig`
}

message ManagedHostNetworkStatusRequest {}
message ManagedHostNetworkStatusResponse {
    repeated ManagedHostNetworkStatusObservation all = 1;
}

message AdminForceDeleteMachineRequest {
    // UUID, IP address, host name or MAC address of either the host or DPU to force delete
    string host_query = 1;
}

// Response to AdminForceDeleteMachine call
// Describes which resources have been released
message AdminForceDeleteMachineResponse {
    bool all_done = 1;

    string managed_host_machine_id = 11;
    string managed_host_machine_interface_id = 12;
    string dpu_machine_id = 13;
    string dpu_machine_interface_id = 14;
    string instance_id = 15;

    string managed_host_bmc_ip = 21;
    string dpu_bmc_ip = 22;

    uint32 deleted_managed_resources = 31;
    uint32 deleted_leafs = 32;

    // The Machines lockdown state before it was attempted to unlock the Machine
    string initial_lockdown_state = 41;
    // Whether the Machine had been unlocked as part of this action
    bool machine_unlocked = 42;
}

// Must provide either machine_id or user/password pair
message AdminRebootRequest {
    string ip = 1;
    optional uint32 port = 2;
    optional string user = 3;
    optional string password = 4;
    optional string machine_id = 5;
}

message AdminRebootResponse {}

enum BMCRequestType {
    IPMI = 0;
    REDFISH = 1;
}

message BMCMetaDataGetRequest {
    MachineId machine_id = 1;
    UserRoles role = 2;
    BMCRequestType request_type = 3;
}

message BMCMetaDataGetResponse {
    string ip = 1;
    string user = 2;
    string password = 3;
    string mac = 4;
}

message BMCMetaDataUpdateRequest {
    message DataItem {
        string user = 2;
        UserRoles role = 3;
        string password = 4;
    }

    MachineId machine_id = 1;
    string ip = 2;
    repeated DataItem data = 3;
    BMCRequestType request_type = 4;
    string mac = 5;
}

message BMCMetaDataUpdateResponse {}

message MachineCredentialsUpdateRequest {
   enum CredentialPurpose {
      HBN = 0;
      LOGIN_USER = 1;
   }
    message Credentials {
        string user = 1;
        string password = 2;
        CredentialPurpose credential_purpose = 3;
    }

    MachineId machine_id = 4;
    repeated Credentials credentials = 5;
}

message MachineCredentialsUpdateResponse {}

message ForgeAgentControlRequest {
    MachineId machine_id = 1;
}

message ForgeAgentControlResponse {
	enum Action {
		NOOP = 0;       // No operation. Do nothing
		RESET = 1;      // Wipe the machine, prepare for next tenant
		DISCOVERY = 2;  // Run full discovery
		REBUILD = 3;    // Future thingy
		RETRY = 4;      // Machine needs more time to come in proper state. Retry again.
	}
	Action action = 1;
}

message MachineDiscoveryInfo {
  UUID machine_interface_id = 1;
  oneof discovery_data {
    machine_discovery.DiscoveryInfo info = 2;
  }
}

message MachineDiscoveryCompletedRequest {
	MachineId machine_id = 1;
}

message MachineCleanupInfo {
	enum CleanupResult {
		OK = 0;
		ERROR = 1;
	}
	message CleanupStepResult {
		CleanupResult result = 1;
		// If the result was an error, this can contain the associate error message
		string message = 2;
	}

	MachineId machine_id = 1;

	// NVMe Cleanup Result
	CleanupStepResult nvme = 2;
	// RAM cleanup result
	CleanupStepResult ram = 3;
	// EFI variable MemoryOverwriteRequestControl-e20939be-32d4-41be-a150-897f85d49829 must be set to 1
	CleanupStepResult mem_overwrite = 4;

	CleanupResult result = 11;
}

message MachineDiscoveryResult {
  // This is returned to the discovery client from the API. Lets try not to put much in here unless we need it.
  MachineId machine_id = 1;
}

message MachineDiscoveryCompletedResponse { }

message MachineCleanupResult {
  // This is returned to the discovery client from the API. Lets try not to put much in here unless we need it.
}

message VpcResourceState {
    string state = 1;
}

message NetworkPrefixEvent {
  int64 id = 1;

  UUID network_prefix_id = 2;

  VpcResourceAction event = 3;

  google.protobuf.Timestamp time = 4;
}

message VpcResourceLeafEvent {
  int64 id = 1;

  UUID vpc_leaf_id = 2;

  VpcResourceAction event = 3;

  google.protobuf.Timestamp time = 4;
}

enum VpcResourceAction {
  VPC_INITIALIZE = 0;
  VPC_SUBMIT = 1;
  VPC_ACCEPT = 2;
  VPC_WAIT = 3;
  VPC_FAIL = 4;
  VPC_SUCCESS = 5;
  VPC_RECOMMISSION = 6;
}

message PxeInstructions {
    string pxe_script = 1;
}

// Specifies whether a network interface is physical network function (PF)
// or a virtual network function
enum InterfaceFunctionType {
  PHYSICAL_FUNCTION = 0;
  VIRTUAL_FUNCTION = 1;
}

// Network configuration for a managed host (host + DPU pair) managed by Forge
message ManagedHostNetworkConfig {
  // Enables access to the Forge admin network for the x86 host
  bool admin_network_enabled = 1;
  // TODO: Do we need the mapping from interface to IP as in the current Leaf spec
  // or multiple IPs for IPv4 vs IPv6?
  string host_admin_ip = 2;
  // DHCP server that the Host DHCP requests should be relayed to
  repeated string dhcp_servers = 3;

  // TODOs:
  // 1. Do we want to keep the ability of maintainence_mode?
  // 2. Do we need any other information out of what is currently defined in
  //    the admin NetworkSegment?
}

// What forge-dpu-agent reports. Will grow over time.
message ManagedHostNetworkStatusObservation {
  MachineId dpu_machine_id = 1;
  optional google.protobuf.Timestamp observed_at = 2;
  optional NetworkHealth health = 3;
}

message ManagedHostNetworkStatusRecordResult {}

// Observed status of the networking subsystem of an instance
message InstanceNetworkStatusObservation {
  // The ID of the instance for which this status was observed
  UUID instance_id = 1;

  // The version of the config that is applied on the networking subsystem
  // Only if the version is equivalent to the latest desired version we
  // can actually interpret the results. If the version is outdated, then the
  // list of interfaces might actually relate to a different interfaces than
  // the ones that are currently required by the networking config.
  string config_version = 2;

  // When this status was observed
  //
  // If the field isn't populated, the server will assume that status is up to
  // date. Clients can set the timestamp to indicate that they provide a status
  // to the server that is based on an older observation (e.g. a cache). This
  // can help the server to decide whether the data that is acted upon might be
  // outdated, and might not indicate that networking is still configured correctly.
  optional google.protobuf.Timestamp observed_at = 3;

  // Status for each configured interface
  repeated InstanceInterfaceStatusObservation interfaces = 4;

  // Status for each configured IB interface
  repeated InstanceIBInterfaceStatusObservation ib_interfaces = 5;
}

// Result for the RecordObservedInstanceNetworkStatus method
message ObservedInstanceNetworkStatusRecordResult {
}

// Observed status of a single network interface of an instance
message InstanceInterfaceStatusObservation {
  // Whether the interface is a physical or virtual function
  // In the case of a virtual function the associated
  // `virtual_function_id` describes the ID of the interface
  InterfaceFunctionType function_type = 1;

  // If the interface is defined as a virtual function (associated
  // `function_type == InterfaceFunctionType::VIRTUAL_FUNCTION`,
  // then this value is set and specifies the virtual function ID that is configured
  // for this network interface.
  optional uint32 virtual_function_id = 2;

  // The MAC address which has been assigned to this interface
  // The list will be empty if interface configuration hasn't been completed
  // and therefore the address is unknown.
  optional string mac_address = 3;

  // The list of IP addresses that had been assigned to this interface,
  // based on the requested subnet.
  // The list will be empty if interface configuration hasn't been completed
  repeated string addresses = 4;
}

// Observed status of a single network interface of an instance
message InstanceIBInterfaceStatusObservation {
  // The GUID which has been assigned to this interface
  // Only relevant for IB interfaces
  optional string guid = 1;

  // The local id of this IB interface; if interface configuration has not been completed, the value is 0.
  uint32 lid = 2;

  // The list of IP addresses that had been assigned to this interface,
  // based on the requested subnet.
  // The list will be empty if interface configuration hasn't been completed or IPoIB disabled
  repeated string addresses = 3;
}

message TenantContent {
}

message Tenant {
  string organizationId = 1;
  TenantContent tenantContent = 2;
  // this string is used to verify that the client has the most updated "view" of a keyset when attempting to modify it
  string version = 3;
}

message CreateTenantRequest {
  // this organization ID must be globally unique
  string organizationId = 1;
}
message CreateTenantResponse {
  Tenant tenant = 1;
}

message UpdateTenantRequest {
  string organizationId = 1;
  TenantContent tenantContent = 2;

  // if this field is set and non-empty, the request will only update the tenant if the version matches the server's view,
  // otherwise it will return a concurrency related error.
  optional string if_version_match = 3;
}
message UpdateTenantResponse {
  // the updated tenant after modification
  Tenant tenant = 1;
}

message FindTenantRequest {
  string tenantOrganizationId = 1;
}
message FindTenantResponse {
  Tenant tenant = 1;
}

message TenantKeysetIdentifier {
  // the organizationId of the associated tenant, required to be non-null and globally unique
  string organizationId = 1;
  // the id of the key, provided by the tenant.  Must be unique within the tenant's organization.
  // TODO: update this document once we have a clearer idea of the charset restrictions for this provided identifier.
  string keysetId = 2;
}

message TenantPublicKey {
  string publicKey = 1;
  optional string comment = 2;
}

message TenantKeysetContent {
  repeated TenantPublicKey publicKeys = 1;
}

message TenantKeyset {
  TenantKeysetIdentifier keysetIdentifier = 1;
  TenantKeysetContent keysetContent = 2;
  // this version will be used to determine if a client has the most updated "view" of a tenant when attempting to modify it
  string version = 3;
}

message CreateTenantKeysetRequest {
  TenantKeysetIdentifier keysetIdentifier = 1;
  // it is allowed for the provided request to contain no keys, which will reserve the identifier as an empty set.
  TenantKeysetContent keysetContent = 2;
}
message CreateTenantKeysetResponse {
  TenantKeyset keyset = 1;
}

message FindTenantKeysetRequest {
  TenantKeysetIdentifier keysetIdentifier = 1;
}
message FindTenantKeysetResponse {
  TenantKeyset keyset = 1;
}

message UpdateTenantKeysetRequest {
  // this request will update the existing keyset provided the identifiers match
  TenantKeysetIdentifier keysetIdentifier = 1;
  TenantKeysetContent keysetContent = 2;

  // if this field is set and non-empty, the request will only update the tenant if the version matches the server's view,
  // otherwise it will return a concurrency related error.
  optional string if_version_match = 3;
}
message UpdateTenantKeysetResponse {
  // will respond with the final keyset after it has been modified in accordance with the request
  TenantKeyset keyset = 1;
}

message DeleteTenantKeysetRequest {
  TenantKeysetIdentifier keysetIdentifier = 1;
}
message DeleteTenantKeysetResponse {}

// the tenantPublicKey will be checked against the following lists for permission to access the instance:
// 1) the instance's keysets.
// 2) the vpc's keyset.
// 3) the tenant's keyset.
// if the key is present in one of those lists, the request will be granted permission to access the instance.
message ValidateTenantPublicKeyRequest {
  string instanceId = 1;
  string tenantPublicKey = 2;
}
// the status of the response will be in the grpc Status object, along with any associated Errors.
message ValidateTenantPublicKeyResponse {}

// Health of HBN on a DPU. Sent by forge-dpu-agent.
message NetworkHealth {
    bool is_healthy = 1;
    repeated string passed = 2;
    repeated string failed = 3;
    optional string message = 4;
}

message DefineResourcePoolRequest {
    string name = 1;
    ResourcePoolType pool_type = 2;
    repeated Range ranges = 3;
}

message DefineResourcePoolResponse {}

message Range {
    string start = 1;
    string end = 2;
}

enum ResourcePoolType {
    Integer = 0;
    Ipv4 = 1;
}
