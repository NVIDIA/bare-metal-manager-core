syntax = "proto3";

import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";
import "machine_discovery.proto";
import "security_group.proto";

package forge;

service Forge {
  // Domain
  rpc CreateDomain(Domain) returns (Domain);
  rpc UpdateDomain(Domain) returns (Domain);
  rpc DeleteDomain(DomainDeletion) returns (DomainDeletionResult);
  rpc FindDomain(DomainSearchQuery) returns (DomainList);
  // VPC
  rpc CreateVpc(VpcCreationRequest) returns (Vpc);
  rpc UpdateVpc(VpcUpdateRequest) returns (VpcUpdateResult);
  rpc DeleteVpc(VpcDeletionRequest) returns (VpcDeletionResult);
  rpc FindVpcs(VpcSearchQuery) returns (VpcList);

  // Segments - i.e. Overlay Networks
  rpc FindNetworkSegments(NetworkSegmentQuery) returns (NetworkSegmentList);
  rpc CreateNetworkSegment(NetworkSegmentCreationRequest) returns (NetworkSegment);
  rpc UpdateNetworkSegment(NetworkSegmentUpdateRequest) returns (NetworkSegmentUpdateResult);
  rpc DeleteNetworkSegment(NetworkSegmentDeletionRequest) returns (NetworkSegmentDeletionResult);
  rpc NetworkSegmentsForVpc(VpcSearchQuery) returns (NetworkSegmentList);

  // Manage instances on machines
  // Allocates a Machine as Instance for tenant, with the given configuration
  rpc AllocateInstance(InstanceAllocationRequest) returns (Instance);
  // Releases an instance that has been allocated by a tenant
  rpc ReleaseInstance(InstanceReleaseRequest) returns (InstanceReleaseResult);
  // Updates the network interface configuration for an instance
  // The update will take effect asynchronously. Users should monitor `Instance.status.network_status.synced`
  // to determine whether all updates have been applied.
  // Note: This is commented because we will not immediately implement the method
  // rpc UpdateInstanceNetworkConfig(InstanceNetworkConfigUpdateRequest) returns (Instance);
  rpc FindInstances(InstanceSearchQuery) returns (InstanceList);
  rpc FindInstanceByMachineID(UUID) returns (InstanceList);

  // INTERNAL: RPC method is used between Site Controller components,
  // and for testing
  rpc RecordObservedInstanceNetworkStatus(InstanceNetworkStatusObservation) returns (ObservedInstanceNetworkStatusRecordResult);

  rpc LookupRecord(DNSMessage.DNSQuestion) returns (DNSMessage.DNSResponse);
//  rpc LookupPTRRecord(DnsRequest) returns (DnsReply);

  // TODO(ajf): Harder to implement bi-directional streaming, commented out for now
  // rpc StreamConsole(stream ConsoleInput) returns (stream ConsoleOutput);
  // rpc StreamInstanceEvents(UUID) returns (stream InstanceEvent);

  /* Power Control */
  rpc InvokeInstancePower(InstancePowerRequest) returns (InstancePowerResult);

  rpc ForgeAgentControl(ForgeAgentControlRequest) returns (ForgeAgentControlResponse);
  // PRIVILEGED: Creates a new machine from nothing
  rpc DiscoverMachine(MachineDiscoveryInfo) returns (MachineDiscoveryResult);
  rpc DiscoveryCompleted(MachineDiscoveryCompletedRequest) returns (MachineDiscoveryCompletedResponse);
  rpc CleanupMachineCompleted(MachineCleanupInfo) returns (MachineCleanupResult);
  rpc DiscoverDhcp(DhcpDiscovery) returns (DhcpRecord);

  // PRIVILEGED: Get a single machine
  rpc GetMachine(UUID) returns (Machine);

  // PRIVILEGED: Find a list of machines
  rpc FindMachines(MachineSearchQuery) returns (MachineList);
  rpc FindInterfaces(InterfaceSearchQuery) returns (InterfaceList);

  // PRIVILEGED: Define and manage new instance types
  rpc CreateInstanceType(InstanceType) returns (InstanceType);
  rpc UpdateInstanceType(InstanceType) returns (InstanceType);
  rpc DeleteInstanceType(InstanceTypeDeletion) returns (InstanceTypeDeletionResult);

  // Tags handling
  rpc CreateTag(TagCreate) returns (TagResult);
  rpc DeleteTag(TagDelete) returns (TagResult);
  rpc ListTags(TagVoid) returns (TagsListResult);

  rpc AssignTag(TagAssign) returns (TagResult);
  rpc RemoveTag(TagRemove) returns (TagResult);
  rpc SetTags(TagsList) returns (TagResult);

  // Auth Requests
  rpc ValidateUserSSHKey(SSHKeyValidationRequest) returns (SSHKeyValidationResponse);

  // PRIVILEGED: Query Vault for the DPU's SSH admin password
  rpc GetDpuSSHCredential(CredentialRequest) returns (CredentialResponse);

  // IPMI handling
  rpc GetBMCMetaData(BMCMetaDataGetRequest) returns (BMCMetaDataGetResponse);
  rpc UpdateBMCMetaData(BMCMetaDataUpdateRequest) returns (BMCMetaDataUpdateResponse);

  // User Credential handling.
  rpc UpdateMachineCredentials(MachineCredentialsUpdateRequest) returns (MachineCredentialsUpdateResponse);

  // SecurityGroup
  // Create or update a security group in its entirety.
  rpc UpdateSecurityGroupPolicy(SecurityGroupPolicy) returns(SecurityGroupPolicy);
  // Delete a security group.
  rpc DeleteSecurityGroupPolicy(SecurityGroupPolicyDeletion) returns(google.protobuf.Empty);
  // Associate a security group with some entities.
  rpc BindSecurityGroup(SecurityGroupBind) returns(google.protobuf.Empty);
  // Disassociate a security group with some entities.
  rpc UnbindSecurityGroup(SecurityGroupBind) returns(google.protobuf.Empty);
  // List all or one security group policy.
  rpc ListSecurityGroupPolicies(SecurityGroupPolicyQuery) returns(SecurityGroupPolicyList);
  // List all or one security group binds.
  rpc ListSecurityGroupBinds(SecurityGroupBindQuery) returns(SecurityGroupBindList);

  rpc GetPxeInstructions(UUID) returns (PxeInstructions);
  rpc Echo(EchoRequest) returns (EchoResponse);
}

message EchoRequest {
  string message = 1;
}

message EchoResponse {
  string message = 1;
}
message DNSMessage {

  message DNSQuestion {
    optional string qName = 1;  // FQDN including trailing dot
    optional uint32 qType = 2;  //
    optional uint32 qClass = 3; // Usually 1 (IN)
  }
  message DNSResponse {
    message DNSRR {
      optional string rdata = 5;
    }
    optional uint32 rcode = 1;
    repeated DNSRR rrs = 2;
  }
  optional DNSQuestion question = 1;
  optional DNSResponse response = 2;
}

message DnsRequest {
  string query = 1;
}

message DnsReply {
  string reply = 1;
}

message DomainList {
  repeated Domain domains = 1;
}

message Domain {
  UUID id = 1;
  string name = 2;

  google.protobuf.Timestamp created = 3;
  google.protobuf.Timestamp updated = 4;
  google.protobuf.Timestamp deleted = 5;
}

message DomainDeletion {
  UUID id = 1;
}

message DomainDeletionResult {

}

message DomainSearchQuery {
  optional UUID id = 1;
  optional string name = 2;
}

message ConsoleInput {
  string input = 1;
}

message ConsoleOutput {
  string output = 1;
}

message InstanceEvent {
  string event = 1;
}


// Primitives
message UUID {
  string value = 1;
}

message VpcSearchQuery {
  optional UUID id = 1;
  optional string name = 2;
}

message Vpc {
  UUID id = 1;
  string name = 2;
  string organization = 3;

  string version = 99;

  // Not sure if we actually still need those
  google.protobuf.Timestamp created = 4;
  google.protobuf.Timestamp updated = 5;
  google.protobuf.Timestamp deleted = 6;
}

message VpcCreationRequest {
  string name = 2;
  string organization = 3;
}

message VpcUpdateRequest {
  UUID id = 1;
  // If the field here is set, the update will only be applied if the version
  // is equivalent to the current version on the Forge Site.
  // If a concurrent update changed the site configuration, the API will return
  // a `ConcurrentModificationError`.
  optional string if_version_match = 2;

  // CR question: To avoid the duplication between VpcUpdateRequest and
  // VpcCreationRequest and Vpc - we could move all user configurable fields into
  // a `message VpcConfig/VpcSettings`. Hwoever I don't feel like this would add
  // a lot for primitive types like Vpc.

  string name = 3;
  string organization = 4;
}

message VpcUpdateResult {
  // TODO: Should we also return the current state as a field here?
  // Probably won't hurt
}

message VpcDeletionRequest {
  UUID id = 1;
}

message VpcDeletionResult {
}

message VpcList {
  repeated Vpc vpcs = 1;
}

// Enumerates possible instance states from the view of a tenant
// This is only a subset of total states that the instance might be in, and
// excludes states that are used while the instance is not being allocated to
// a tenant.
enum TenantState {
  // The instance is currently getting provisioned for a tenant
  PROVISIONING = 0;
  // The instance is ready and can be used by the tenant
  READY = 1;
  // The instance has been ready, but the newest configuration that the tenant
  // desired has not been applied yet
  CONFIGURING = 2;
  // The instance is shutting down. Shutdown has not completed yet
  TERMINATING = 3;
  // The instance has fully shut down, and is no longer available for the user
  TERMINATED = 4;
  // The instance is in a terminal failed state. This state is equivalent to
  // DEACTIVATED - no user software is running anymore during the state. However
  // an instance might enter a FAILED state before even fully activating, in case
  // activation failed.
  FAILED = 5;
}

message NetworkSegment {
  UUID id = 1;
  UUID vpc_id = 2;

  string name = 3;

  optional UUID subdomain_id = 4;
  optional int32 mtu = 5;

  repeated NetworkPrefix prefixes = 6;

  string version = 99;
  TenantState state = 100;

  // Not sure if we actually still need those
  google.protobuf.Timestamp created = 11;
  google.protobuf.Timestamp updated = 12;
  google.protobuf.Timestamp deleted = 13;
}

message NetworkSegmentCreationRequest {
  UUID vpc_id = 2;

  string name = 3;

  optional UUID subdomain_id = 4;
  optional int32 mtu = 5;

  repeated NetworkPrefix prefixes = 6;
}

// A request to update the configuration of a network segment
// The `NetworkSegment` will be updated and make use of all the configurations
// specified here. If clients want to retain some particular configurations,
// they should fetch the original state of the `NetworkSegment`, and apply the
// changes they want to make based on that.
// Fetching the original configuration will yield a `version` string to the client.
// The client can pass the version back to the server to allow the server to check
// if any concurrent modification changed the object in between the client examining
// it and the update being executed.
message NetworkSegmentUpdateRequest {
  UUID id = 1;
  // If the field here is set, the update will only be applied if the version
  // is equivalent to the current version on the Forge Site.
  // If a concurrent update changed the site configuration, the API will return
  // a `ConcurrentModificationError`.
  optional string if_version_match = 2;

  string name = 3;
  optional int32 mtu = 5;
}

message NetworkSegmentUpdateResult {
  // TODO: Should we also return the current state as a field here?
  // Probably won't hurt
}

message NetworkSegmentDeletionRequest {
  UUID id = 1;
}

message NetworkSegmentDeletionResult {
}

message NetworkSegmentQuery {
  UUID id = 1;
}

message NetworkPrefix {
  UUID id = 1;
  string prefix = 2;
  optional string gateway = 3;
  int32 reserve_first = 4;
  VpcResourceState state = 5;
  repeated NetworkPrefixEvent events = 6;
  optional string circuit_id = 7;
}

message MachineState {
  string state = 1;
}

enum InstanceTypeCapabilities {
  DEFAULT = 0;
}

message InstancePowerRequest {
  UUID machine_id = 1;
  enum Operation {
    POWER_RESET = 0;
  }
  Operation operation = 2;
  bool boot_with_custom_ipxe = 3;
}

message InstanceType {
  UUID id = 1;
  string short_name = 2;
  string description = 3;

  repeated InstanceTypeCapabilities capabilities = 4;

  bool active = 5;
  google.protobuf.Timestamp created = 6;
  google.protobuf.Timestamp updated = 7;
}

message InstanceTypeDeletion {
  UUID id = 1;
}

message InstancePowerResult {
}

message InstanceTypeDeletionResult {}

message InstanceSearchQuery {
  optional UUID id = 1;
}

message InstanceList {
  repeated Instance instances = 1;
}

message InstanceAllocationRequest {
  // The Machine on top of which we create an Instance
  // If we go towards "we already have instances model", this would become more of a
  // AssignInstanceToTenant request, and the ID would be the instance_id
  UUID machine_id = 1;

  // Desired configuration for the allocated instance
  InstanceConfig config = 2;

  // SSH keys are not part of `InstanceConfig` since they are secrets that are
  // set once at instance allocation. They should not be reported in `Instance`
  // which contains `InstanceConfig`.
  // TODO: We might need to add changeInstanceSshKeys method if users want to
  // update them at instance creation. But we can defer this until there is a
  // customer need.
  repeated string ssh_keys = 11;
}

// Tenant related configuration that is set once the instance is allocated
// by a tenant
message TenantConfig {
  // Identifies the tenant that uses this instance
  string tenant_org = 1;

  // TODO: If we want to make those user-changeable, it might also be worthwhile to
  // move them into a message `InstanceImageConfig` or something along that.
  // Alternative is to instruct users to simply provision new images if they need
  // a different image.
  // In the model where `Instance`s also exist before being allocated by the user
  // then this one has at least one state change - from being empty to being populated.
  // We could also move all of this into a `message InstanceTenantConfig` to be
  // able to get from empty to populated.
  optional string user_data = 11;
  string custom_ipxe = 12;
}

// Desired configuration for an instance
message InstanceConfig {
  // Tenant related configuation.
  // This field can be absent if the instance has not yet been allocated by
  // a tenant. On assignment, the config changes once. Due to the one-time
  // change no version field is required.
  TenantConfig tenant = 1;

  // Configures instance networking configurations
  InstanceNetworkConfig network = 11;
}

// Desired network configuration for an instance
message InstanceNetworkConfig {
  // Configures how instance network interfaces are set up
  repeated InstanceInterfaceConfig interfaces = 1;

  // The ID of security group that is attached to this instance.
  // The configurations in this group apply to all interfaces on the instance.
  // Note: This is commented because we will not supported setting these in the first
  // release of the new Instance API
  // optional UUID security_group_id = 4;
}

// New configuration for the instances network interfaces
// This completely overwrites the existing interfaces, so it would be up on the caller
// to make sure the new settings are consistent and old interfaces that should not be
// touched are listed here again.
// A change in any entry of `InstanceNetworkConfig::interface_configs` can be interpreted by
// Forge as deleting the old interface and replacing it with a new interface.
// Note: This is commented because we will not immediately implement the method
// message InstanceNetworkConfigUpdateRequest {
//   // The ID of the instance that should get an updated networking configuration
//   UUID instance_id = 1;

//   // If the field here is set, the update will only be applied if the version
//   // is equivalent to the current network config version on the Forge Site.
//   // If a concurrent update changed the site configuration, the API will return
//   // a `ConcurrentModificationError`.
//   optional string if_version_match = 2;

//   // The updated instance network configuration
//   InstanceNetworkConfig network_config = 3;
// }

// Current status of an instance
message InstanceStatus {
  // Status that is related to the tenant of the instance.
  // In case no tenant has been assigned to this instance, the field would be absent.
  optional InstanceTenantStatus tenant = 1;

  // Note: There will be a separate state for the states
  // that are only important for the site admin and forge team.
  // That state is at the moment defined on `message Machine`, but might
  // be carried over. It's outside of the scope of this change.

  // Status of the networking subsystem of an instance
  InstanceNetworkStatus network = 11;

  // Whether all configurations related to an instance are in-sync.
  // This is a logical AND for the settings of all sub-configurations.
  // At this time it equals `InstanceNetworkStatus::configs_synced`,
  // but might in the future also include readiness for other subsystems.
  SyncState configs_synced = 101;
}

// State of the networking subsystem of an instance
message InstanceNetworkStatus {
  // Status for each configured interface
  //
  // Each entry in this status array maps to it's corresponding entry in the
  // Config section. E.g. `instance.status.network.interface_status[1]`
  // would map to `instance.config.network.interface_configs[1]`.
  repeated InstanceInterfaceStatus interfaces = 1;

  // Whether all desired network changes that the user has applied have taken effect
  // This includes:
  // - Whether `InstanceNetworkConfig` is of exactly the same version as the
  //   version the user desires.
  // - Whether the version of each security policy that is either directly referenced
  //   as part of an `InstanceInterfaceConfig` or indirectly referenced via the
  //   the security policies that are applied to the VPC or NetworkSegment
  //   is exactly the same version as the version the user desires.
  //
  // Note for the implementation: We need to monitor all these config versions
  // on the feedback path from DPU to carbide in order to know whether the
  // changes have indeed taken effect.
  // TODO: Do we also want to show all applied versios here, or just track them
  // internally? Probably not helpfor for tenants at all - but it could be helpful
  // for the Forge operating team to debug settings that to do do not go in-sync
  // without having to attach to the database.
  SyncState configs_synced = 101;
}

// Contains all information about an actively running instance
// This entails both the instace configuration, as well as the current state of the instance
message Instance {
  // Instance ID
  UUID id = 1;
  // The ID of the machine which is utilized for this Instance
  UUID machine_id = 2;

  // The desired configuration on the instance
  InstanceConfig config = 103;

  // The most recent status of the instance that has been observed
  InstanceStatus status = 104;

  // Current version of the networking configuration that is applied on the instance
  // This field can be used in InstanceNetworkConfigUpdateRequest::if_version_match
  // to only request updates if the version hasn't been updated in between.
  string network_config_version = 201;
}

// The configuration that a customer desires for an instances network interface
message InstanceInterfaceConfig {
  // Whether the user wants to create a physical or virtual function
  InterfaceFunctionType function_type = 1;

  // Network segment ID can change. It if changes - we require a new IP address
  UUID network_segment_id = 3;

  // The ID of security group that is attached to this interface
  // Note: This is commented because we will not supported setting these in the first
  // release of the new Instance API
  // optional UUID security_group_id = 4;
}

// The actual status of a single network interface of an instance
message InstanceInterfaceStatus {
  // If the interface is defined as a virtual function (associated
  // `InstanceInterfaceConfig.function_type == InterfaceFunctionType::VIRTUAL_FUNCTION`,
  // then this value is set and specifies the virtual function ID that is configured
  // for this network interface.
  optional uint32 virtual_function_id = 1;

  // The MAC address which has been assigned to this interface
  // The list will be empty if interface configuration hasn't been completed
  // and therefore the address is unknown.
  optional string mac_address = 2;

  // The list of IP addresses that had been assigned to this interface,
  // based on the requested subnet.
  // The list will be empty if interface configuration hasn't been completed
  repeated string addresses = 3;
}

message InstanceReleaseRequest {
  UUID id = 1;
}

message InstanceReleaseResult {
}

message MachineSearchQuery {
  optional UUID id = 1;
  optional string fqdn = 2;
}

message InterfaceList {
  repeated MachineInterface interfaces = 1;
}

message MachineList {
  repeated Machine machines = 1;
}

message InterfaceSearchQuery {
  optional UUID id = 1;
}

message Machine {
  UUID id = 1;

  google.protobuf.Timestamp created = 4;
  google.protobuf.Timestamp updated = 5;
  google.protobuf.Timestamp deployed = 6;

  // Note: These might change if ore lifecycle mention flows into `Instance`
  string state = 7;
  repeated MachineEvent events = 8;
  // Note: This is not yet removed in this change to limit the amount of breaking
  // changes at once - but users shouldn't rely on it. The actually interesting
  // information around interfaces for Instance users is in `Instance::InstanceNetworkStatus`.
  repeated MachineInterface interfaces = 9;

  // TODO: This field might actually move Instance since the discovered hardware
  // could be different per lifecycle. When the machine is updated with different
  // hardware and restarted, the data can change. The Instance would have the
  // capability to store the actual discovery information for each lifecycle
  optional machine_discovery.DiscoveryInfo discovery_info = 10;
}

// The most recent tenant related status
message InstanceTenantStatus {
  // The current state of the instance from the point of view of the assigned tenant
  TenantState state = 1;
  // An optional message which can contain details about the state
  string state_details = 2;
}

enum SyncState {
  // All configuration changes that users requested have been applied
  SYNCED = 0;
  // At least one configuration change to an active instance has not yet been processed
  PENDING = 1;
}

enum MachineArchitecture {
  ARM = 0;
  X86 = 1;
}

message MachineEvent {
  int64 id = 1;
  UUID  machine_id = 2;

  string event = 3;

  google.protobuf.Timestamp time = 4;
}

message MachineInterface {
  UUID id = 1;
  optional UUID attached_dpu_machine_id = 2;
  UUID machine_id = 3;
  UUID segment_id = 4;

  string hostname = 5;

  UUID domain_id = 6;

  bool primary_interface = 7;
  string mac_address = 8;

  repeated string address = 9;
}

message DhcpDiscovery {
  string mac_address = 1;
  string relay_address = 2;
  optional string vendor_string = 3;
  optional string link_address = 4;
  optional string circuit_id = 5;
}

message DhcpRecord {
  UUID machine_id = 1;
  UUID machine_interface_id = 2;
  UUID segment_id = 3;
  UUID subdomain_id = 4;

  string fqdn = 5;
  string mac_address = 6;
  string address = 7;

  int32 mtu = 8;

  string prefix = 9;
  optional string gateway = 10;
}

message NetworkSegmentList {
  repeated NetworkSegment network_segments = 1;
}

message Tag {
  string slug = 1;
  optional string name = 3;  // Mandatory in case of CREATE action.
}

message TagCreate {
  Tag tag = 1;
}

message TagDelete {
  Tag tag = 1;
}

message TagResult {
  bool result = 1;
}

message TagVoid {
}

message TagsList {
  repeated string slugs = 1;
  UUID target = 2;
  TagTargetKind target_kind = 3;
}

message TagsListResult {
  repeated Tag tags = 1;
}

enum TagTargetKind {
  MACHINE = 0;
  NETWORK_SEGMENT = 1;
}

message TagAssign {
  string slug = 1;
  UUID target = 2;
  TagTargetKind target_kind = 3;
}

message TagRemove {
  string slug = 1;
  UUID target = 2;
  TagTargetKind target_kind = 3;
}

message SSHKeyValidationRequest {
    string user = 1;
    string pubkey = 2;
}

enum UserRoles {
  USER = 0;
  ADMINISTRATOR = 1;
  OPERATOR = 2;
  NOACCESS = 3;
}

message SSHKeyValidationResponse {
    bool is_authenticated = 1;
    UserRoles role = 2;
}

message CredentialRequest {
	string host_id = 1;  // UUID, IP address, host name or MAC address
}

message CredentialResponse {
	string username = 1;
	string password = 2;
}

enum BMCRequestType {
    IPMI = 0;
    REDFISH = 1;
}

message BMCMetaDataGetRequest {
    UUID machine_id = 1;
    UserRoles role = 2;
    BMCRequestType request_type = 3;
}

message BMCMetaDataGetResponse {
    string ip = 1;
    string user = 2;
    string password = 3;
}

message BMCMetaDataUpdateRequest {
    message DataItem {
        string user = 2;
        UserRoles role = 3;
        string password = 4;
    }

    UUID machine_id = 1;
    string ip = 2;
    repeated DataItem data = 3;
    BMCRequestType request_type = 4;
}

message BMCMetaDataUpdateResponse {}

message MachineCredentialsUpdateRequest {
   enum CredentialPurpose {
      HBN = 0;
      LOGIN_USER = 1;
   }
    message Credentials {
        string user = 1;
        string password = 2;
        CredentialPurpose credential_purpose = 3;
    }

    UUID machine_id = 4;
    repeated Credentials credentials = 5;
}

message MachineCredentialsUpdateResponse {}

message ForgeAgentControlRequest {
    UUID machine_id = 1;
}

message ForgeAgentControlResponse {
	enum Action {
		NOOP = 0;       // No operation. Do nothing
		RESET = 1;      // Wipe the machine, prepare for next tenant
		DISCOVERY = 2;  // Run full discovery
		REBUILD = 3;    // Future thingy
	}
	Action action = 1;
}

message MachineDiscoveryInfo {
  UUID machine_interface_id = 1;
  oneof discovery_data {
    machine_discovery.DiscoveryInfo info = 2;
  }
}

message MachineDiscoveryCompletedRequest {
	UUID machine_id = 1;
}

message MachineCleanupInfo {
	enum CleanupResult {
		OK = 0;
		ERROR = 1;
	}
	message CleanupStepResult {
		CleanupResult result = 1;
		// If the result was an error, this can contain the associate error message
		string message = 2;
	}

	UUID machine_id = 1;

	// NVMe Cleanup Result
	CleanupStepResult nvme = 2;
	// RAM cleanup result
	CleanupStepResult ram = 3;
	// EFI variable MemoryOverwriteRequestControl-e20939be-32d4-41be-a150-897f85d49829 must be set to 1
	CleanupStepResult mem_overwrite = 4;

	CleanupResult result = 11;
}

message MachineDiscoveryResult {
  // This is returned to the discovery client from the API. Lets try not to put much in here unless we need it.
  UUID machine_id = 1;
}

message MachineDiscoveryCompletedResponse { }

message MachineCleanupResult {
  // This is returned to the discovery client from the API. Lets try not to put much in here unless we need it.
}

message VpcResourceState {
    string state = 1;
}

message NetworkPrefixEvent {
  int64 id = 1;

  UUID network_prefix_id = 2;

  VpcResourceAction event = 3;

  google.protobuf.Timestamp time = 4;
}

message VpcResourceLeafEvent {
  int64 id = 1;

  UUID vpc_leaf_id = 2;

  VpcResourceAction event = 3;

  google.protobuf.Timestamp time = 4;
}

enum VpcResourceAction {
  VPC_INITIALIZE = 0;
  VPC_SUBMIT = 1;
  VPC_ACCEPT = 2;
  VPC_WAIT = 3;
  VPC_FAIL = 4;
  VPC_SUCCESS = 5;
  VPC_RECOMMISSION = 6;
}

message PxeInstructions {
    string pxe_script = 1;
}

// Specifies whether a network interface is physical network function (PF)
// or a virtual network function
enum InterfaceFunctionType {
  PHYSICAL_FUNCTION = 0;
  VIRTUAL_FUNCTION = 1;
}

// Observed status of the networking subsystem of an instance
message InstanceNetworkStatusObservation {
  // The ID of the instance for which this status was observed
  UUID instance_id = 1;

  // The version of the config that is applied on the networking subsystem
  // Only if the version is equivalent to the latest desired version we
  // can actually interpret the results. If the version is outdated, then the
  // list of interfaces might actually relate to a different interfaces than
  // the ones that are currently required by the networking config.
  string config_version = 2;

  // When this status was observed
  //
  // If the field isn't populated, the server will assume that status is up to
  // date. Clients can set the timestamp to indicate that they provide a status
  // to the server that is based on an older observation (e.g. a cache). This
  // can help the server to decide whether the data that is acted upon might be
  // oudated, and might not indicate that networking is still configured correctly.
  optional google.protobuf.Timestamp observed_at = 3;

  // Status for each configured interface
  repeated InstanceInterfaceStatusObservation interfaces = 4;
}

// Result for the RecordObservedInstanceNetworkStatus method
message ObservedInstanceNetworkStatusRecordResult {
}

// Observed status of a single network interface of an instance
message InstanceInterfaceStatusObservation {
  // Whether the interface is a physical or virtual function
  // In the case of a virtual function the associcated
  // `virtual_function_id` describes the ID of the interface
  InterfaceFunctionType function_type = 1;

  // If the interface is defined as a virtual function (associated
  // `function_type == InterfaceFunctionType::VIRTUAL_FUNCTION`,
  // then this value is set and specifies the virtual function ID that is configured
  // for this network interface.
  optional uint32 virtual_function_id = 2;

  // The MAC address which has been assigned to this interface
  // The list will be empty if interface configuration hasn't been completed
  // and therefore the address is unknown.
  optional string mac_address = 3;

  // The list of IP addresses that had been assigned to this interface,
  // based on the requested subnet.
  // The list will be empty if interface configuration hasn't been completed
  repeated string addresses = 4;
}

