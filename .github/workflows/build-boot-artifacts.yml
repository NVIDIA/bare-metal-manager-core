name: Build Artifacts (Boot & Ephemeral Images)

on:
  workflow_call:
    inputs:
      arch:
        description: 'Target architecture: x86_64 or aarch64'
        required: true
        type: string
      cargo_make_task:
        description: 'Cargo make task to execute'
        required: true
        type: string
      build_type:
        description: 'Build type: boot or ephemeral'
        required: true
        type: string
      build_container:
        description: 'Build container image to use (for container mode only)'
        required: false
        type: string
        default: ''
      runner:
        description: 'Runner label to use'
        required: true
        type: string
      version:
        description: 'Build version string (used for debian packages)'
        required: true
        type: string
      use_container:
        description: 'Run in container (true) or directly on runner (false for mkosi)'
        required: false
        default: true
        type: boolean
    outputs:
      artifacts_json:
        description: 'Artifacts paths as JSON array'
        value: ${{ jobs.build.outputs.artifacts }}

jobs:
  build:
    runs-on: ${{ inputs.runner }}
    timeout-minutes: 120
    outputs:
      artifacts: ${{ steps.collect-artifacts.outputs.paths }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 0  # Full git history needed for git describe

      - name: Initialize submodules at pinned commits
        run: |
          set -e

          # Try standard git submodule update first (respects pinned commits)
          echo "Attempting git submodule update..."
          git submodule update --init --recursive 2>&1 || echo "âš ï¸  git submodule command failed"

          # Check if submodules were actually cloned (command can succeed but not clone anything)
          if [ -f "pxe/ipxe/upstream/src/Makefile" ] && [ -d "pxe/mkosi/.git" ]; then
            echo "âœ… Submodules initialized via git submodule"
          else
            echo "âš ï¸  Submodules not present after git submodule, using manual fallback..."

            # Get the pinned commits from the Git tree (matches GitLab's GIT_SUBMODULE_STRATEGY: recursive)
            IPXE_COMMIT=$(git ls-tree HEAD pxe/ipxe/upstream | awk '{print $3}')
            MKOSI_COMMIT=$(git ls-tree HEAD pxe/mkosi | awk '{print $3}')

            # Fallback: If Git tree doesn't have submodule commits (sanitized repo),
            # read from .gitmodules which has FIXME hardcoded commits
            if [ -z "$IPXE_COMMIT" ]; then
              echo "âš ï¸  Git tree missing submodule metadata, reading from .gitmodules..."
              IPXE_COMMIT=$(git config -f .gitmodules --get submodule.pxe/ipxe/upstream.commit)
              MKOSI_COMMIT=$(git config -f .gitmodules --get submodule.mkosi.commit)
            fi

            echo "ðŸ“Œ iPXE pinned to: ${IPXE_COMMIT}"
            echo "ðŸ“Œ mkosi pinned to: ${MKOSI_COMMIT}"

            # Clone iPXE at the specific pinned commit
            if [ ! -f "pxe/ipxe/upstream/src/Makefile" ]; then
              echo "ðŸ“¦ Cloning iPXE at pinned commit..."
              rm -rf pxe/ipxe/upstream
              git clone https://github.com/ipxe/ipxe.git pxe/ipxe/upstream
              cd pxe/ipxe/upstream
              git checkout ${IPXE_COMMIT}
              cd ../../..
            fi

            # Clone mkosi at the specific pinned commit
            if [ ! -d "pxe/mkosi/.git" ]; then
              echo "ðŸ“¦ Cloning mkosi at pinned commit..."
              rm -rf pxe/mkosi
              git clone https://github.com/systemd/mkosi.git pxe/mkosi
              cd pxe/mkosi
              git checkout ${MKOSI_COMMIT}
              cd ../..
            fi
          fi

          # Verify submodules are present
          [ -f "pxe/ipxe/upstream/src/Makefile" ] || { echo "âŒ iPXE missing"; exit 1; }
          [ -d "pxe/mkosi" ] || { echo "âŒ mkosi missing"; exit 1; }

          # Show what we got (for debugging)
          echo "âœ… iPXE commit: $(cd pxe/ipxe/upstream && git rev-parse --short HEAD)"
          echo "âœ… mkosi commit: $(cd pxe/mkosi && git rev-parse --short HEAD)"
          echo "âœ… Submodules ready"

      # For ephemeral builds, download boot artifacts first
      - name: Download prerequisite boot artifacts
        if: inputs.build_type == 'ephemeral'
        uses: actions/download-artifact@v4
        with:
          name: boot-artifacts-${{ inputs.arch }}-${{ github.run_id }}
          path: .
        continue-on-error: false

      # Setup mkosi environment for ephemeral builds (runs on shell)
      - name: Setup mkosi environment
        if: inputs.build_type == 'ephemeral'
        uses: ./.github/actions/setup-mkosi-environment
        with:
          rust-version: '1.90.0'
          arch: ${{ inputs.arch }}

      # Setup Docker for container-based builds
      - name: Setup Docker authentication
        if: inputs.use_container == true
        uses: ./.github/actions/docker-auth
        with:
          username: ${{ secrets.NVCR_USERNAME }}
          token: ${{ secrets.NVCR_TOKEN }}

      - name: Pull build container
        if: inputs.use_container == true && inputs.build_container != ''
        run: |
          echo "Pulling build container: ${{ inputs.build_container }}"
          docker pull ${{ inputs.build_container }}

      - name: Set up environment variables
        run: |
          echo "CARGO_HOME=${{ github.workspace }}/cargo" >> $GITHUB_ENV
          echo "CARGO_INCREMENTAL=0" >> $GITHUB_ENV
          echo "CACHE_DIRECTORY=${{ github.workspace }}/cache" >> $GITHUB_ENV
          echo "APT_CACHE_DIR=${{ github.workspace }}/apt" >> $GITHUB_ENV
          echo "LOGNAME=root" >> $GITHUB_ENV
          echo "KEA_BIN_PATH=/usr/bin" >> $GITHUB_ENV
          echo "KEA_INCLUDE_PATH=/usr/include/kea" >> $GITHUB_ENV
          echo "REPO_ROOT=${{ github.workspace }}" >> $GITHUB_ENV
          echo "VERSION=${{ inputs.version }}" >> $GITHUB_ENV
          echo "FORGE_CA=prod" >> $GITHUB_ENV

          # Add cargo and sbin to PATH (needed for mkosi)
          echo "$HOME/.cargo/bin" >> $GITHUB_PATH
          echo "/sbin" >> $GITHUB_PATH
          echo "/usr/sbin" >> $GITHUB_PATH

      - name: Create cache directories
        run: |
          mkdir -p ${{ github.workspace }}/cargo
          mkdir -p ${{ github.workspace }}/cache
          mkdir -p ${{ github.workspace }}/apt
          mkdir -p pxe/static/blobs/internal/${{ inputs.arch }}

      - name: Display build information
        run: |
          echo "============================================"
          echo "Building: ${{ inputs.build_type }} artifacts"
          echo "============================================"
          echo "Architecture: ${{ inputs.arch }}"
          echo "Task: ${{ inputs.cargo_make_task }}"
          echo "Version: ${{ inputs.version }}"
          echo "Runner: ${{ inputs.runner }}"
          echo "Use container: ${{ inputs.use_container }}"
          if [ -n "${{ inputs.build_container }}" ]; then
            echo "Container: ${{ inputs.build_container }}"
          fi
          echo "Working directory: $(pwd)"
          echo "============================================"

      # Run build in container mode (for boot artifacts)
      - name: Run cargo make task (container mode)
        if: inputs.use_container == true
        run: |
          # Set up environment variables for container (matches GitLab CI global variables)
          ENV_ARGS="-e CARGO_HOME=/workspace/cargo"
          ENV_ARGS="$ENV_ARGS -e CARGO_INCREMENTAL=0"
          ENV_ARGS="$ENV_ARGS -e CACHE_DIRECTORY=/workspace/cache"
          ENV_ARGS="$ENV_ARGS -e APT_CACHE_DIR=/workspace/apt"
          ENV_ARGS="$ENV_ARGS -e LOGNAME=root"
          ENV_ARGS="$ENV_ARGS -e KEA_BIN_PATH=/usr/bin"
          ENV_ARGS="$ENV_ARGS -e KEA_INCLUDE_PATH=/usr/include/kea"
          ENV_ARGS="$ENV_ARGS -e REPO_ROOT=/workspace"
          ENV_ARGS="$ENV_ARGS -e VERSION=${{ inputs.version }}"
          ENV_ARGS="$ENV_ARGS -e FORGE_CA=prod"

          echo "============================================"
          echo "Running in container: ${{ inputs.build_container }}"
          echo "VERSION=${{ inputs.version }}"
          echo "FORGE_CA=prod"
          echo "============================================"

          # Run cargo make in container
          docker run --rm \
            -v "${{ github.workspace }}:/workspace" \
            -w /workspace \
            ${ENV_ARGS} \
            ${{ inputs.build_container }} \
            bash -c "git config --global --add safe.directory /workspace && git config --global --add safe.directory /workspace/pxe/ipxe/upstream && echo 'VERSION in container: '\${VERSION} && cargo make --cwd pxe ${{ inputs.cargo_make_task }}"

      # Run build directly on runner (for ephemeral images with mkosi)
      - name: Run cargo make task (shell mode)
        if: inputs.use_container == false
        run: |
          set -euo pipefail

          # Configure git to trust the workspace
          git config --global --add safe.directory "${{ github.workspace }}" || true

          # Source cargo environment
          source $HOME/.cargo/env

          echo "============================================"
          echo "Running on shell runner (mkosi mode)"
          echo "VERSION=${{ inputs.version }}"
          echo "============================================"

          # Run the cargo make task with full output
          cargo make --cwd pxe ${{ inputs.cargo_make_task }} 2>&1 | tee build.log

          echo "Build completed!"

      - name: Verify generated artifacts
        run: |
          echo "Checking generated artifacts..."

          if [[ "${{ inputs.build_type }}" == "boot" ]]; then
            if [[ "${{ inputs.arch }}" == "x86_64" ]]; then
              EXPECTED_FILES=(
                "pxe/static/blobs/internal/x86_64/ipxe.efi"
                "target/debug/forge-admin-cli"
              )
            else
              EXPECTED_FILES=(
                "pxe/static/blobs/internal/aarch64/ipxe.efi"
                "pxe/static/blobs/internal/aarch64/carbide.efi"
                "pxe/static/blobs/internal/aarch64/carbide.root"
              )
            fi
          elif [[ "${{ inputs.build_type }}" == "ephemeral" ]]; then
            if [[ "${{ inputs.arch }}" == "x86_64" ]]; then
              EXPECTED_FILES=(
                "pxe/static/blobs/internal/x86_64/scout.efi"
                "pxe/static/blobs/internal/x86_64/scout.cpio.zst"
                "pxe/static/blobs/internal/x86_64/qcow-imager.efi"
              )
            else
              EXPECTED_FILES=(
                "pxe/static/blobs/internal/aarch64/scout.efi"
                "pxe/static/blobs/internal/aarch64/scout.cpio.zst"
                "pxe/static/blobs/internal/aarch64/qcow-imager.efi"
              )
            fi
          fi

          ALL_FOUND=true
          for file in "${EXPECTED_FILES[@]}"; do
            if [[ -f "$file" ]]; then
              size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null)
              echo "âœ“ Found: $file (${size} bytes)"
            else
              echo "âœ— Missing: $file"
              ALL_FOUND=false
            fi
          done

          if [[ "$ALL_FOUND" != "true" ]]; then
            echo ""
            echo "ERROR: Not all expected artifacts were generated!"
            echo "Build may have failed. Check the build log above."
            exit 1
          fi

          echo ""
          echo "âœ… All expected artifacts generated successfully!"

      - name: Collect artifacts metadata
        id: collect-artifacts
        run: |
          # Determine artifacts based on build type and architecture
          if [[ "${{ inputs.build_type }}" == "boot" ]]; then
            if [[ "${{ inputs.arch }}" == "x86_64" ]]; then
              ARTIFACTS='["pxe/static/blobs/internal/x86_64/ipxe.efi", "target/debug/forge-admin-cli", "target/debs/*"]'
            else
              ARTIFACTS='["pxe/static/blobs/internal/aarch64/ipxe.efi", "pxe/static/blobs/internal/aarch64/carbide.efi", "pxe/static/blobs/internal/aarch64/carbide.root", "pxe/static/blobs/internal/aarch64/preingestion.bfb", "pxe/static/blobs/internal/aarch64/forge.bfb", "pxe/static/blobs/internal/apt", "target/aarch64-unknown-linux-gnu/release/forge-scout", "target/debs/*"]'
            fi
          else
            if [[ "${{ inputs.arch }}" == "x86_64" ]]; then
              ARTIFACTS='["pxe/static/blobs/internal/x86_64/scout.efi", "pxe/static/blobs/internal/x86_64/scout.cpio.zst", "pxe/static/blobs/internal/x86_64/qcow-imager.efi", "target/debs/*"]'
            else
              ARTIFACTS='["pxe/static/blobs/internal/aarch64/scout.efi", "pxe/static/blobs/internal/aarch64/scout.cpio.zst", "pxe/static/blobs/internal/aarch64/qcow-imager.efi", "pxe/mkosi.profiles/scout-x86_64/mkosi.extra/build-output/*", "target/debs/*"]'
            fi
          fi

          echo "paths=${ARTIFACTS}" >> $GITHUB_OUTPUT
          echo "Artifacts to upload: ${ARTIFACTS}"

      - name: Upload artifacts
        if: always()  # Upload artifacts even if build fails (matches GitLab CI 'when: always')
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.build_type }}-artifacts-${{ inputs.arch }}-${{ github.run_id }}
          path: |
            pxe/static/blobs/
            target/debug/forge-admin-cli
            target/debs/
            target/aarch64-unknown-linux-gnu/
            pxe/mkosi.profiles/
          if-no-files-found: warn
          retention-days: 1

      - name: Upload build log on failure
        if: failure() && inputs.build_type == 'ephemeral'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.build_type }}-build-log-${{ inputs.arch }}-${{ github.run_id }}
          path: build.log
          if-no-files-found: warn
          retention-days: 7

      - name: Display build summary
        run: |
          echo "============================================"
          echo "âœ… ${{ inputs.build_type }} Build Completed"
          echo "============================================"
          echo "Architecture: ${{ inputs.arch }}"
          echo "Task: ${{ inputs.cargo_make_task }}"
          echo "Version: ${{ inputs.version }}"
          echo "Container mode: ${{ inputs.use_container }}"
          echo ""
          echo "Generated Artifacts:"
          find pxe/static/blobs/internal/${{ inputs.arch }} -type f 2>/dev/null || echo "No blobs found"
          echo "============================================"
