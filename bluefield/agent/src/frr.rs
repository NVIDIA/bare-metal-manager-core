/*
 *   SPDX-FileCopyrightText: Copyright (c) 2022-2022. NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 *   SPDX-License-Identifier: LicenseRef-NvidiaProprietary
 *
 *   NVIDIA CORPORATION, its affiliates and licensors retain all intellectual
 *   property and proprietary rights in and to this material, related
 *   documentation and any modifications thereto. Any use, reproduction,
 *   disclosure or distribution of this material and related documentation
 *   without an express license agreement from NVIDIA CORPORATION or
 *   its affiliates is strictly prohibited.
 */

use std::{net::Ipv4Addr, process::Command};

use eyre::WrapErr;
use gtmpl_derive::Gtmpl;

pub const PATH: &str = "/var/lib/hbn/etc/frr/frr.conf";
const TMPL_FULL: &str = include_str!("../templates/frr.conf");

const _TMPL_EMPTY: &str = "
# Auto-generated by Forge.
!---- Cumulus Defaults ----
frr defaults datacenter
log syslog informational
no zebra nexthop kernel enable
!---- Rendered frr.conf ----
vrf default
exit-vrf
!---- CUE snippets ----
";

/// Generate frr.conf
pub fn build(conf: FrrConfig) -> Result<String, eyre::Report> {
    let params = TmplFrrConfigParameters {
        ASN: conf.asn,
        LoopbackIP: conf.loopback_ip.to_string(),
        Uplinks: conf.uplinks,
        AccessVLANs: conf
            .access_vlans
            .into_iter()
            .map(|c| TmplFrrConfigVLAN {
                ID: c.vlan_id,
                HostRoute: format!("{}/32", c.ip),
            })
            .collect(),
    };
    match gtmpl::template(TMPL_FULL, params) {
        Ok(s) =>
        // we indent the template for readability. remove those indents, but not the blank lines
        {
            Ok(s.lines()
                .map(|l| l.trim_start())
                .collect::<Vec<_>>()
                .join("\n")
                + "\n")
        }
        Err(err) => Err(err.into()),
    }
}

pub fn reload() -> Result<(), eyre::Report> {
    let out = Command::new("/usr/lib/frr/frrinit.sh")
        .arg("reload")
        .output()
        .wrap_err("/usr/lib/frr/frrinit.sh")?;
    if !out.status.success() {
        return Err(eyre::eyre!(
            "Failed reloading frr.conf with '/usr/lib/frr/frrinit.sh reload'. \nSTDOUT: {}\nSTDERR: {}",
            String::from_utf8_lossy(&out.stdout),
            String::from_utf8_lossy(&out.stderr),
        ));
    }
    Ok(())
}

/// What we need in order to generate an frr.conf
pub struct FrrConfig {
    pub asn: u64,
    pub loopback_ip: Ipv4Addr,
    pub uplinks: Vec<String>,
    pub access_vlans: Vec<FrrVlanConfig>,
}

pub struct FrrVlanConfig {
    pub vlan_id: u32,
    pub ip: String,
}

//
// Go template objects, hence allow(non_snake_case)
//

#[allow(non_snake_case)]
#[derive(Clone, Gtmpl)]
struct TmplFrrConfigVLAN {
    ID: u32,
    HostRoute: String,
}

#[allow(non_snake_case)]
#[derive(Clone, Gtmpl)]
struct TmplFrrConfigParameters {
    ASN: u64,
    LoopbackIP: String,
    Uplinks: Vec<String>,
    AccessVLANs: Vec<TmplFrrConfigVLAN>,
}

#[cfg(test)]
mod tests {
    use super::{build, FrrConfig};

    #[test]
    fn test_write_frr() -> Result<(), Box<dyn std::error::Error>> {
        let params = FrrConfig {
            asn: 65535,
            uplinks: vec!["p0_sf".to_string(), "p1_sf".to_string()],
            loopback_ip: [192, 168, 0, 1].into(),
            access_vlans: vec![],
        };
        let output = build(params)?;
        let expected = include_str!("../templates/tests/frr.conf.expected");
        let mut has_error = false;
        if output != expected {
            for (g, e) in output.lines().zip(expected.lines()) {
                if g != e {
                    has_error = true;
                    println!("Line differs:");
                    println!("GOT: {}", g);
                    println!("EXP: {}", e);
                }
            }
        }
        assert!(!has_error);

        Ok(())
    }
}
