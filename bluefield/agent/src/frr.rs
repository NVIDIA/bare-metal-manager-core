/*
 *   SPDX-FileCopyrightText: Copyright (c) 2022-2022. NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 *   SPDX-License-Identifier: LicenseRef-NvidiaProprietary
 *
 *   NVIDIA CORPORATION, its affiliates and licensors retain all intellectual
 *   property and proprietary rights in and to this material, related
 *   documentation and any modifications thereto. Any use, reproduction,
 *   disclosure or distribution of this material and related documentation
 *   without an express license agreement from NVIDIA CORPORATION or
 *   its affiliates is strictly prohibited.
 */

use std::net::Ipv4Addr;

use gtmpl_derive::Gtmpl;

const TMPL_FULL: &str = include_str!("../templates/frr.conf");

const _TMPL_EMPTY: &str = "
# Auto-generated by Forge.
!---- Cumulus Defaults ----
frr defaults datacenter
log syslog informational
no zebra nexthop kernel enable
!---- Rendered frr.conf ----
vrf default
exit-vrf
!---- CUE snippets ----
";

/// Generate frr.conf
pub fn build(conf: FrrConfig) -> Result<String, eyre::Report> {
    let params = TmplFrrConfigParameters {
        ASN: conf.asn,
        LoopbackIP: conf.loopback_ip.to_string(),
        UplinkPeerGroup: "FORGE_UPLINK".to_string(),
        Uplinks: vec!["p0_sf".to_string(), "p1_sf".to_string()],
        ToUnderlayRouteFilterName: "FORGE_TO_UNDERLAY".to_string(),
        FromUnderlayRouteFilterName: "FORGE_FROM_UNDERLAY".to_string(),
        ImportDefaultRouteOnly: conf.is_import_default_route,
        AccessVLANs: conf
            .access_vlans
            .into_iter()
            .map(|c| TmplFrrConfigVLAN {
                ID: c.id,
                HostRoute: c.host_route,
            })
            .collect(),
    };
    gtmpl::template(TMPL_FULL, params).map_err(|e| e.into())
}

/// What we need in order to generate an frr.conf
pub struct FrrConfig {
    pub asn: i64,
    pub loopback_ip: Ipv4Addr,
    pub is_import_default_route: bool,
    pub access_vlans: Vec<FrrVlanConfig>,
}

pub struct FrrVlanConfig {
    pub id: u32,
    pub host_route: String,
}

//
// Go template objects, hence allow(non_snake_case)
//

#[allow(non_snake_case)]
#[derive(Clone, Gtmpl)]
struct TmplFrrConfigVLAN {
    ID: u32,
    HostRoute: String,
}

#[allow(non_snake_case)]
#[derive(Clone, Gtmpl)]
struct TmplFrrConfigParameters {
    ASN: i64,
    LoopbackIP: String,
    UplinkPeerGroup: String,
    Uplinks: Vec<String>,
    ToUnderlayRouteFilterName: String,
    FromUnderlayRouteFilterName: String,
    ImportDefaultRouteOnly: bool,
    AccessVLANs: Vec<TmplFrrConfigVLAN>,
}

#[cfg(test)]
mod tests {
    use super::{build, FrrConfig};

    #[test]
    fn test_full() -> Result<(), Box<dyn std::error::Error>> {
        let params = FrrConfig {
            asn: 65535,
            loopback_ip: [192, 168, 0, 1].into(),
            is_import_default_route: true,
            access_vlans: vec![],
        };
        let output = build(params)?;
        assert_eq!(output, include_str!("../templates/frr.conf.expected"));

        Ok(())
    }
}
