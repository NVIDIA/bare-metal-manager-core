/*
 *   SPDX-FileCopyrightText: Copyright (c) 2022-2022. NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 *   SPDX-License-Identifier: LicenseRef-NvidiaProprietary
 *
 *   NVIDIA CORPORATION, its affiliates and licensors retain all intellectual
 *   property and proprietary rights in and to this material, related
 *   documentation and any modifications thereto. Any use, reproduction,
 *   disclosure or distribution of this material and related documentation
 *   without an express license agreement from NVIDIA CORPORATION or
 *   its affiliates is strictly prohibited.
 */

use std::net::Ipv4Addr;

use gtmpl_derive::Gtmpl;

use ::rpc::forge as rpc;

pub const PATH: &str = "etc/frr/frr.conf";
const TMPL_FULL_ETV: &str = include_str!("../templates/frr_etv.conf");
const TMPL_FULL_FNN: &str = include_str!("../templates/frr_fnn.conf");

pub const TMPL_EMPTY: &str = "
# Auto-generated by Forge.
!---- Cumulus Defaults ----
frr defaults datacenter
log syslog informational
no zebra nexthop kernel enable
!---- Rendered frr.conf ----
vrf default
exit-vrf
!---- CUE snippets ----
";

pub const RELOAD_CMD: &str = "/usr/lib/frr/frrinit.sh reload";

/// Generate frr.conf
pub fn build(conf: FrrConfig) -> Result<String, eyre::Report> {
    let params = TmplFrrConfigParameters {
        ASN: conf.asn,
        LoopbackIP: conf.loopback_ip.to_string(),
        Uplinks: conf.uplinks,
        AccessVLANs: conf
            .access_vlans
            .into_iter()
            .map(|c| TmplFrrConfigVLAN {
                ID: c.vlan_id,
                HostIP: c.ip,
                HostRoute: c.network,
            })
            .collect(),
        VpcVni: conf.vpc_vni.unwrap_or_default(),
        RouteServers: conf.route_servers.clone(),
    };
    let tmpl_path = match conf.network_virtualization_type {
        None => TMPL_FULL_ETV,
        Some(x) if x == rpc::VpcVirtualizationType::EthernetVirtualizer as i32 => TMPL_FULL_ETV,
        Some(x) if x == rpc::VpcVirtualizationType::ForgeNativeNetworking as i32 => TMPL_FULL_FNN,
        Some(x) => {
            eyre::bail!("Invalid network_virtualization_type {x}");
        }
    };
    match gtmpl::template(tmpl_path, params) {
        Ok(s) =>
        // we indent the template for readability. remove those indents, but not the blank lines
        {
            Ok(s.lines()
                .map(|l| l.trim_start())
                .collect::<Vec<_>>()
                .join("\n")
                + "\n")
        }
        Err(err) => Err(err.into()),
    }
}

/// An empty frr.conf
pub fn blank() -> String {
    gtmpl::template(TMPL_EMPTY, "").expect("frr blank template cannot fail")
}

/// What we need in order to generate an frr.conf
pub struct FrrConfig {
    pub asn: u32,
    pub loopback_ip: Ipv4Addr,
    pub uplinks: Vec<String>,
    pub access_vlans: Vec<FrrVlanConfig>,
    pub network_virtualization_type: Option<i32>,
    pub vpc_vni: Option<u32>,
    pub route_servers: Vec<String>,
}

pub struct FrrVlanConfig {
    pub vlan_id: u32,
    pub network: String,
    pub ip: String,
}

//
// Go template objects, hence allow(non_snake_case)
//

#[allow(non_snake_case)]
#[derive(Clone, Gtmpl)]
struct TmplFrrConfigVLAN {
    ID: u32,
    HostIP: String,
    HostRoute: String,
}

#[allow(non_snake_case)]
#[derive(Clone, Gtmpl)]
struct TmplFrrConfigParameters {
    ASN: u32,
    LoopbackIP: String,
    Uplinks: Vec<String>,
    AccessVLANs: Vec<TmplFrrConfigVLAN>,
    VpcVni: u32,
    RouteServers: Vec<String>,
}

#[cfg(test)]
mod tests {
    use super::{build, FrrConfig};

    #[test]
    fn test_write_frr() -> Result<(), Box<dyn std::error::Error>> {
        let params = FrrConfig {
            asn: 65535,
            uplinks: vec!["p0_sf".to_string(), "p1_sf".to_string()],
            loopback_ip: [192, 168, 0, 1].into(),
            access_vlans: vec![],
            network_virtualization_type: None,
            vpc_vni: None,
            route_servers: vec![],
        };
        let output = build(params)?;
        let expected = include_str!("../templates/tests/frr.conf.expected");
        let mut has_error = false;
        if output != expected {
            for (g, e) in output.lines().zip(expected.lines()) {
                if g.trim() != e.trim() {
                    has_error = true;
                    println!("Line differs:");
                    println!("GOT: {}", g);
                    println!("EXP: {}", e);
                }
            }
        }
        assert!(!has_error);

        Ok(())
    }
}
