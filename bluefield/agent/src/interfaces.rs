/*
 *   SPDX-FileCopyrightText: Copyright (c) 2022-2022. NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 *   SPDX-License-Identifier: LicenseRef-NvidiaProprietary
 *
 *   NVIDIA CORPORATION, its affiliates and licensors retain all intellectual
 *   property and proprietary rights in and to this material, related
 *   documentation and any modifications thereto. Any use, reproduction,
 *   disclosure or distribution of this material and related documentation
 *   without an express license agreement from NVIDIA CORPORATION or
 *   its affiliates is strictly prohibited.
 */

use std::net::Ipv4Addr;

use gtmpl_derive::Gtmpl;
use serde::Deserialize;

use ::rpc::forge as rpc;

pub const PATH: &str = "etc/network/interfaces";
const TMPL_FULL_ETV: &str = include_str!("../templates/interfaces_etv");
const TMPL_FULL_FNN: &str = include_str!("../templates/interfaces_fnn");
const TMPL_EMPTY: &str = "# Auto-generated by Forge!
source /etc/network/interfaces.d/*.intf

auto lo
iface lo inet loopback
";
pub const RELOAD_CMD: &str = "ifreload -a";

/// Generate interfaces file
pub fn build(conf: InterfacesConfig) -> Result<String, eyre::Report> {
    let mut nets = Vec::with_capacity(conf.networks.len());
    for network in conf.networks {
        nets.push(TmplEniConfigPort {
            Name: network.interface_name.clone(),
            VlanID: network.vlan,
            VNI: network.vni,
            IP: network.gateway_cidr.clone(),
        });
    }
    let params = TmplEniConfigParameters {
        LoopbackIP: conf.loopback_ip.to_string(),
        Uplinks: conf.uplinks,
        PortConfigs: nets,
        VNIDevice: conf.vni_device,
    };
    let tmpl_path = match conf.network_virtualization_type {
        None => TMPL_FULL_ETV,
        Some(x) if x == rpc::VpcVirtualizationType::EthernetVirtualizer as i32 => TMPL_FULL_ETV,
        Some(x) if x == rpc::VpcVirtualizationType::ForgeNativeNetworking as i32 => TMPL_FULL_FNN,
        Some(x) => {
            eyre::bail!("Invalid network_virtualization_type {x}");
        }
    };
    gtmpl::template(tmpl_path, params).map_err(|e| e.into())
}

/// An empty interfaces
pub fn blank() -> String {
    gtmpl::template(TMPL_EMPTY, "").expect("interfaces blank template cannot fail")
}

pub struct InterfacesConfig {
    pub loopback_ip: Ipv4Addr,
    pub uplinks: Vec<String>,
    pub vni_device: String,
    pub networks: Vec<Network>,
    pub network_virtualization_type: Option<i32>,
}

#[derive(Deserialize, Debug)]
pub struct Network {
    pub interface_name: String,
    pub vlan: u16,
    pub vni: u32,
    pub gateway_cidr: String,
}

//
// Go template objects, hence allow(non_snake_case)
//

#[allow(non_snake_case)]
#[derive(Clone, Gtmpl)]
struct TmplEniConfigParameters {
    LoopbackIP: String,
    Uplinks: Vec<String>,
    PortConfigs: Vec<TmplEniConfigPort>,
    VNIDevice: String,
}

#[allow(non_snake_case)]
#[derive(Clone, Gtmpl)]
struct TmplEniConfigPort {
    Name: String,
    VlanID: u16,
    VNI: u32,
    IP: String, // with mask, 1.1.1.1/20
}
