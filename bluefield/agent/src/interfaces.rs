/*
 *   SPDX-FileCopyrightText: Copyright (c) 2022-2022. NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 *   SPDX-License-Identifier: LicenseRef-NvidiaProprietary
 *
 *   NVIDIA CORPORATION, its affiliates and licensors retain all intellectual
 *   property and proprietary rights in and to this material, related
 *   documentation and any modifications thereto. Any use, reproduction,
 *   disclosure or distribution of this material and related documentation
 *   without an express license agreement from NVIDIA CORPORATION or
 *   its affiliates is strictly prohibited.
 */

use std::net::Ipv4Addr;

use gtmpl_derive::Gtmpl;
use serde::Deserialize;

const _PATH: &str = "/etc/network/interfaces";
const TMPL_FULL: &str = include_str!("../templates/interfaces");
const _TMPL_EMPTY: &str = "# Auto-generated by Forge!
source /etc/network/interfaces.d/*.intf

auto lo
iface lo inet loopback
";

/// Generate interfaces file
pub fn build(conf: InterfacesConfig) -> Result<String, eyre::Report> {
    let mut ports = Vec::with_capacity(conf.ports.len());
    for port in conf.ports {
        let name = port.host_interface + "_sf";
        let ip_with_mask = if port.is_isolated {
            // Hack, use the last IP in the range.
            let gw_ip_bytes = port.gw_ip.octets();
            let gw_mask_bytes = port.gw_mask.octets();
            let mut ip: [u8; 4] = [0, 0, 0, 0];
            for i in 0..4 {
                ip[i] = gw_ip_bytes[i] | (0b11111111 ^ gw_mask_bytes[i]);
            }
            ip[3] -= 1;
            let ipaddr: Ipv4Addr = ip.into();
            format!("{}/32", ipaddr)
        } else {
            format!(
                "{}/{}",
                port.gw_ip,
                ipnetwork::ipv4_mask_to_prefix(port.gw_mask)?
            )
        };
        ports.push(TmplEniConfigPort {
            Name: name,
            VlanID: port.vlan as u32,
            VNI: port.vni,
            IP: ip_with_mask,
        });
    }
    let params = TmplEniConfigParameters {
        LoopbackIP: conf.loopback_ip.to_string(),
        Uplinks: vec!["p0_sf".to_string(), "p1_sf".to_string()],
        PortConfigs: ports,
        VNIDevice: if conf.is_admin {
            "".to_string()
        } else {
            "vxlan5555".to_string()
        },
    };
    gtmpl::template(TMPL_FULL, params).map_err(|e| e.into())
}

pub struct InterfacesConfig {
    pub loopback_ip: Ipv4Addr,
    pub is_admin: bool, // true for HostAdminRequest, false for PortRequest
    pub ports: Vec<PortConfig>,
}

#[derive(Deserialize, Debug)]
pub struct PortConfig {
    pub host_interface: String,
    pub vlan: u16,
    pub vni: u32,
    pub gw_ip: Ipv4Addr,
    pub gw_mask: Ipv4Addr,
    pub is_isolated: bool,
}

//
// Go template objects, hence allow(non_snake_case)
//

#[allow(non_snake_case)]
#[derive(Clone, Gtmpl)]
struct TmplEniConfigParameters {
    LoopbackIP: String,
    Uplinks: Vec<String>,
    PortConfigs: Vec<TmplEniConfigPort>,
    VNIDevice: String,
}

#[allow(non_snake_case)]
#[derive(Clone, Gtmpl)]
struct TmplEniConfigPort {
    Name: String,
    VlanID: u32,
    VNI: u32,
    IP: String, // with mask, 1.1.1.1/20
}
