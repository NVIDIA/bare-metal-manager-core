{{- $nvueConfig := . -}}
- header:
    model: VX
    nvue-api-version: nvue_v1
    rev-id: 1.0
    version: Cumulus Linux 5.6.0
- set:
{{- if .IncludeBridge }} {{/* Only if an L2 segment exists should bridges be configured */}}
    bridge:
      domain:
        br_default:
          vlan:
  {{- range .Tenant.PortConfigs }}
    {{- if .IsL2Segment }}
            '{{ .VlanID }}':
              vni:
                '{{ .L2VNI }}': {} {{/* Always configuring an L2VNI, even if not necessary. Less conditions in the template */}}
    {{- end }}
  {{- end }}
{{- end }}
    evpn:
      enable: on
    interface:
      lo:
        ip:
          address:
            {{ .LoopbackIP }}/32: {}
        type: loopback
      pf0dpu1_if:
        ip:
          address:
            169.254.169.253/30: {}
{{- if .IsStorageClient }} {{/* New variable to be created to define if a node is a storage client and the interface should be created */}}
      pf0dpu3_if:
        ip:
          address:
            {{ $.StorageDpuIP }}: {}
        vrf: storage
{{- end }}
{{- range .Uplinks}}
      {{ . }}:
        type: swp
{{- end }}
{{- $tenant := .Tenant }}
{{- range .Tenant.PortConfigs }}
      {{ .InterfaceName }}:
        type: swp
        acl: {{/* Removing condition of use-case. ACL should always be configured. The condition should be for the ACL content and not the existance */}}
        {{- if $.HasDenyPrefixes }}
          p0000_deny_prefixes_ipv4:
            inbound: {}
        {{- end }}
          p0005_security_group_ipv4_in: 
            inbound: {}
          p0005_security_group_ipv6_in:
            inbound: {}
          p0005_security_group_ipv4_out: 
            outbound: {}
          p0005_security_group_ipv6_out: 
            outbound: {}
        {{- if $tenant.HasVpcPeerPrefixes }}
          p0009_vpc_peer_egress_from_host:
            inbound: {}
          p0009_vpc_peer_ingress_to_host:
            outbound: {}
        {{- end }}
        {{- if and ($.UseVpcIsolation) ($.HasSiteFabricPrefixes) }}
          {{- if not $tenant.HasNetworkSecurityGroup }}
          p0010_vpc_isolation_ipv4:
            inbound: {}
          {{- end }}
        {{- end }}
        {{- if $tenant.HasVpcPeerPrefixes }}
          p0015_vpc_peer_in:
            inbound: {}
          p0015_vpc_peer_out:
            outbound: {}
        {{- end }}
   {{- if .IsL2Segment }}
          dhcp_flood_prevention:
            inbound: {}
   {{- end }}
   {{- if not .IsL2Segment }} {{/* If not L2, IP will be directly configured on the interface */}}
        ip:
          address:
            {{ .IP }}: {} {{/* In case of FNN L3, this is the first IP in the /31 in the prefix */}}
          vrf: {{ $tenant.VrfName }} {{/* The name of the VRF (VPC) this interface should be in (reference to the configured VRF later) */}}
     {{- else }} {{/* If the segment is L2, the interface should be configured in the bridge */}}
        bridge:
          domain:
            br_default:
              access: {{ .VlanID }}
   {{- end }}
  {{- if .IsL2Segment }} {{/* If the segment is L2, an SVI is needed */}}
      vlan{{ .VlanID }}:
        type: svi
        vlan: {{ .VlanID }}
        ip:
          address:
            {{ .SviIP }}: {} {{/* The SviIP is a _different_ ip from the same subnet than the gateway. Typically the second IP in the subnet */}}
          vrf: {{ $tenant.VrfName }} {{/* The name of the VRF (VPC) this interface should be in (reference to the configured VRF later) */}}
          vrr:
            address:
              {{ .IP }}: {} {{/* In case of FNN l2, the first IP from the subnet */}}
            enable: on
            mac-address: {{ .SviMAC }} {{/* A shared MAC address for all vlan interfaces in the same VNI (VPC) */}}
            state:
              up: {}
  {{- end }}
{{- end }}
    nve:
      vxlan:
        arp-nd-suppress: on
        enable: on
        source:
          address: {{ .LoopbackIP }} {{/* Unique DPU Loopback used as VTEP */}}
    router:
      bgp:
        autonomous-system: {{ .ASN }} {{/* Unique DPU ASN */}}
        enable: on
        router-id: {{ .LoopbackIP }}
      vrr:
        enable: on
      policy:
        prefix-list:
          dpu_from_instance: {{/* In case of BYOIP a limit so only /32s can be accepted */}}
            rule:
              '10':
                action: permit
                match:
                  0.0.0.0/0:
                    min-prefix-len: 32
        route-map:
          dpu_to_instance:
            rule:
              '10':
                action:
                  deny: {}
{{- if $nvueConfig.StatefulAclsEnabled }}
    system:
      reflexive-acl:
        enable: on                  
{{- end }}
    vrf:
      default:
        router:
          nexthop-tracking:
            ipv4:
              resolved-via-default: on
          bgp:
            address-family:
              ipv4-unicast:
                enable: on
                multipaths:
                  ebgp: 128
                redistribute:
                  connected:
                    enable: on
              l2vpn-evpn:
                enable: on
            enable: on
            neighbor:
{{- range .RouteServers }}
              {{ . }}:
                peer-group: routeserver
                type: numbered
{{- end }}
{{- range .Uplinks}}
              {{ . }}:
                peer-group: underlay
                type: unnumbered
{{- end }}
            path-selection:
              multipath:
                aspath-ignore: on
            peer-group:
              routeserver:
                address-family:
                  ipv4-unicast:
                    enable: off
                  l2vpn-evpn:
                    enable: on
                multihop-ttl: 255
                remote-as: external
                update-source: lo
              underlay:
                remote-as: external
{{- if .Tenant.VrfLoopback }}
      {{ .Tenant.VrfName }}: {{/* A VRF (VPC) needs to be defined on each DPU. This also creates an interface which introduces a max of 15 chars */}}
        evpn:
          enable: on
          vni:
            '{{ .Tenant.L3VNI }}': {} {{/* A VRF (VPC) needs a unique VNI to create the tenant separation */}}
        loopback:
          ip:
            address:
              {{ .Tenant.VrfLoopback }}/32: {} {{/* Every VRF on each DPU requires a unique loopback address */}}
        router:
          bgp:
            address-family:
              ipv4-unicast:
                enable: on
                redistribute:
                  connected:
                    enable: on
                route-export:
                  to-evpn:
                    enable: on
            enable: on
            neighbor:
  {{- range .Tenant.HostInterfaces}}
    {{- if .HostIP }}
              {{ .HostIP }}:
                passive-mode: on
                peer-group: tenant
                type: numbered
    {{- end }}
  {{- end }}
            peer-group:
              tenant:
                address-family:
                  ipv4-unicast:
                    policy:
                      inbound:
                        prefix-list: dpu_from_instance
                      outbound:
                        route-map: dpu_to_instance
                nexthop-connected-check: off
                remote-as: external
                timers:
                  connection-retry: 10
                  hold: 9
                  keepalive: 3
                  route-advertisement: none
            route-export:
              to-evpn:
                route-target:
                  11414:{{ .Tenant.L3VNI }}: {}
            route-import:
              from-evpn:
                route-target:
                  11414:{{ $.InternetL3VNI }}: {}
                  11414:{{ .Tenant.L3VNI }}: {}
                {{- range .Tenant.VpcPeerVnis }}
                  11414:{{ .Vni }}: {}
                {{- end}}
                  auto: {}
{{- end }}
    acl:
      dhcp_flood_prevention:
        rule: 
          '10':
            action:
              deny: {}
            hw-offload: off
            match:
              ip:
                dest-ip: 255.255.255.255
                dest-port:
                  '67': {}
                protocol: udp
                source-port:
                  '68': {}
        type: ipv4

 {{- if $.HasDenyPrefixes }}
      p0000_deny_prefixes_ipv4:
        type: ipv4
        rule:
    {{- if not .Tenant.HasNetworkSecurityGroup }}
      {{- range $tenant.PortConfigs }}
        {{- range .VpcPrefixes }}
          '{{ .Index }}':
            action:
              permit: {}
            match:
              ip:
                dest-ip: {{ .Prefix }}
        {{- end }}
      {{- end }}
    {{- end}}        
    {{- range $.DenyPrefixes }}
          '{{ .Index }}':
            action:
              deny: {}
            match:
              ip:
                dest-ip: {{ .Prefix }}
    {{- end }}
{{- end }}
{{- if .Tenant.HasVpcPeerPrefixes }}
      p0009_vpc_peer_egress_from_host:
        rule:
        {{- range .Tenant.VpcPeerPrefixes }}
          '{{ .Index }}':
            action:
              permit: {}
            match:
              ip:
                dest-ip: {{ .Prefix }}
        {{- end }}
      p0009_vpc_peer_ingress_to_host:
        rule:
        {{- range .Tenant.VpcPeerPrefixes }}
          '{{ .Index }}':
            action:
              permit: {}
            match:
              ip:
                source-ip: {{ .Prefix }}
        {{- end }}
{{- end }}
 {{- if and ($.UseVpcIsolation) ($.HasSiteFabricPrefixes) }}
    {{- if not .Tenant.HasNetworkSecurityGroup }}
      p0010_vpc_isolation_ipv4:
        type: ipv4
        rule:
      {{- range $tenant.PortConfigs }}
        {{- range .VpcPrefixes }}
          '{{ .Index }}':
            action:
              permit: {}
            match:
              ip:
                dest-ip: {{ .Prefix }}
        {{- end }}
      {{- end }}
      {{- range $.SiteFabricPrefixes }}
          '{{ .Index }}':
            action:
              deny: {}
            match:
              ip:
                dest-ip: {{ .Prefix }}
      {{- end }}
    {{- end}}
 {{- end}}
      p0005_security_group_ipv4_in: {{/* Egress from host.  Ingress and Egress is defined from instance perspective, so reverse on DPU side */}}
        rule:
      {{- if .Tenant.HasIpv4EgressSecurityGroupRules }}
        {{- range .Tenant.EgressNetworkSecurityGroupRulesIpv4 }}
          '{{ .Priority }}':
            action:
              {{ .Action }}: {}
            match:
              {{- if and ($nvueConfig.StatefulAclsEnabled) (.CanBeStateful) }}
              conntrack:{{/* Testing showed this is not needed, but we should follow the docs */}}
                new: {}
                established: {}
              {{- end }}
              ip:
                dest-ip: {{ .DstPrefix }}
                {{- if .HasDstPort }}
                dest-port:
                  '{{ .DstPort }}': {}
                {{- end }} 
                {{- if not .CanMatchAnyProtocol }} 
                protocol: {{ .Protocol }}
                {{- end}}
                source-ip: {{ .SrcPrefix }} 
                {{- if .HasSrcPort }}
                source-port:
                  '{{ .SrcPort }}': {}
                {{- end }} 
        {{- end }}
      {{- end }}
          '65535':
            action:
              {{- if .Tenant.HasNetworkSecurityGroup }}
              deny: {}
              {{- else }}
              permit: {}
              {{- end }}
        type: ipv4
      p0005_security_group_ipv6_in: {{/* Egress from host.  Ingress and Egress is defined from instance perspective, so reverse on DPU side */}}
        rule:
      {{- if .Tenant.HasIpv6EgressSecurityGroupRules }}
        {{- range .Tenant.EgressNetworkSecurityGroupRulesIpv6 }}
          '{{ .Priority }}':
            action:
              {{ .Action }}: {}
            match:
              ip:
                dest-ip: {{ .DstPrefix }}
                {{- if .HasDstPort }}
                dest-port:
                  '{{ .DstPort }}': {}
                {{- end }} 
                {{- if not .CanMatchAnyProtocol }} 
                protocol: {{ .Protocol }}
                {{- end }}
                source-ip: {{ .SrcPrefix }} 
                {{- if .HasSrcPort }}
                source-port:
                  '{{ .SrcPort }}': {}
                {{- end }} 
        {{- end }}
      {{- end }}
          '65535':
            action:
              {{- if .Tenant.HasNetworkSecurityGroup }}
              deny: {}
              {{- else }}
              permit: {}
              {{- end }}
        type: ipv6
      p0005_security_group_ipv4_out: {{/* Ingress to host. Ingress and Egress is defined from instance perspective, so reverse on DPU side */}}
        rule:
      {{- if .Tenant.HasIpv4IngressSecurityGroupRules }}
        {{- range .Tenant.IngressNetworkSecurityGroupRulesIpv4 }}
          '{{ .Priority }}':
            action:
              {{ .Action }}: {}
            match:
              ip:
                dest-ip: {{ .DstPrefix }}
                {{- if .HasDstPort }}
                dest-port:
                  '{{ .DstPort }}': {}
                {{- end }}
                {{- if not .CanMatchAnyProtocol }} 
                protocol: {{ .Protocol }}
                {{- end }}
                source-ip: {{ .SrcPrefix }} 
                {{- if .HasSrcPort }}
                source-port:
                  '{{ .SrcPort }}': {}
                {{- end }} 
        {{- end }}
      {{- end }}
      {{- if $nvueConfig.StatefulAclsEnabled }}
          '65532':
            action:
              permit: {}
            match:
              ip:
                protocol: tcp
              conntrack:
                established: {}
          '65533':
            action:
              permit: {}
            match:
              ip:
                protocol: udp
              conntrack:
                established: {}
          '65534':
            action:
              permit: {}
            match:
              ip:
                protocol: icmp
              conntrack:
                established: {}
      {{- end }}
          '65535':
            action:
              {{- if .Tenant.HasNetworkSecurityGroup }}
              deny: {}
              {{- else }}
              permit: {}
              {{- end }}
        type: ipv4
      p0005_security_group_ipv6_out: {{/* Ingress to host.  Ingress and Egress is defined from instance perspective, so reverse on DPU side */}}
        rule:
      {{- if .Tenant.HasIpv6IngressSecurityGroupRules }}
        {{- range .Tenant.IngressNetworkSecurityGroupRulesIpv6 }}
          '{{ .Priority }}':
            action:
              {{ .Action }}: {}
            match:
              ip:
                dest-ip: {{ .DstPrefix }}
                {{- if .HasDstPort }}
                dest-port:
                  '{{ .DstPort }}': {}
                {{- end }} 
                {{- if not .CanMatchAnyProtocol }} 
                protocol: {{ .Protocol }}
                {{- end}}
                source-ip: {{ .SrcPrefix }} 
                {{- if .HasSrcPort }}
                source-port:
                  '{{ .SrcPort }}': {}
                {{- end }} 
        {{- end }}
      {{- end }}
          '65535':
            action:
              {{- if .Tenant.HasNetworkSecurityGroup }}
              deny: {}
              {{- else }}
              permit: {}
              {{- end }}
        type: ipv6
