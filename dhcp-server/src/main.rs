/*
 * SPDX-FileCopyrightText: Copyright (c) 2021-2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 * SPDX-License-Identifier: LicenseRef-NvidiaProprietary
 *
 * NVIDIA CORPORATION, its affiliates and licensors retain all intellectual
 * property and proprietary rights in and to this material, related
 * documentation and any modifications thereto. Any use, reproduction,
 * disclosure or distribution of this material and related documentation
 * without an express license agreement from NVIDIA CORPORATION or
 * its affiliates is strictly prohibited.
 */

mod cache;
mod command_line;
mod errors;
mod modes;
mod packet_handler;
mod rpc;
mod util;
mod vendor_class;

use std::{
    collections::HashMap,
    error::Error,
    net::{Ipv4Addr, SocketAddr},
    sync::Arc,
    time::Duration,
};

use ::rpc::{
    forge::{DhcpDiscovery, DhcpRecord},
    MachineId, Uuid,
};
use cache::CacheEntry;
use command_line::{Args, ServerMode};
use errors::DhcpError;
use lru::LruCache;
use modes::{
    controller::Controller,
    dpu::{get_host_config, Dpu},
    fnn::Fnn,
    DhcpMode,
};
use serde::Deserialize;
use tokio::net::UdpSocket;
use tonic::async_trait;
use tracing::level_filters::LevelFilter;
use tracing_subscriber::{prelude::*, EnvFilter};
use utils::models::dhcp::{DhcpConfig, HostConfig};

pub struct Server {
    socket: Arc<UdpSocket>,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    let env_filter = EnvFilter::builder()
        .with_default_directive(LevelFilter::INFO.into())
        .from_env_lossy()
        .add_directive("tower=warn".parse().unwrap())
        .add_directive("rustls=warn".parse().unwrap())
        .add_directive("hyper=warn".parse().unwrap())
        .add_directive("tokio_util::codec=warn".parse().unwrap())
        .add_directive("h2=warn".parse().unwrap())
        .add_directive("hickory_resolver::error=info".parse().unwrap())
        .add_directive("hickory_proto::xfer=info".parse().unwrap())
        .add_directive("hickory_resolver::name_server=info".parse().unwrap())
        .add_directive("hickory_proto=info".parse().unwrap());
    let stdout_formatter = logfmt::layer();

    tracing_subscriber::registry()
        .with(stdout_formatter.with_filter(env_filter))
        .try_init()?;

    let args = Args::load();
    let config = init(args.clone()).await?;

    if let ServerMode::Controller = args.mode {
        if args.interfaces.len() != 1 {
            return Err(
                DhcpError::MultipleInterfacesProvidedOneSupported(args.interfaces.len()).into(),
            );
        }
    }

    let mut join_handle = vec![];

    // Create a new socket for each interface.
    // In case of Controller, there will be only 1 interface.
    for interface in args.interfaces {
        let config_clone = config.clone();
        let args_mode = args.mode.clone();
        let handle = tokio::spawn(async move {
            let handler: Box<dyn DhcpMode> = get_mode(&args_mode);
            let listen_address = SocketAddr::new(std::net::IpAddr::from([0, 0, 0, 0]), 67);

            // Create a socket2.socket. std and tokio sockets do not support advance options like
            // reuseaddr to be set.
            let socket = socket2::Socket::new(
                socket2::Domain::IPV4,
                socket2::Type::DGRAM,
                Some(socket2::Protocol::UDP),
            )
            .unwrap();
            socket.set_reuse_address(true).unwrap();
            socket.set_nonblocking(true).unwrap();
            socket.bind(&listen_address.into()).unwrap();
            let mut retries_left = 10;
            while retries_left > 0 && socket.bind_device(Some(interface.as_bytes())).is_err() {
                retries_left -= 1;
                tracing::info!(
                    "Interface {interface} not ready, retrying {retries_left} more times"
                );
                tokio::time::sleep(Duration::from_secs(2)).await;
            }
            if retries_left == 0 {
                panic!("Cannot bind interface {interface}.");
            }
            socket.set_broadcast(true).unwrap(); // Not for listening, but allowed for sending.

            // Now create tokio UDPSocket from socket2, which has all needed advanced options set.
            let socket = UdpSocket::from_std(socket.into()).unwrap();

            tracing::info!(
                "Listening on {:?} on interface: {}, mode: {:?}",
                listen_address,
                interface,
                handler
            );

            let server: Server = Server {
                socket: Arc::new(socket),
            };

            // Machine cache is used only in Controller mode and Controller listens only on one
            // interface, so it is ok to initialize cache here.
            let mut machine_cache =
                LruCache::new(std::num::NonZeroUsize::new(cache::MACHINE_CACHE_SIZE).unwrap());

            // Listen on each interface and process it.

            loop {
                let mut buf = [0; 1500];
                let (len, addr) = server.socket.recv_from(&mut buf).await.unwrap();

                // Not a valid packet.
                if len < MINIMUM_DHCP_PKT_SIZE {
                    tracing::error!("Dropping packet because it is smaller than min length.");
                    continue;
                }

                process(
                    addr,
                    server.socket.clone(),
                    &buf,
                    config_clone.clone(),
                    &*handler,
                    &interface,
                    &mut machine_cache,
                )
                .await;
            }
        });

        join_handle.push(handle);
    }

    for handle in join_handle {
        handle.await?;
    }

    Ok(())
}

fn get_mode(args_mode: &ServerMode) -> Box<dyn DhcpMode> {
    match args_mode {
        ServerMode::Dpu => Box::new(Dpu {}),
        ServerMode::Controller => Box::new(Controller {}),
        ServerMode::Fnn => Box::new(Fnn {}),
    }
}

#[derive(Debug, Clone)]
pub struct Config {
    dhcp_config: DhcpConfig,
    host_config: Option<HostConfig>, // Valid only for Dpu mode.
    fnn_config: Option<FnnConfig>,
}

#[derive(Debug, Clone, Deserialize)]
pub struct IpConfig {
    giaddr: Ipv4Addr,
    address: Ipv4Addr,
    fqdn: String,
}

#[derive(Debug, Clone, Deserialize)]
pub struct SubnetInfo {
    gateway: Ipv4Addr,
    prefix: String,
    ip: Vec<IpConfig>,
}

#[derive(Debug, Clone, Deserialize)]
pub struct FnnConfig {
    config: HashMap<String, SubnetInfo>,
}

async fn init(args: Args) -> Result<Config, DhcpError> {
    let f = tokio::fs::read_to_string(args.dhcp_config).await?;
    let dhcp_config: DhcpConfig = serde_yaml::from_str(&f)?;

    let host_config;
    if let ServerMode::Dpu = args.mode {
        host_config = get_host_config(args.host_config).await?;
    } else {
        host_config = None;
    };

    let fnn_config;
    if let ServerMode::Fnn = args.mode {
        fnn_config = modes::fnn::get_fnn_config(args.fnn_config).await?;
    } else {
        fnn_config = None;
    }

    Ok(Config {
        dhcp_config,
        host_config,
        fnn_config,
    })
}

#[derive(Debug)]
pub struct Test {}

#[async_trait]
impl DhcpMode for Test {
    async fn discover_dhcp(
        &self,
        _discovery_request: DhcpDiscovery,
        _config: &Config,
        _machine_cache: &mut LruCache<String, CacheEntry>,
    ) -> Result<DhcpRecord, DhcpError> {
        Ok(DhcpRecord {
            machine_id: Some(MachineId {
                id: "fm100dsbiu5ckus880v8407u0mkcensa39cule26im5gnpvmuufckacguc0".to_string(),
            }),
            machine_interface_id: Some(Uuid {
                value: "0fd6e9a3-06fc-4a22-ad29-aca299677b00".to_string(),
            }),
            segment_id: Some(Uuid {
                value: "55a2d74e-f9e1-49d5-bf99-be05171a5d75".to_string(),
            }),
            subdomain_id: Some(Uuid {
                value: "56a2d74e-f9e1-49d5-bf99-be05171a5d75".to_string(),
            }),
            fqdn: "seventeen-connecticut.dev3.frg.nvidia.com".to_string(),
            mac_address: "b8:3f:d2:90:9a:12".to_string(),
            address: "10.217.132.204".to_string(),
            mtu: 6000,
            prefix: "10.217.132.192/26".to_string(),
            gateway: Some("10.217.132.193".to_string()),
            booturl: None,
        })
    }

    async fn get_remote_id(
        &self,
        _host_config: &Option<HostConfig>,
    ) -> Result<Option<String>, DhcpError> {
        Ok(Some(
            "d33nk2ne8p59qr988hssbc84gb2b0s34vcq5j7pm5jnrbnhc6880".to_string(),
        ))
    }
}

const MINIMUM_DHCP_PKT_SIZE: usize = 236;

#[tracing::instrument(skip_all)]
async fn process(
    addr: SocketAddr,
    socket: Arc<UdpSocket>,
    buf: &[u8],
    config: Config,
    handler: &dyn DhcpMode,
    circuit_id: &str, // interface name
    machine_cache: &mut LruCache<String, CacheEntry>,
) {
    if !addr.is_ipv4() {
        tracing::error!("Dropping ivp6 packet.");
        return;
    }

    tracing::info!("Received packet [{}] from {}", buf[0], addr);

    let packet = match packet_handler::process_packet(
        buf,
        &config,
        circuit_id,
        handler,
        machine_cache,
    )
    .await
    {
        Ok(packet) => packet,
        Err(err) => {
            tracing::error!("Dropping packet because of error: {}", err);
            return;
        }
    };

    let dest_address = handler.get_destination_address(&packet);
    match packet.send(dest_address, socket).await {
        Ok(_) => {}
        Err(err) => {
            tracing::error!("Packet sending failed because of error: {}", err);
        }
    }
}

#[cfg(test)]
mod test {
    use std::{
        env,
        net::{Ipv4Addr, SocketAddrV4},
        path::PathBuf,
    };

    use dhcproto::{v4::Message, Decodable};
    use lru::LruCache;

    use crate::{cache, command_line::Args, init, packet_handler, DhcpMode, Test};

    fn get_test_args() -> Args {
        let base_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));

        Args {
            interfaces: vec!["eth0".to_string()],
            dhcp_config: base_path.join("conf/conf.yaml").display().to_string(),
            host_config: Some(
                base_path
                    .join("test/host_config.yaml")
                    .display()
                    .to_string(),
            ),
            mode: crate::command_line::ServerMode::Dpu,
            fnn_config: Some(base_path.join("test/fnn_config.yaml").display().to_string()),
        }
    }

    #[tokio::test]
    async fn test_init() {
        init(get_test_args()).await.unwrap();
    }

    #[tokio::test]
    async fn test_complete_flow_arm() {
        let byte_stream = vec![
            0x01, 0x01, 0x06, 0x00, 0x2c, 0xa1, 0x5b, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xb8, 0x3f, 0xd2, 0x90, 0x9a, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x82,
            0x53, 0x63, 0x35, 0x01, 0x03, 0x32, 0x04, 0x0a, 0xd9, 0x84, 0xcc, 0x0c, 0x29, 0x73,
            0x65, 0x76, 0x65, 0x6e, 0x74, 0x65, 0x65, 0x6e, 0x2d, 0x63, 0x6f, 0x6e, 0x6e, 0x65,
            0x63, 0x74, 0x69, 0x63, 0x75, 0x74, 0x2e, 0x64, 0x65, 0x76, 0x33, 0x2e, 0x66, 0x72,
            0x67, 0x2e, 0x6e, 0x76, 0x69, 0x64, 0x69, 0x61, 0x2e, 0x63, 0x6f, 0x6d, 0x37, 0x0d,
            0x01, 0x1c, 0x02, 0x03, 0x0f, 0x06, 0x77, 0x0c, 0x2c, 0x2f, 0x1a, 0x79, 0x2a, 0x3c,
            0x0d, 0x4e, 0x56, 0x49, 0x44, 0x49, 0x41, 0x2f, 0x42, 0x46, 0x2f, 0x4f, 0x4f, 0x42,
            0xff,
        ];
        let handler: Box<dyn DhcpMode> = Box::new(Test {});
        let config = init(get_test_args()).await.unwrap();
        let mut machine_cache =
            LruCache::new(std::num::NonZeroUsize::new(cache::MACHINE_CACHE_SIZE).unwrap());
        assert!(packet_handler::process_packet(
            &byte_stream,
            &config,
            "vlan200",
            &*handler,
            &mut machine_cache
        )
        .await
        .is_err());
    }

    #[tokio::test]
    async fn test_complete_flow() {
        let byte_stream = vec![
            0x01, 0x01, 0x06, 0x01, 0xfc, 0x02, 0xb0, 0xfc, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0xd9, 0x05, 0x29,
            0xb8, 0x3f, 0xd2, 0x90, 0x97, 0xe4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x82,
            0x53, 0x63, 0x35, 0x01, 0x01, 0x39, 0x02, 0x05, 0xc0, 0x37, 0x1b, 0x01, 0x02, 0x03,
            0x04, 0x05, 0x06, 0x0c, 0x0d, 0x0f, 0x11, 0x12, 0x16, 0x17, 0x1c, 0x28, 0x29, 0x2a,
            0x2b, 0x32, 0x33, 0x36, 0x3a, 0x3b, 0x3c, 0xa5, 0x43, 0x61, 0x61, 0x11, 0x00, 0x44,
            0x45, 0x4c, 0x4c, 0x4b, 0x00, 0x10, 0x4c, 0x80, 0x56, 0xca, 0xc0, 0x4f, 0x30, 0x52,
            0x33, 0x5e, 0x03, 0x01, 0x03, 0x10, 0x5d, 0x02, 0x00, 0x10, 0x3c, 0x21, 0x48, 0x54,
            0x54, 0x50, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x3a, 0x41, 0x72, 0x63, 0x68, 0x3a,
            0x30, 0x30, 0x30, 0x31, 0x36, 0x3a, 0x55, 0x4e, 0x44, 0x49, 0x3a, 0x30, 0x30, 0x33,
            0x30, 0x31, 0x36, 0x52, 0x45, 0x01, 0x07, 0x76, 0x6c, 0x61, 0x6e, 0x37, 0x35, 0x34,
            0x02, 0x34, 0x64, 0x33, 0x33, 0x6e, 0x6b, 0x32, 0x6e, 0x65, 0x38, 0x70, 0x35, 0x39,
            0x71, 0x72, 0x39, 0x38, 0x38, 0x68, 0x73, 0x73, 0x62, 0x63, 0x38, 0x34, 0x67, 0x62,
            0x32, 0x62, 0x30, 0x73, 0x33, 0x34, 0x76, 0x63, 0x71, 0x35, 0x6a, 0x37, 0x70, 0x6d,
            0x35, 0x6a, 0x6e, 0x72, 0x62, 0x6e, 0x68, 0x63, 0x36, 0x38, 0x38, 0x30, 0x05, 0x04,
            0x0a, 0xd9, 0x05, 0xa9, 0xff,
        ];
        let handler: Box<dyn DhcpMode> = Box::new(Test {});
        let config = init(get_test_args()).await.unwrap();
        let mut machine_cache =
            LruCache::new(std::num::NonZeroUsize::new(cache::MACHINE_CACHE_SIZE).unwrap());
        let packet = packet_handler::process_packet(
            &byte_stream,
            &config,
            "vlan200",
            &*handler,
            &mut machine_cache,
        )
        .await
        .unwrap();

        assert_eq!(
            packet.dst_address(),
            SocketAddrV4::new(Ipv4Addr::from([0x0a, 0xd9, 0x05, 0x29]), 67)
        );
        let packet = Message::decode(&mut dhcproto::Decoder::new(packet.encoded_packet())).unwrap();

        assert_eq!(packet.yiaddr(), Ipv4Addr::from([10, 217, 132, 204]));
    }

    #[tokio::test]
    async fn test_complete_flow_with_valid_ciaddr() {
        let byte_stream = vec![
            0x01, 0x01, 0x06, 0x01, 0xfc, 0x02, 0xb0, 0xfc, 0x00, 0x00, 0x80, 0x00, 0x0a, 0x01,
            0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0xd9, 0x05, 0x29,
            0xb8, 0x3f, 0xd2, 0x90, 0x97, 0xe4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x82,
            0x53, 0x63, 0x35, 0x01, 0x01, 0x39, 0x02, 0x05, 0xc0, 0x37, 0x1b, 0x01, 0x02, 0x03,
            0x04, 0x05, 0x06, 0x0c, 0x0d, 0x0f, 0x11, 0x12, 0x16, 0x17, 0x1c, 0x28, 0x29, 0x2a,
            0x2b, 0x32, 0x33, 0x36, 0x3a, 0x3b, 0x3c, 0xa5, 0x43, 0x61, 0x61, 0x11, 0x00, 0x44,
            0x45, 0x4c, 0x4c, 0x4b, 0x00, 0x10, 0x4c, 0x80, 0x56, 0xca, 0xc0, 0x4f, 0x30, 0x52,
            0x33, 0x5e, 0x03, 0x01, 0x03, 0x10, 0x5d, 0x02, 0x00, 0x10, 0x3c, 0x21, 0x48, 0x54,
            0x54, 0x50, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x3a, 0x41, 0x72, 0x63, 0x68, 0x3a,
            0x30, 0x30, 0x30, 0x31, 0x36, 0x3a, 0x55, 0x4e, 0x44, 0x49, 0x3a, 0x30, 0x30, 0x33,
            0x30, 0x31, 0x36, 0x52, 0x45, 0x01, 0x07, 0x76, 0x6c, 0x61, 0x6e, 0x37, 0x35, 0x34,
            0x02, 0x34, 0x64, 0x33, 0x33, 0x6e, 0x6b, 0x32, 0x6e, 0x65, 0x38, 0x70, 0x35, 0x39,
            0x71, 0x72, 0x39, 0x38, 0x38, 0x68, 0x73, 0x73, 0x62, 0x63, 0x38, 0x34, 0x67, 0x62,
            0x32, 0x62, 0x30, 0x73, 0x33, 0x34, 0x76, 0x63, 0x71, 0x35, 0x6a, 0x37, 0x70, 0x6d,
            0x35, 0x6a, 0x6e, 0x72, 0x62, 0x6e, 0x68, 0x63, 0x36, 0x38, 0x38, 0x30, 0x05, 0x04,
            0x0a, 0xd9, 0x05, 0xa9, 0xff,
        ];
        let handler: Box<dyn DhcpMode> = Box::new(Test {});
        let config = init(get_test_args()).await.unwrap();
        let mut machine_cache =
            LruCache::new(std::num::NonZeroUsize::new(cache::MACHINE_CACHE_SIZE).unwrap());
        let packet = packet_handler::process_packet(
            &byte_stream,
            &config,
            "vlan200",
            &*handler,
            &mut machine_cache,
        )
        .await
        .unwrap();

        assert_eq!(
            packet.dst_address(),
            SocketAddrV4::new(Ipv4Addr::from([10, 217, 5, 41]), 67)
        );

        let packet = Message::decode(&mut dhcproto::Decoder::new(packet.encoded_packet())).unwrap();

        assert_eq!(packet.yiaddr(), Ipv4Addr::from([10, 217, 132, 204]));
    }

    #[tokio::test]
    async fn validate_test_host_config() {
        let config = init(get_test_args()).await.unwrap();

        let host_config = config.host_config.unwrap();
        assert_eq!(host_config.host_ip_addresses.len(), 2);
        assert!(host_config.host_ip_addresses["vlan200"].booturl.is_none());
    }
}
