/*
 * SPDX-FileCopyrightText: Copyright (c) 2021-2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 * SPDX-License-Identifier: LicenseRef-NvidiaProprietary
 *
 * NVIDIA CORPORATION, its affiliates and licensors retain all intellectual
 * property and proprietary rights in and to this material, related
 * documentation and any modifications thereto. Any use, reproduction,
 * disclosure or distribution of this material and related documentation
 * without an express license agreement from NVIDIA CORPORATION or
 * its affiliates is strictly prohibited.
 */

/*!
 *  Code for working the measurement_bundles and measurement_bundles_values
 *  tables in the database, leveraging the bundle-specific record types.
*/

use crate::db::DatabaseError;
use crate::measured_boot::db;
use crate::measured_boot::db::machine::bundle_state_to_machine_state;
use crate::measured_boot::interface::bundle::{
    delete_bundle_for_id, delete_bundle_values_for_id, get_machines_for_bundle_id,
    get_measurement_bundle_by_id, get_measurement_bundle_for_name,
    get_measurement_bundle_records_for_profile_id, get_measurement_bundle_records_with_txn,
    get_measurement_bundle_values_for_bundle_id, insert_measurement_bundle_record,
    insert_measurement_bundle_value_records, rename_bundle_for_bundle_id,
    rename_bundle_for_bundle_name, update_state_for_bundle_id,
};
use crate::measured_boot::interface::common::pcr_register_values_to_map;
use crate::measured_boot::interface::report::match_latest_reports;
use crate::measured_boot::interface::{common, common::acquire_advisory_txn_lock};
use crate::{CarbideError, CarbideResult};
use forge_uuid::machine::MachineId;
use forge_uuid::measured_boot::{MeasurementBundleId, MeasurementSystemProfileId};
use itertools::Itertools;
use measured_boot::bundle::MeasurementBundle;
use measured_boot::journal::MeasurementJournal;
use measured_boot::pcr::PcrRegisterValue;
use measured_boot::records::{
    MeasurementBundleRecord, MeasurementBundleState, MeasurementBundleValueRecord,
};
use sqlx::{Postgres, Transaction};

pub async fn new_with_txn(
    txn: &mut Transaction<'_, Postgres>,
    profile_id: MeasurementSystemProfileId,
    name: Option<String>,
    values: &[PcrRegisterValue],
    state: Option<MeasurementBundleState>,
) -> CarbideResult<MeasurementBundle> {
    // Acquire an advisory lock (automatically released at the end of the txn),
    // whose hash key is generated by the PCR indexes + valuees, ensuring that a duplicate
    // bundle cannot be created during this time.
    acquire_advisory_txn_lock(txn, &pcr_values_to_string(values)).await?;

    if has_exact_from_values(txn, profile_id, values).await? {
        return Err(CarbideError::AlreadyFoundError {
            kind: "MeasurementBundle",
            id: String::from("(with same bundle values)"),
        });
    }

    let bundle_name = match name {
        Some(name) => name,
        None => common::generate_name()?,
    };

    let info = insert_measurement_bundle_record(txn, profile_id, bundle_name.clone(), state)
        .await
        .map_err(|sqlx_err| {
            let is_db_err = sqlx_err.as_database_error();
            match is_db_err {
                Some(db_err) => match db_err.kind() {
                    sqlx::error::ErrorKind::UniqueViolation => CarbideError::AlreadyFoundError {
                        kind: "MeasurementBundle",
                        id: bundle_name.clone(),
                    },
                    sqlx::error::ErrorKind::NotNullViolation => {
                        CarbideError::GenericError(format!(
                            "bundle missing not null value: {} (msg: {})",
                            bundle_name.clone(),
                            db_err
                        ))
                    }
                    _ => CarbideError::from(DatabaseError::new(
                        file!(),
                        line!(),
                        "MeasurementBundle.new_with_txn db_err",
                        sqlx_err,
                    )),
                },
                None => CarbideError::from(DatabaseError::new(
                    file!(),
                    line!(),
                    "MeasurementBundle.new_with_txn sqlx_err",
                    sqlx_err,
                )),
            }
        })?;

    let bundle_values =
        insert_measurement_bundle_value_records(txn, info.bundle_id, values).await?;
    let bundle = from_info_and_values(info, bundle_values)?;
    update_journal(&bundle, txn).await?;

    Ok(bundle)
}

/// from_info_and_values creates a new bundle from the
/// base record and its values.
pub fn from_info_and_values(
    info: MeasurementBundleRecord,
    values: Vec<MeasurementBundleValueRecord>,
) -> CarbideResult<MeasurementBundle> {
    Ok(MeasurementBundle {
        bundle_id: info.bundle_id,
        profile_id: info.profile_id,
        name: info.name,
        ts: info.ts,
        state: info.state,
        values,
    })
}

/// from_id_with_txn returns a fully populated instance of
/// MeasurementBundle for the provided `bundle_id`.
pub async fn from_id_with_txn(
    txn: &mut Transaction<'_, Postgres>,
    bundle_id: MeasurementBundleId,
) -> CarbideResult<MeasurementBundle> {
    match get_measurement_bundle_by_id(txn, bundle_id).await? {
        Some(info) => {
            let values = get_measurement_bundle_values_for_bundle_id(txn, info.bundle_id)
                .await
                .map_err(CarbideError::from)?;
            Ok(from_info_and_values(info, values)?)
        }
        None => Err(CarbideError::NotFoundError {
            kind: "MeasurementBundle",
            id: bundle_id.to_string(),
        }),
    }
}

/// from_name_with_txn returns a fully populated instance of
/// MeasurementBundle for the provided `bundle_name`.
pub async fn from_name_with_txn(
    txn: &mut Transaction<'_, Postgres>,
    bundle_name: String,
) -> CarbideResult<MeasurementBundle> {
    match get_measurement_bundle_for_name(txn, bundle_name.clone()).await? {
        Some(info) => {
            let values = get_measurement_bundle_values_for_bundle_id(txn, info.bundle_id).await?;
            Ok(from_info_and_values(info, values)?)
        }
        None => Err(CarbideError::NotFoundError {
            kind: "MeasurementBundle",
            id: bundle_name.clone(),
        }),
    }
}

/////////////////////////////////////////////////////
/// set_state_for_id sets the bundle state for
/// the given bundle ID.
/////////////////////////////////////////////////////

pub async fn set_state_for_id(
    txn: &mut Transaction<'_, Postgres>,
    bundle_id: MeasurementBundleId,
    state: MeasurementBundleState,
) -> CarbideResult<MeasurementBundle> {
    let info = set_state_for_bundle_id(txn, bundle_id, state).await?;
    let values = get_measurement_bundle_values_for_bundle_id(txn, info.bundle_id).await?;
    let bundle = from_info_and_values(info, values)?;
    update_journal(&bundle, txn).await?;
    Ok(bundle)
}

/////////////////////////////////////////////////////
/// get_all returns all populated MeasurementBundle
/// models from records in the database.
/////////////////////////////////////////////////////

pub async fn get_all(txn: &mut Transaction<'_, Postgres>) -> CarbideResult<Vec<MeasurementBundle>> {
    let mut res: Vec<MeasurementBundle> = Vec::new();
    let mut bundle_records = get_measurement_bundle_records_with_txn(txn).await?;
    for bundle_record in bundle_records.drain(..) {
        let values =
            get_measurement_bundle_values_for_bundle_id(txn, bundle_record.bundle_id).await?;
        res.push(from_info_and_values(bundle_record, values)?);
    }
    Ok(res)
}

/////////////////////////////////////////////////////
/// get_all_for_profile_id returns all populated
/// MeasurementBundle models for a given profile ID.
/////////////////////////////////////////////////////

pub async fn get_all_for_profile_id(
    txn: &mut Transaction<'_, Postgres>,
    profile_id: MeasurementSystemProfileId,
) -> CarbideResult<Vec<MeasurementBundle>> {
    let mut res: Vec<MeasurementBundle> = Vec::new();
    let mut bundle_records = get_measurement_bundle_records_for_profile_id(txn, profile_id).await?;
    for bundle_record in bundle_records.drain(..) {
        let values =
            get_measurement_bundle_values_for_bundle_id(txn, bundle_record.bundle_id).await?;
        res.push(from_info_and_values(bundle_record, values)?);
    }
    Ok(res)
}

/// has_exact_from_values is just a wrapper to make things
/// a little cleaner for potential callers of exact_from_values.
pub async fn has_exact_from_values(
    txn: &mut Transaction<'_, Postgres>,
    profile_id: MeasurementSystemProfileId,
    values: &[PcrRegisterValue],
) -> CarbideResult<bool> {
    match exact_from_values(txn, profile_id, values).await? {
        Some(_) => Ok(true),
        None => Ok(false),
    }
}

/// exact_from_values returns a fully populated instance of
/// MeasurementBundle that exactly matches the provided `values`.
pub async fn exact_from_values(
    txn: &mut Transaction<'_, Postgres>,
    profile_id: MeasurementSystemProfileId,
    values: &[PcrRegisterValue],
) -> CarbideResult<Option<MeasurementBundle>> {
    match match_from_values(txn, profile_id, values).await? {
        Some(bundle) => {
            if bundle.values.len() == values.len() {
                return Ok(Some(bundle));
            }
            Ok(None)
        }
        None => Ok(None),
    }
}

/// match_from_values returns a fully populated instance of
/// MeasurementBundle that matches the provided `values`.
pub async fn match_from_values(
    txn: &mut Transaction<'_, Postgres>,
    profile_id: MeasurementSystemProfileId,
    values: &[PcrRegisterValue],
) -> CarbideResult<Option<MeasurementBundle>> {
    let bundle_id = match match_bundle(txn, profile_id, values).await? {
        Some(bundle_id) => bundle_id,
        None => {
            return Ok(None);
        }
    };
    Ok(Some(from_id_with_txn(txn, bundle_id).await?))
}

/// delete deletes this bundle.
pub async fn delete(
    measurement_bundle: &MeasurementBundle,
    txn: &mut Transaction<'_, Postgres>,
    purge_journals: bool,
) -> CarbideResult<MeasurementBundle> {
    delete_for_id_with_txn(txn, measurement_bundle.bundle_id, purge_journals).await
}

pub async fn delete_for_id_with_txn(
    txn: &mut Transaction<'_, Postgres>,
    bundle_id: MeasurementBundleId,
    purge_journals: bool,
) -> CarbideResult<MeasurementBundle> {
    // Note that due to relational constraints, values must be
    // deleted before the parent record.
    if purge_journals {
        return Err(CarbideError::GenericError(String::from(
            "journal purge not implemented -- TODO",
        )));
    }
    let values = delete_bundle_values_for_id(txn, bundle_id).await?;
    let record = delete_bundle_for_id(txn, bundle_id).await?;
    match record {
        Some(record) => from_info_and_values(record, values),
        None => Err(CarbideError::NotFoundError {
            kind: "MeasurementBundleRecord",
            id: bundle_id.to_string(),
        }),
    }
}

/// rename_for_id renames a MeasurementBundle based on its ID.
pub async fn rename_for_id(
    txn: &mut Transaction<'_, Postgres>,
    bundle_id: MeasurementBundleId,
    new_bundle_name: String,
) -> CarbideResult<MeasurementBundle> {
    let info = rename_bundle_for_bundle_id(txn, bundle_id, new_bundle_name.clone())
        .await
        .map_err(CarbideError::from)?;
    match info {
        Some(info) => from_info_and_values(
            info,
            get_measurement_bundle_values_for_bundle_id(txn, bundle_id).await?,
        ),
        None => Err(CarbideError::NotFoundError {
            kind: "MeasurementBundleRecord",
            id: bundle_id.to_string(),
        }),
    }
}

/// rename_for_name renames a MeasurementBundle based on its name.
pub async fn rename_for_name(
    txn: &mut Transaction<'_, Postgres>,
    bundle_name: String,
    new_bundle_name: String,
) -> CarbideResult<MeasurementBundle> {
    let info =
        match rename_bundle_for_bundle_name(txn, bundle_name.clone(), new_bundle_name.clone())
            .await?
        {
            Some(info) => info,
            None => {
                return Err(CarbideError::NotFoundError {
                    kind: "MeasurementBundleRecord",
                    id: bundle_name.clone(),
                });
            }
        };
    let values = get_measurement_bundle_values_for_bundle_id(txn, info.bundle_id).await?;
    from_info_and_values(info, values)
}

/// delete_for_name deletes a MeasurementBundle and associated
/// MeasurementBundleValues, returning a fully populated instance of
/// MeasurementBundle of the data that was deleted for `bundle_id`.
pub async fn delete_for_name(
    txn: &mut Transaction<'_, Postgres>,
    bundle_name: String,
    purge_journals: bool,
) -> CarbideResult<MeasurementBundle> {
    // Note that due to relational constraints, values must be
    // deleted before the parent record.
    if purge_journals {
        return Err(CarbideError::GenericError(String::from(
            "journal purge not supported -- TODO",
        )));
    }
    let bundle = delete(
        &from_name_with_txn(txn, bundle_name.clone()).await?,
        txn,
        purge_journals,
    )
    .await?;
    Ok(bundle)
}

async fn update_journal(
    measurement_bundle: &MeasurementBundle,
    txn: &mut Transaction<'_, Postgres>,
) -> CarbideResult<Vec<MeasurementJournal>> {
    let machine_state = bundle_state_to_machine_state(&measurement_bundle.state);

    let reports = match_latest_reports(txn, &measurement_bundle.pcr_values()).await?;
    let mut updates: Vec<MeasurementJournal> = Vec::new();
    for report in reports.iter() {
        let machine = db::machine::from_id_with_txn(txn, report.machine_id.clone()).await?;
        let discovery_attributes = db::machine::discovery_attributes(&machine)?;
        let profile =
            db::profile::match_from_attrs_or_new_with_txn(txn, &discovery_attributes).await?;

        // Don't update journal entries for profiles
        // that aren't mine, since, in theory, two
        // different profiles could have the same
        // golden measurement bundles.
        if profile.profile_id != measurement_bundle.profile_id {
            continue;
        }
        updates.push(
            db::journal::new_with_txn(
                txn,
                report.machine_id.clone(),
                report.report_id,
                Some(profile.profile_id),
                Some(measurement_bundle.bundle_id),
                machine_state,
            )
            .await?,
        );
    }
    Ok(updates)
}

pub fn intersects(
    measurement_bundle: &MeasurementBundle,
    values: &[PcrRegisterValue],
) -> CarbideResult<bool> {
    let register_map = pcr_register_values_to_map(values)?;
    Ok(measurement_bundle.values.iter().all(|value_record| {
        if let Some(register_value) = register_map.get(&value_record.pcr_register) {
            register_value.sha256 == value_record.sha256
        } else {
            false
        }
    }))
}

/// get_machines returns a vector of MachineIds currently
/// associated with this bundle.
pub async fn get_machines(
    measurement_bundle: &MeasurementBundle,
    txn: &mut Transaction<'_, Postgres>,
) -> CarbideResult<Vec<MachineId>> {
    get_machines_for_bundle_id(txn, measurement_bundle.bundle_id)
        .await
        .map_err(CarbideError::from)
}

/// match_bundle takes a map of k/v pairs and returns a singular matching
/// bundle ID based on the exact k/v pairs and the number of pairs, should
/// one exist.
///
/// The code is written as such to only allow one bundle to match, so if two
/// matching bundles end up matching, it's because someone was messing around
/// in the tables (or there's a bug).
async fn match_bundle(
    txn: &mut Transaction<'_, Postgres>,
    profile_id: MeasurementSystemProfileId,
    values: &[PcrRegisterValue],
) -> CarbideResult<Option<MeasurementBundleId>> {
    // NOTE(chet): Here is a story!
    //
    // Just for reference, when there was a fixed set of values throughout
    // the codebase (e.g. PCR_VALUE_LENGTH was fixed at 7), this function
    // used to be as simple as the single line of code below. But, once it
    // was decided that the client could send a variable journal size, and
    // that an operator could approve which values to pull into a bundle,
    // it became slightly more complex, since then it went from matching a
    // journal -> bundle to finding bundles which intersected with the
    // provided journal.
    //
    // Ok(get_measurement_bundle_ids_by_values(txn, values).await?)
    //
    // The reason is I could just do where values in ((0,v1), (1,v2), ...),
    // and know there was always a distinct match against 7 values, easy
    // peasy. It's not like that anymore, and that's ok, but it does result
    // in a little more code.

    // Get all bundles, and figure out which *active* bundles intersect
    // with the provided journal. After that, we'll attempt to find the
    // most specific match (if there are multiple matches).
    let mut all_bundles = get_all_for_profile_id(txn, profile_id).await?;

    // TODO(chet): This could be moved somewhere more formal.
    let allowed_states = [
        MeasurementBundleState::Active,
        MeasurementBundleState::Obsolete,
    ];

    let mut matching: Vec<MeasurementBundle> = Vec::new();
    for bundle in all_bundles.drain(..) {
        if allowed_states.contains(&bundle.state) && intersects(&bundle, values)? {
            matching.push(bundle);
        }
    }

    // If there are no matching bundles, or a single matching
    // bundle, it's simple to handle here.
    if matching.is_empty() {
        return Ok(None);
    } else if matching.len() == 1 {
        return Ok(Some(matching[0].bundle_id));
    }

    // Otherwise, sort by the number of bundle values
    // in the bundle, and return the most specific bundle
    // match (as in, the most unique values, if there is
    // one). If there's a conflict, then return an error.
    matching.sort_by(|a, b| b.values.len().cmp(&a.values.len()));
    if matching[0].values.len() == matching[1].values.len() {
        return Err(CarbideError::GenericError(String::from(
            "cannot determine most specific bundle match",
        )));
    }

    Ok(Some(matching[0].bundle_id))
}

/// set_state_for_bundle_id sets a new state for a given bundle ID.
pub async fn set_state_for_bundle_id(
    txn: &mut Transaction<'_, Postgres>,
    bundle_id: MeasurementBundleId,
    state: MeasurementBundleState,
) -> Result<MeasurementBundleRecord, CarbideError> {
    match update_state_for_bundle_id(txn, bundle_id, state, false)
        .await
        .map_err(CarbideError::from)?
    {
        // Got a record back, which means the state was successfully
        // updated, so return it.
        Some(record) => Ok(record),

        // Didn't get one back, which means something happened, as in
        // either the bundle didn't exist, or the state is set to
        // revoked. If it's neither of those cases, that's fun.
        None => match get_measurement_bundle_by_id(txn, bundle_id).await? {
            None => Err(CarbideError::NotFoundError {
                kind: "MeasurementBundleRecord",
                id: bundle_id.to_string(),
            }),
            Some(existing_bundle) => {
                if existing_bundle.state == MeasurementBundleState::Revoked {
                    Err(CarbideError::GenericError(format!(
                        "bundle cannot be moved from revoked state: {}",
                        bundle_id
                    )))
                } else {
                    Err(CarbideError::GenericError(format!(
                        "totally unknown reason why this happened for bundle: {}",
                        bundle_id
                    )))
                }
            }
        },
    }
}

/// pcr_values_to_string takes a vec of PcrRegisterValue
/// and turns them into a consistent string sorted by PCR
/// register index, as a k:v (pcr_index:pcr_value), separated
/// by commas.
fn pcr_values_to_string(pcr_values: &[PcrRegisterValue]) -> String {
    let sorted_values = pcr_values
        .iter()
        .sorted_by_key(|value| value.pcr_register)
        .collect::<Vec<_>>();

    sorted_values
        .into_iter()
        .map(|value| format!("{}:{}", value.pcr_register, value.sha256))
        .collect::<Vec<_>>()
        .join(",")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pcr_values_to_string() {
        let pcr_values = vec![
            PcrRegisterValue {
                pcr_register: 8,
                sha256: String::from("ocho"),
            },
            PcrRegisterValue {
                pcr_register: 5,
                sha256: String::from("cinco"),
            },
            PcrRegisterValue {
                pcr_register: 1,
                sha256: String::from("uno"),
            },
        ];

        assert_eq!("1:uno,5:cinco,8:ocho", pcr_values_to_string(&pcr_values));
    }
}
