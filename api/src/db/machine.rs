//!
//! Machine - represents a database-backed Machine object
//!
use crate::{CarbideError, CarbideResult};
use ipnetwork::IpNetwork;
use log::{debug, info, warn};
use mac_address::MacAddress;
use sqlx::postgres::PgRow;
use sqlx::{Acquire, FromRow, Postgres, Row, Transaction};
use uuid::Uuid;

use std::convert::From;
use std::str;

use super::{
    AddressSelectionStrategy, MachineAction, MachineEvent, MachineInterface, MachineState,
    NetworkSegment,
};

use chrono::prelude::*;

use crate::human_hash;

use std::net::IpAddr;

use rpc::v0 as rpc;

///
/// A machine is a standalone system that performs network booting via normal DHCP processes.
///
#[derive(Debug)]
pub struct Machine {
    ///
    /// The UUID of the machine, this is an internal identifier in the database that's unique for
    /// all machines managed by this instance of carbide.
    ///
    id: uuid::Uuid,

    ///
    /// This is the FQDN of the machine that's used to access the machine remotely.  It's IP
    /// address is mapped to the IP address on the [MachineInterface][interface] that's `primary`.
    ///
    /// [interface]: crate::db::MachineInterface
    ///
    fqdn: String,

    /// When this machine record was created
    created: DateTime<Utc>,

    /// When the machine record was last modified
    modified: DateTime<Utc>,

    /// The current state of the machine
    state: MachineState,

    /// A list of [MachineEvent][event]s that this machine has experienced
    ///
    /// [event]: crate::db::MachineEvent
    events: Vec<MachineEvent>,

    /// A list of [MachineInterface][interface]s that this machine owns
    ///
    /// [event]: crate::db::MachineInterface
    interfaces: Vec<MachineInterface>,

    /// The cloud-init userdata for this node
    userdata: Option<String>,
}

impl<'r> FromRow<'r, PgRow> for Machine {
    fn from_row(row: &'r PgRow) -> Result<Self, sqlx::Error> {
        Ok(Machine {
            id: row.try_get("id")?,
            fqdn: row.try_get("fqdn")?,
            created: row.try_get("created")?,
            modified: row.try_get("modified")?,
            state: row.try_get("state")?,
            events: Vec::new(),
            interfaces: Vec::new(),
            userdata: row.try_get("userdata")?,
        })
    }
}

///
/// A parameter to find() to filter machines by Uuid;
///
pub enum MachineIdsFilter {
    /// Don't filter by uuid
    All,

    /// Filter by a list of uuids
    List(Vec<uuid::Uuid>),

    /// Retrieve a single machine
    One(uuid::Uuid),
}

///
/// Implements conversion from a database-backed `Machine` to a Protobuf representation of the
/// Machine.
///
impl From<Machine> for rpc::Machine {
    fn from(machine: Machine) -> Self {
        rpc::Machine {
            id: Some(machine.id.into()),
            fqdn: machine.fqdn,
            created: Some(rpc::Timestamp {
                seconds: machine.created.timestamp(),
                nanos: 0,
            }),
            modified: Some(rpc::Timestamp {
                seconds: machine.created.timestamp(),
                nanos: 0,
            }),
            state: Some(machine.state.into()),
            userdata: machine.userdata,
            events: machine
                .events
                .into_iter()
                .map(|event| event.into())
                .collect(),
            interfaces: machine
                .interfaces
                .into_iter()
                .map(|interface| interface.into())
                .collect(),
        }
    }
}

impl Machine {
    /// Create a machine object in the database
    ///
    /// Arguments:
    ///
    /// * `txn` - A reference to a currently open database transaction
    /// * `fqdn` - initial hostname used to identify this host
    ///
    pub async fn create(txn: &mut Transaction<'_, Postgres>, fqdn: String) -> CarbideResult<Self> {
        let row: (Uuid,) = sqlx::query_as("INSERT INTO machines (fqdn) VALUES ($1) RETURNING id")
            .bind(&fqdn)
            .fetch_one(&mut *txn)
            .await?;

        match Machine::find_one(&mut *txn, row.0).await {
            Ok(Some(x)) => Ok(x),
            Ok(None) => Err(CarbideError::DatabaseInconsistencyOnMachineCreate(row.0)),
            Err(x) => Err(x),
        }
    }

    pub async fn find_one(
        txn: &mut Transaction<'_, Postgres>,
        uuid: uuid::Uuid,
    ) -> CarbideResult<Option<Self>> {
        Machine::find(txn, MachineIdsFilter::One(uuid))
            .await
            .map(|v| v.into_iter().next())
    }

    pub fn generate_hostname_from_uuid(uuid: &uuid::Uuid) -> String {
        human_hash::humanize(uuid, 2)
    }

    /// Discovery of a machine
    ///
    /// A machine has DHCPed and we will attempt to find a machine in the database, or we create
    /// one with an autogenerated hostname using the default domain name found in the
    /// [NetworkSegment][crate::db::NetworkSegment] identified by the DHCP relay's network this
    /// DHCP DISCOVER request was found.
    ///
    /// Arguments:
    ///
    /// * `txn` - A reference to a currently open database transaction
    /// * `macaddr` - The mac_address::MacAddress of the booting machine
    /// * `relay` - The IP address of the DHCP relay servicing the request.
    pub async fn discover(
        txn: &mut Transaction<'_, Postgres>,
        macaddr: MacAddress,
        relay: IpAddr,
    ) -> CarbideResult<Self> {
        // Find machines that have the mac address on the subnet being relayed
        // It's possible to have duplicate mac addresses on different subnets.
        let sql = r#"
        SELECT m.id FROM
            machines m
            INNER JOIN machine_interfaces mi
                ON m.id = mi.machine_id
            INNER JOIN network_segments ns
                ON mi.segment_id = ns.id
            WHERE
                mi.mac_address = $1::macaddr
                AND
                (($2::inet <<= ns.subnet_ipv4) OR ($2::inet <<= ns.subnet_ipv6));
        "#;

        let mut machine_ids: Vec<(Uuid,)> = sqlx::query_as(sql)
            .bind(macaddr)
            .bind(IpNetwork::from(relay))
            .fetch_all(&mut *txn)
            .await?;

        match &machine_ids.len() {
            0 => {
                info!("No existing machine with mac address {} using network with relay: {}, creating one.", macaddr, relay);

                match NetworkSegment::for_relay(txn, relay).await? {
                    Some(segment) => {
                        let generated_hostname =
                            Self::generate_hostname_from_uuid(&uuid::Uuid::new_v4());
                        let generated_fqdn =
                            format!("{}.{}", generated_hostname, segment.subdomain());

                        debug!("Generated hostname {}", generated_fqdn);

                        let mut txn2 = txn.begin().await?;

                        let machine = Machine::create(&mut txn2, generated_fqdn).await?;

                        let _ = MachineInterface::create(
                            &mut txn2,
                            &machine,
                            &segment,
                            &macaddr,
                            &AddressSelectionStrategy::Automatic(true),
                            &AddressSelectionStrategy::Automatic(true),
                        )
                        .await?;

                        txn2.commit().await?;

                        Ok(Self::find(txn, MachineIdsFilter::List(vec![machine.id()]))
                            .await?
                            .remove(0))
                    }
                    None => Err(CarbideError::NoNetworkSegmentsForRelay(relay)),
                }
            }
            1 => {
                let id = machine_ids.remove(0);
                Machine::find_one(txn, id.0).await.and_then(|machine| {
                    if let Some(machine) = machine {
                        Ok(machine)
                    } else {
                        Err(CarbideError::DatabaseInconsistencyOnMachineCreate(id.0))
                    }
                })
            }
            _ => {
                warn!(
                    "More than one mac address ({0}) for network segment (relay ip: {1})",
                    &macaddr, &relay
                );
                Err(CarbideError::NetworkSegmentDuplicateMacAddress(macaddr))
            }
        }
    }

    /// Returns the UUID of the machine object
    pub fn id(&self) -> uuid::Uuid {
        self.id
    }

    /// Returns the std::time::SystemTime for when the machine was initially discovered
    pub fn created(&self) -> chrono::DateTime<Utc> {
        self.created
    }

    /// Returns the std::time::SystemTime for when the machine was last updated
    pub fn modified(&self) -> chrono::DateTime<Utc> {
        self.modified
    }

    /// Returns a reference to the FQDN of the machine
    pub fn fqdn(&self) -> &str {
        &self.fqdn
    }

    /// Returns the list of Events the machine has experienced
    pub fn events(&self) -> &Vec<MachineEvent> {
        &self.events
    }

    /// Returns the list of Interfaces this machine owns
    pub fn interfaces(&self) -> &Vec<MachineInterface> {
        &self.interfaces
    }

    /// Update this machine's FQDN
    ///
    /// This updates the machines FQDN which will render the old name in-accessible after the DNS
    /// TTL expires on recursive resolvers.  The authoritative resolver is updated immediately.
    ///
    /// Arguments:
    ///
    /// * `txn` - A reference to a currently open database transaction
    /// * `new_fqdn` - The new FQDN, which is subject to DNS validation rules (todo!())
    pub async fn update_fqdn(
        &mut self,
        txn: &mut Transaction<'_, Postgres>,
        new_fqdn: &str,
    ) -> CarbideResult<&Machine> {
        let (fqdn, timestamp) =
            sqlx::query_as("UPDATE machines SET fqdn=$1 RETURNING fqdn,modified")
                .bind(new_fqdn)
                .fetch_one(txn)
                .await?;

        self.fqdn = fqdn;
        self.modified = timestamp;

        Ok(self)
    }

    /// Return the current state of the machine based on the sequence of events the machine has
    /// experienced.
    ///
    /// This object does not store the current state, but calculates it from the actions that have
    /// been performed on the machines.
    ///
    /// Arguments:
    ///
    /// * `txn` - A reference to a currently open database transaction
    ///
    pub async fn current_state(
        &self,
        txn: &mut Transaction<'_, Postgres>,
    ) -> CarbideResult<MachineState> {
        MachineState::for_machine(self, txn).await
    }

    /// Perform an arbitrary action to a Machine and advance it to the next state given the last
    /// state.
    ///
    /// Arguments:
    ///
    /// * `txn` - A reference to a currently open database transaction
    /// * `action` - A reference to a MachineAction enum
    ///
    pub async fn advance(
        &self,
        txn: &mut Transaction<'_, Postgres>,
        action: &MachineAction,
    ) -> CarbideResult<bool> {
        let id: (Uuid,) = sqlx::query_as(
            "INSERT INTO machine_events (machine_id, action) VALUES ($1, $2) RETURNING id",
        )
        .bind(self.id())
        .bind(action)
        .fetch_one(txn)
        .await?;

        log::info!("Event ID is {}", id.0);

        Ok(true)
    }

    /// Perform action `Fail` on the Machine advancing it to the next state given the last
    /// state
    ///
    /// Arguments:
    ///
    /// * `txn` - A reference to a currently open database transaction
    ///
    pub async fn fail(&self, txn: &mut Transaction<'_, Postgres>) -> CarbideResult<bool> {
        self.advance(txn, &MachineAction::Fail).await
    }

    /// Perform action `Commission` on the Machine advancing it to the next state given the last
    /// state
    ///
    /// Arguments:
    ///
    /// * `txn` - A reference to a currently open database transaction
    ///
    pub async fn commission(&self, txn: &mut Transaction<'_, Postgres>) -> CarbideResult<bool> {
        self.advance(txn, &MachineAction::Commission).await
    }

    /// Find machines given a set of criteria, right now just returns all machines because there's
    /// no way to filter the machines.
    ///
    /// TODO(ajf): write a query langauge???
    ///
    /// Arguments:
    ///
    /// * `txn` - A reference to a currently open database transaction
    ///
    pub async fn find(
        txn: &mut Transaction<'_, Postgres>,
        id_filter: MachineIdsFilter,
    ) -> CarbideResult<Vec<Machine>> {
        let base_query = "SELECT m.*,machine_state_machine(me.action,me.version) AS state FROM machines m JOIN machine_events me ON me.machine_id=m.id {where} GROUP BY m.id".to_owned();

        let mut all_machines: Vec<Machine> = match id_filter {
            MachineIdsFilter::All => {
                sqlx::query_as::<_, Machine>(&base_query.replace("{where}", ""))
                    .fetch_all(&mut *txn)
                    .await?
            }
            MachineIdsFilter::One(uuid) => {
                sqlx::query_as::<_, Machine>(&base_query.replace("{where}", "WHERE m.id=$1"))
                    .bind(uuid)
                    .fetch_all(&mut *txn)
                    .await?
            }
            MachineIdsFilter::List(list) => {
                sqlx::query_as::<_, Machine>(&base_query.replace("{where}", "WHERE m.id=ANY($1)"))
                    .bind(list)
                    .fetch_all(&mut *txn)
                    .await?
            }
        };

        let all_uuids = all_machines.iter().map(|m| m.id()).collect::<Vec<Uuid>>();

        let mut events_for_machine =
            MachineEvent::find_by_machine_ids(&mut *txn, all_uuids.as_slice()).await?;

        let mut interfaces_for_machine =
            MachineInterface::find_by_machine_ids(&mut *txn, all_uuids.as_slice()).await?;

        all_machines.iter_mut().for_each(|machine| {
            if let Some(events) = events_for_machine.remove(&machine.id) {
                machine.events = events;
            } else {
                warn!("Machine {0} ({1}) has no events", machine.id, machine.fqdn);
            }

            if let Some(interfaces) = interfaces_for_machine.remove(&machine.id) {
                machine.interfaces = interfaces;
            } else {
                warn!(
                    "Machine {0} ({1}) has no interfaces",
                    machine.id, machine.fqdn
                );
            }
        });

        Ok(all_machines)
    }
}

#[cfg(test)]
mod test {}
