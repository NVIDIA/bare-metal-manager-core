use std::{collections::HashMap, fmt::Write};

use chrono::Utc;
use forge_uuid::machine::MachineId;
use futures_util::stream::StreamExt;
use sqlx::{Acquire, Postgres, Transaction};

use crate::{
    CarbideError,
    db::{self, DatabaseError, machine::MachineSearchConfig},
    model::{
        machine::capabilities::MachineCapabilityInfiniband,
        sku::{
            Sku, SkuComponentChassis, SkuComponentCpu, SkuComponentGpu,
            SkuComponentInfinibandDevices, SkuComponentMemory, SkuComponents, diff_skus,
        },
    },
};

/// Find a SKU that matches the specified SKU using the same comparison that
/// the SKU validation code uses. (i.e. the description, id and others are not compared)
///
/// The specified SKU must not exist in the DB (otherwise it will always be the match).
pub async fn find_matching(
    txn: &mut Transaction<'_, Postgres>,
    sku: &Sku,
) -> Result<Option<Sku>, DatabaseError> {
    let query = "SELECT * FROM machine_skus";

    let mut sku_stream = sqlx::query_as(query).fetch(&mut **txn);

    while let Some(result) = sku_stream.next().await {
        match result {
            Ok(existing_sku) => {
                let diffs = diff_skus(sku, &existing_sku);
                if diffs.is_empty() {
                    return Ok(Some(existing_sku));
                }
            }
            Err(sqlx::Error::RowNotFound) => {}
            Err(e) => return Err(DatabaseError::new(file!(), line!(), "create sku", e)),
        }
    }

    Ok(None)
}

pub async fn create(txn: &mut Transaction<'_, Postgres>, sku: &Sku) -> Result<(), CarbideError> {
    let mut inner_txn = txn
        .begin()
        .await
        .map_err(|e| DatabaseError::new(file!(), line!(), "begin", e))?;

    let query = "LOCK TABLE instance_addresses IN ACCESS EXCLUSIVE MODE";
    sqlx::query(query)
        .execute(&mut *inner_txn)
        .await
        .map_err(|e| DatabaseError::new(file!(), line!(), query, e))?;

    if let Some(existing_sku) = find_matching(&mut inner_txn, sku).await? {
        return Err(CarbideError::InvalidArgument(format!(
            "Specified SKU matches SKU with ID: {}",
            existing_sku.id
        )));
    }

    // purposely leaves out Created.  it will be generated by the DB.
    let query =
        "INSERT INTO machine_skus (id, description, components) values ($1, $2, $3) RETURNING id";

    let _: () = sqlx::query_as(query)
        .bind(&sku.id)
        .bind(&sku.description)
        .bind(sqlx::types::Json(&sku.components))
        .fetch_one(&mut *inner_txn)
        .await
        .map_err(|e| DatabaseError::new(file!(), line!(), "create sku", e))?;

    inner_txn
        .commit()
        .await
        .map_err(|e| DatabaseError::new(file!(), line!(), "commit create sku", e))?;

    Ok(())
}

pub async fn delete(
    txn: &mut Transaction<'_, Postgres>,
    sku_id: &str,
) -> Result<String, DatabaseError> {
    // purposely leaves out Id and Created.  they will be generated by the DB.
    let query = "DELETE FROM machine_skus WHERE id=$1 RETURNING id";

    let (id,): (String,) = sqlx::query_as(query)
        .bind(sku_id)
        .fetch_one(&mut **txn)
        .await
        .map_err(|e| DatabaseError::new(file!(), line!(), "create sku", e))?;

    Ok(id)
}

pub async fn get_sku_ids(
    txn: &mut Transaction<'_, Postgres>,
) -> Result<Vec<String>, DatabaseError> {
    let query = "SELECT id FROM machine_skus";

    let skus: Vec<(String,)> = sqlx::query_as(query)
        .fetch_all(&mut **txn)
        .await
        .map_err(|e| DatabaseError::new(file!(), line!(), "get sku ids", e))?;

    Ok(skus.into_iter().map(|v| v.0).collect())
}

pub async fn find(
    txn: &mut Transaction<'_, Postgres>,
    sku_ids: &[String],
) -> Result<Vec<Sku>, DatabaseError> {
    let query = "SELECT * FROM machine_skus WHERE id=ANY($1)";

    let skus: Vec<Sku> = sqlx::query_as(query)
        .bind(sku_ids)
        .fetch_all(&mut **txn)
        .await
        .map_err(|e| DatabaseError::new(file!(), line!(), "find skus", e))?;

    if skus.is_empty() {
        return Err(DatabaseError::new(
            file!(),
            line!(),
            "find skus",
            sqlx::Error::RowNotFound,
        ));
    }
    Ok(skus)
}

pub async fn from_topology(
    txn: &mut Transaction<'_, Postgres>,
    machine_id: &MachineId,
) -> Result<Sku, DatabaseError> {
    let created = Utc::now();

    let Some(machine) = db::machine::find(
        txn,
        db::ObjectFilter::One(*machine_id),
        MachineSearchConfig {
            include_predicted_host: true,
            ..Default::default()
        },
    )
    .await?
    .into_iter()
    .next() else {
        return Err(DatabaseError::new(
            file!(),
            line!(),
            "sku_from_topology",
            sqlx::Error::RowNotFound,
        ));
    };

    let Some(hardware_info) = machine.hardware_info.as_ref() else {
        return Err(DatabaseError::new(
            file!(),
            line!(),
            "sku_from_topology",
            sqlx::Error::RowNotFound,
        ));
    };

    let chassis = SkuComponentChassis {
        vendor: hardware_info
            .dmi_data
            .as_ref()
            .map(|dd| dd.sys_vendor.clone())
            .unwrap_or_default(),
        model: hardware_info
            .dmi_data
            .as_ref()
            .map(|dd| dd.product_name.clone())
            .unwrap_or_default(),
        architecture: hardware_info.machine_type.to_string(),
    };

    let mut cpus_per_slot: HashMap<u32, SkuComponentCpu> = HashMap::default();
    for cpu in &hardware_info.cpus {
        cpus_per_slot
            .entry(cpu.socket)
            .and_modify(|entry| entry.thread_count += 1)
            .or_insert(SkuComponentCpu {
                vendor: cpu.vendor.clone(),
                model: cpu.model.clone(),
                thread_count: 1,
                count: 1,
            });
    }

    let mut cpus: HashMap<String, SkuComponentCpu> = HashMap::default();
    for cpu in cpus_per_slot {
        cpus.entry(cpu.1.model.clone())
            .and_modify(|entry| entry.count += 1)
            .or_insert(cpu.1);
    }

    let mut gpu_components: HashMap<(String, String), SkuComponentGpu> = HashMap::default();
    for gpu in &hardware_info.gpus {
        let vendor = "NVIDIA".to_string();
        let key = (gpu.name.clone(), gpu.total_memory.clone());
        gpu_components
            .entry(key)
            .and_modify(|entry| entry.count += 1)
            .or_insert(SkuComponentGpu {
                vendor,
                model: gpu.name.clone(),
                count: 1,
                total_memory: gpu.total_memory.clone(),
            });
    }

    let mut mem_components: HashMap<(String, u32), SkuComponentMemory> = HashMap::default();
    let mut total_mem = 0u64;
    for mem in &hardware_info.memory_devices {
        if let Some(cap) = mem.size_mb {
            total_mem += cap as u64;
            let key = (mem.mem_type.clone().unwrap_or_default(), cap);
            mem_components
                .entry(key.clone())
                .and_modify(|entry| entry.count += 1)
                .or_insert(SkuComponentMemory {
                    capacity_mb: key.1,
                    memory_type: key.0,
                    count: 1,
                });
        }
    }

    let ib_capabilities = MachineCapabilityInfiniband::from_ib_interfaces_and_status(
        &hardware_info.infiniband_interfaces,
        machine.infiniband_status_observation.as_ref(),
    );
    let ib_components: Vec<SkuComponentInfinibandDevices> = ib_capabilities
        .into_iter()
        .map(|cap| SkuComponentInfinibandDevices {
            vendor: cap.vendor,
            model: cap.name,
            count: cap.count,
            inactive_devices: cap.inactive_devices,
        })
        .collect();

    let mut description = format!(
        "{}; {}xCPU; {}xGPU; {}",
        chassis.model,
        cpus.values().map(|v| v.count).sum::<u32>(),
        gpu_components.values().map(|v| v.count).sum::<u32>(),
        ::utils::sku::capacity_string(total_mem)
    );
    let num_ib_devices = ib_components.iter().map(|c| c.count).sum::<u32>();
    if num_ib_devices != 0 {
        write!(&mut description, "; {}xIB", num_ib_devices).unwrap();
    }

    Ok(Sku {
        id: format!("{} {}", chassis.model.clone(), Utc::now()),
        description,
        created,
        components: SkuComponents {
            chassis,
            cpus: cpus.into_values().collect(),
            gpus: gpu_components.into_values().collect(),
            memory: mem_components.into_values().collect(),
            infiniband_devices: ib_components,
        },
    })
}
