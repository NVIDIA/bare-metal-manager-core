use std::{collections::BTreeMap, fmt::Write};

use chrono::Utc;
use forge_uuid::machine::MachineId;
use futures_util::stream::StreamExt;
use itertools::Itertools;
use sqlx::{Acquire, PgConnection};

use crate::{
    CarbideError,
    db::{self, DatabaseError, machine::MachineSearchConfig},
    model::{
        machine::capabilities::{MachineCapabilitiesSet, MachineCapabilityInfiniband},
        sku::{
            Sku, SkuComponentChassis, SkuComponentCpu, SkuComponentGpu,
            SkuComponentInfinibandDevices, SkuComponentMemory, SkuComponentStorage, SkuComponents,
            diff_skus,
        },
    },
};

/// The current version of the SKU format.  The state machine will create older
/// versions from hardware using the currently assigned sku's version so that
/// SKUs can maintain backward compatibility
pub const CURRENT_SKU_VERSION: u32 = 2;

/// Find a SKU that matches the specified SKU using the same comparison that
/// the SKU validation code uses. (i.e. the description, id and others are not compared)
///
/// The specified SKU must not exist in the DB (otherwise it will always be the match).
pub async fn find_matching(
    txn: &mut PgConnection,
    sku: &Sku,
) -> Result<Option<Sku>, DatabaseError> {
    let query = "SELECT * FROM machine_skus";

    let mut sku_stream = sqlx::query_as(query).fetch(txn);

    while let Some(result) = sku_stream.next().await {
        match result {
            Ok(existing_sku) => {
                let diffs = diff_skus(sku, &existing_sku);
                if diffs.is_empty() {
                    return Ok(Some(existing_sku));
                }
            }
            Err(sqlx::Error::RowNotFound) => {}
            Err(e) => return Err(DatabaseError::new("find matching sku", e)),
        }
    }

    Ok(None)
}

pub async fn create(txn: &mut PgConnection, sku: &Sku) -> Result<(), CarbideError> {
    if sku.schema_version != CURRENT_SKU_VERSION {
        return Err(CarbideError::InvalidArgument(
            "SKU version is no longer supported".to_string(),
        ));
    }

    const DB_TXN_NAME: &str = "sku::create";
    let mut inner_txn = txn
        .begin()
        .await
        .map_err(|e| DatabaseError::txn_begin(DB_TXN_NAME, e))?;

    let query = "LOCK TABLE machine_skus IN ACCESS EXCLUSIVE MODE";
    sqlx::query(query)
        .execute(&mut *inner_txn)
        .await
        .map_err(|e| DatabaseError::query(query, e))?;

    if let Some(existing_sku) = find_matching(&mut inner_txn, sku).await? {
        return Err(CarbideError::InvalidArgument(format!(
            "Specified SKU matches SKU with ID: {}",
            existing_sku.id
        )));
    }

    // purposely leaves out Created.  it will be generated by the DB.
    let query = "INSERT INTO machine_skus (id, description, components, schema_version) values ($1, $2, $3, $4) RETURNING id";

    let _: () = sqlx::query_as(query)
        .bind(&sku.id)
        .bind(&sku.description)
        .bind(sqlx::types::Json(&sku.components))
        .bind(sku.schema_version as i32)
        .fetch_one(&mut *inner_txn)
        .await
        .map_err(|e| DatabaseError::new("create sku", e))?;

    inner_txn
        .commit()
        .await
        .map_err(|e| DatabaseError::txn_commit(DB_TXN_NAME, e))?;

    Ok(())
}

pub async fn delete(txn: &mut PgConnection, sku_id: &str) -> Result<String, DatabaseError> {
    // purposely leaves out Created.  it will be generated by the DB.
    let query = "DELETE FROM machine_skus WHERE id=$1 RETURNING id";

    let (id,): (String,) = sqlx::query_as(query)
        .bind(sku_id)
        .fetch_one(txn)
        .await
        .map_err(|e| DatabaseError::query(query, e))?;

    Ok(id)
}

pub async fn get_sku_ids(txn: &mut PgConnection) -> Result<Vec<String>, DatabaseError> {
    let query = "SELECT id FROM machine_skus";

    let skus: Vec<(String,)> = sqlx::query_as(query)
        .fetch_all(txn)
        .await
        .map_err(|e| DatabaseError::new("get sku ids", e))?;

    Ok(skus.into_iter().map(|v| v.0).collect())
}

pub async fn find(txn: &mut PgConnection, sku_ids: &[String]) -> Result<Vec<Sku>, DatabaseError> {
    if sku_ids.is_empty() {
        return Ok(Vec::new());
    }

    let query = "SELECT * FROM machine_skus WHERE id=ANY($1)";

    let skus: Vec<Sku> = sqlx::query_as(query)
        .bind(sku_ids)
        .fetch_all(txn)
        .await
        .map_err(|e| DatabaseError::new("find skus", e))?;

    Ok(skus)
}

pub async fn update_metadata(
    txn: &mut PgConnection,
    sku_id: String,
    description: Option<String>,
    device_type: Option<String>,
) -> Result<(), DatabaseError> {
    if description.is_none() && device_type.is_none() {
        return Err(DatabaseError::new(
            "Update SKU Metadata",
            sqlx::Error::InvalidArgument("desciption and/or device_type required".to_string()),
        ));
    }

    let mut builder = sqlx::QueryBuilder::new("UPDATE machine_skus SET ".to_string());
    if let Some(description) = description {
        builder.push(" description = ");
        builder.push_bind(description);
        if device_type.is_some() {
            builder.push(",");
        }
    }

    if let Some(device_type) = device_type {
        builder.push(" device_type = ");
        builder.push_bind(device_type);
    }

    builder.push(" WHERE id = ");
    builder.push_bind(sku_id);
    builder.push(" RETURNING id");

    let _: (String,) = builder
        .build_query_as()
        .fetch_one(&mut *txn)
        .await
        .map_err(|err| DatabaseError::query(builder.sql(), err))?;

    Ok(())
}

pub async fn replace_components(
    txn: &mut PgConnection,
    sku_id: &str,
    components: SkuComponents,
) -> Result<Sku, DatabaseError> {
    let query = "UPDATE machine_skus SET components = $1 WHERE id= $2 RETURNING *";
    let sku = sqlx::query_as(query)
        .bind(sqlx::types::Json(&components))
        .bind(sku_id)
        .fetch_one(&mut *txn)
        .await
        .map_err(|err| DatabaseError::query(query, err))?;

    crate::db::machine::update_sku_status_verify_request_time_for_sku(txn, sku_id).await?;
    Ok(sku)
}

pub async fn generate_sku_from_machine(
    txn: &mut PgConnection,
    machine_id: &MachineId,
) -> Result<Sku, DatabaseError> {
    generate_sku_from_machine_at_version(txn, machine_id, CURRENT_SKU_VERSION).await
}

pub async fn generate_sku_from_machine_at_version(
    txn: &mut PgConnection,
    machine_id: &MachineId,
    schema_version: u32,
) -> Result<Sku, DatabaseError> {
    match schema_version {
        0 | 1 => generate_sku_from_machine_at_version_0_or_1(txn, machine_id, schema_version).await,
        2 => generate_sku_from_machine_at_version_2(txn, machine_id).await,
        _ => Err(DatabaseError::new(
            "generate_sku_from_machine_at_version",
            sqlx::Error::RowNotFound,
        )),
    }
}

pub async fn generate_sku_from_machine_at_version_0_or_1(
    txn: &mut PgConnection,
    machine_id: &MachineId,
    schema_version: u32,
) -> Result<Sku, DatabaseError> {
    let created = Utc::now();

    let Some(machine) = db::machine::find(
        txn,
        db::ObjectFilter::One(*machine_id),
        MachineSearchConfig {
            include_predicted_host: true,
            ..Default::default()
        },
    )
    .await?
    .into_iter()
    .next() else {
        return Err(DatabaseError::new(
            "sku_from_topology",
            sqlx::Error::RowNotFound,
        ));
    };

    let Some(hardware_info) = machine.hardware_info.as_ref() else {
        return Err(DatabaseError::new(
            "sku_from_topology",
            sqlx::Error::RowNotFound,
        ));
    };

    let chassis = SkuComponentChassis {
        vendor: hardware_info
            .dmi_data
            .as_ref()
            .map(|dd| dd.sys_vendor.clone())
            .unwrap_or_default(),
        model: hardware_info
            .dmi_data
            .as_ref()
            .map(|dd| dd.product_name.clone())
            .unwrap_or_default(),
        architecture: hardware_info.machine_type.to_string(),
    };

    let mut gpu_components: BTreeMap<(String, String), SkuComponentGpu> = BTreeMap::default();
    for gpu in &hardware_info.gpus {
        let vendor = "NVIDIA".to_string();
        let key = (gpu.name.clone(), gpu.total_memory.clone());
        gpu_components
            .entry(key)
            .and_modify(|entry| entry.count += 1)
            .or_insert(SkuComponentGpu {
                vendor,
                model: gpu.name.clone(),
                count: 1,
                total_memory: gpu.total_memory.clone(),
            });
    }

    let mut mem_components: BTreeMap<(String, u32), SkuComponentMemory> = BTreeMap::default();
    let mut total_mem = 0u64;
    for mem in &hardware_info.memory_devices {
        if let Some(cap) = mem.size_mb {
            total_mem += cap as u64;
            let key = (mem.mem_type.clone().unwrap_or_default(), cap);
            mem_components
                .entry(key.clone())
                .and_modify(|entry| entry.count += 1)
                .or_insert(SkuComponentMemory {
                    capacity_mb: key.1,
                    memory_type: key.0,
                    count: 1,
                });
        }
    }

    let ib_capabilities = MachineCapabilityInfiniband::from_ib_interfaces_and_status(
        &hardware_info.infiniband_interfaces,
        machine.infiniband_status_observation.as_ref(),
    );
    let ib_components: Vec<SkuComponentInfinibandDevices> = ib_capabilities
        .into_iter()
        .map(|cap| SkuComponentInfinibandDevices {
            vendor: cap.vendor,
            model: cap.name,
            count: cap.count,
            inactive_devices: cap.inactive_devices,
        })
        .collect();

    let mut description = format!(
        "{}; {}xCPU; {}xGPU; {}",
        chassis.model,
        hardware_info
            .cpu_info
            .iter()
            .map(|v| v.sockets)
            .sum::<u32>(),
        gpu_components.values().map(|v| v.count).sum::<u32>(),
        ::utils::sku::capacity_string(total_mem)
    );
    let num_ib_devices = ib_components.iter().map(|c| c.count).sum::<u32>();
    if num_ib_devices != 0 {
        write!(&mut description, "; {num_ib_devices}xIB").unwrap();
    }

    let storage = if schema_version >= 1 {
        let mut storage: BTreeMap<String, SkuComponentStorage> = BTreeMap::new();
        for block_device in &hardware_info.block_devices {
            storage
                .entry(block_device.model.clone())
                .and_modify(|s| s.count += 1)
                .or_insert(SkuComponentStorage {
                    model: block_device.model.clone(),
                    count: 1,
                });
        }
        storage
    } else {
        BTreeMap::default()
    };

    Ok(Sku {
        schema_version,
        id: format!("{} {}", chassis.model, Utc::now()),
        description,
        created,
        components: SkuComponents {
            chassis,
            cpus: hardware_info
                .cpu_info
                .iter()
                .map(SkuComponentCpu::from)
                .collect(),
            gpus: gpu_components.into_values().collect(),
            memory: mem_components.into_values().collect(),
            infiniband_devices: ib_components,
            storage: storage.into_values().collect(),
        },
        device_type: None,
    })
}

pub async fn generate_sku_from_machine_at_version_2(
    txn: &mut PgConnection,
    machine_id: &MachineId,
) -> Result<Sku, DatabaseError> {
    let created = Utc::now();

    let Some(machine) = db::machine::find(
        txn,
        db::ObjectFilter::One(*machine_id),
        MachineSearchConfig {
            include_predicted_host: true,
            ..Default::default()
        },
    )
    .await?
    .into_iter()
    .next() else {
        return Err(DatabaseError::new(
            "sku_from_topology",
            sqlx::Error::RowNotFound,
        ));
    };

    let Some(hardware_info) = machine.hardware_info.as_ref() else {
        return Err(DatabaseError::new(
            "sku_from_topology",
            sqlx::Error::RowNotFound,
        ));
    };

    let capabilities = MachineCapabilitiesSet::from_hardware_info(
        hardware_info.clone(),
        machine.infiniband_status_observation.as_ref(),
        machine.associated_dpu_machine_ids(),
        machine.interfaces.clone(),
    );

    let chassis = SkuComponentChassis {
        vendor: hardware_info
            .dmi_data
            .as_ref()
            .map(|dd| dd.sys_vendor.clone())
            .unwrap_or_default(),
        model: hardware_info
            .dmi_data
            .as_ref()
            .map(|dd| dd.product_name.clone())
            .unwrap_or_default(),
        architecture: hardware_info.machine_type.to_string(),
    };

    let cpus: Vec<SkuComponentCpu> = capabilities
        .cpu
        .into_iter()
        .map(|c| SkuComponentCpu {
            vendor: c.vendor.unwrap_or_default(),
            model: c.name,
            thread_count: c.threads.unwrap_or_default(),
            count: c.count,
        })
        .sorted()
        .collect();

    let gpus: Vec<SkuComponentGpu> = capabilities
        .gpu
        .into_iter()
        .map(|g| SkuComponentGpu {
            vendor: g.vendor.unwrap_or("NVIDIA".to_owned()),
            model: g.name,
            total_memory: g.memory_capacity.unwrap_or_default(),
            count: g.count,
        })
        .sorted()
        .collect();

    let mut mem_components: BTreeMap<(String, u32), SkuComponentMemory> = BTreeMap::default();
    let mut total_mem = 0u64;
    for mem in &hardware_info.memory_devices {
        if let Some(cap) = mem.size_mb {
            total_mem += cap as u64;
            let key = (mem.mem_type.clone().unwrap_or_default(), cap);
            mem_components
                .entry(key.clone())
                .and_modify(|entry| entry.count += 1)
                .or_insert(SkuComponentMemory {
                    capacity_mb: key.1,
                    memory_type: key.0,
                    count: 1,
                });
        }
    }

    let infiniband_devices: Vec<SkuComponentInfinibandDevices> = capabilities
        .infiniband
        .into_iter()
        .map(|cap| SkuComponentInfinibandDevices {
            vendor: cap.vendor,
            model: cap.name,
            count: cap.count,
            inactive_devices: cap.inactive_devices,
        })
        .sorted()
        .collect();

    let mut description = format!(
        "{}; {}xCPU; {}xGPU; {}",
        chassis.model,
        cpus.iter().map(|v| v.count).sum::<u32>(),
        gpus.iter().map(|v| v.count).sum::<u32>(),
        ::utils::sku::capacity_string(total_mem)
    );
    let num_ib_devices = infiniband_devices.iter().map(|c| c.count).sum::<u32>();
    if num_ib_devices != 0 {
        write!(&mut description, "; {num_ib_devices}xIB").unwrap();
    }

    // Storage cannot be pulled from capabilities (yet).  The block device hardware inventory has duplicate entries
    // for disk and partitions on that disk.  The NVME device inventory is a duplicate of the disk entries
    // in the block device, and so is ignored.  TODO: move to use capabilities when available.
    let mut storage: BTreeMap<String, SkuComponentStorage> = BTreeMap::default();
    for s in hardware_info
        .block_devices
        .iter()
        .filter(|s| s.device_type == "disk")
    {
        storage
            .entry(s.model.clone())
            .and_modify(|s| s.count += 1)
            .or_insert(SkuComponentStorage {
                model: s.model.clone(),
                count: 1,
            });
    }

    Ok(Sku {
        schema_version: CURRENT_SKU_VERSION,
        id: format!("{} {}", chassis.model, Utc::now()),
        description,
        created,
        components: SkuComponents {
            chassis,
            cpus,
            gpus,
            memory: mem_components.into_values().collect(),
            infiniband_devices,
            storage: storage.into_values().collect(),
        },
        device_type: None,
    })
}
