/*
 * SPDX-FileCopyrightText: Copyright (c) 2021-2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 * SPDX-License-Identifier: LicenseRef-NvidiaProprietary
 *
 * NVIDIA CORPORATION, its affiliates and licensors retain all intellectual
 * property and proprietary rights in and to this material, related
 * documentation and any modifications thereto. Any use, reproduction,
 * disclosure or distribution of this material and related documentation
 * without an express license agreement from NVIDIA CORPORATION or
 * its affiliates is strictly prohibited.
 */
use log::LevelFilter;

use carbide::db::tags::{Tag, TagAssociation, TagCreate, TagDelete, TagTargetKind, TagsList};

const FIXTURE_CREATED_MACHINE_ID: &str = "fm100dsasb5dsh6e6ogogslpovne4rj82rp9jlf00qd7mcvmaadv85phk3g";

#[ctor::ctor]
fn setup() {
    pretty_env_logger::formatted_timed_builder()
        .filter_level(LevelFilter::Warn)
        .init();
}

#[sqlx::test(fixtures("create_domain", "create_vpc", "create_network_segment"))]
async fn tag_create_and_list(pool: sqlx::PgPool) -> Result<(), Box<dyn std::error::Error>> {
    let mut txn = pool
        .begin()
        .await
        .expect("Unable to create transaction on database pool");

    let tag = TagCreate {
        tag: Some(Tag {
            id: None,
            slug: "testtag".into(),
            name: Some("Test Tag".into()),
        }),
    };

    tag.create(&mut txn).await?;

    txn.commit().await.unwrap();

    let mut txn = pool
        .begin()
        .await
        .expect("Unable to create transaction on database pool");

    let mut all_tags = Tag::list_all(&mut txn).await?;

    let created_tag = all_tags.tags.pop().unwrap();

    assert_eq!(created_tag.slug, "testtag".to_string());
    assert_eq!(created_tag.name.unwrap(), "Test Tag".to_string());

    Ok(())
}

#[sqlx::test(fixtures("create_domain", "create_vpc", "create_network_segment"))]
async fn tag_deletion(pool: sqlx::PgPool) -> Result<(), Box<dyn std::error::Error>> {
    let mut txn = pool.begin().await?;

    let tag = TagCreate {
        tag: Some(Tag {
            id: None,
            slug: "testtag".into(),
            name: Some("Test Tag".into()),
        }),
    };

    tag.create(&mut txn).await?;
    txn.commit().await?;

    let mut txn = pool.begin().await?;

    TagDelete { tag: tag.tag }.delete(&mut txn).await?;

    Ok(())
}

#[sqlx::test(fixtures(
    "create_domain",
    "create_vpc",
    "create_network_segment",
    "create_machine"
))]
async fn tag_assign_and_remove(pool: sqlx::PgPool) -> Result<(), Box<dyn std::error::Error>> {
    let mut txn = pool.begin().await?;

    let tag = TagCreate {
        tag: Some(Tag {
            id: None,
            slug: "testtag".into(),
            name: Some("Test Tag".into()),
        }),
    };

    tag.create(&mut txn).await?;

    txn.commit().await.unwrap();

    let mut txn = pool.begin().await?;

    let testassociation = TagAssociation {
        tag_id: None,
        slug: Some("testtag".to_string()),
        target: FIXTURE_CREATED_MACHINE_ID,
        target_kind: TagTargetKind::Machine,
    };

    testassociation.assign(&mut txn).await?;

    txn.commit().await?;

    let mut txn = pool.begin().await?;

    let testassociation = TagAssociation {
        tag_id: None,
        slug: Some("testtag".to_string()),
        target: FIXTURE_CREATED_MACHINE_ID,
        target_kind: TagTargetKind::Machine,
    };

    let result = testassociation.remove(&mut txn).await;

    txn.commit().await?;

    assert!(matches!(result, Ok(_)));

    Ok(())
}

#[sqlx::test(fixtures(
    "create_domain",
    "create_vpc",
    "create_network_segment",
    "create_machine"
))]
async fn test_set_tags(pool: sqlx::PgPool) -> Result<(), Box<dyn std::error::Error>> {
    // Create tag first to delete.
    let mut txn = pool.begin().await?;

    TagCreate {
        tag: Some(Tag {
            id: None,
            slug: "testtag".into(),
            name: Some("Test Tag".into()),
        }),
    }
    .create(&mut txn)
    .await?;

    txn.commit().await?;
    let mut txn = pool.begin().await?;

    TagCreate {
        tag: Some(Tag {
            id: None,
            slug: "testtag1".into(),
            name: Some("Test Tag".into()),
        }),
    }
    .create(&mut txn)
    .await?;

    txn.commit().await?;

    let mut txn = pool.begin().await?;

    TagsList {
        slugs: vec!["testtag".to_string(), "testtag1".to_string()],
        target: FIXTURE_CREATED_MACHINE_ID,
        target_kind: TagTargetKind::Machine,
    }
    .assign(&mut txn)
    .await?;

    txn.commit().await?;
    Ok(())
}
